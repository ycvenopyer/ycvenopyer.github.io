<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024 Fall 需求与商业模式创新复习</title>
      <link href="/2025/01/03/command-and-innovation-of-commercial-modes-review/"/>
      <url>/2025/01/03/command-and-innovation-of-commercial-modes-review/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-1-期末考核要求"><a href="#Part-1-期末考核要求" class="headerlink" title="Part 1 期末考核要求"></a>Part 1 期末考核要求</h2><h3 id="1-商业模式部分（60分）"><a href="#1-商业模式部分（60分）" class="headerlink" title="1.商业模式部分（60分）"></a>1.商业模式部分（60分）</h3><p>概述：基于给定背景和题目的知识点运用</p><p>商业模式画布绘制+需求类型 – 20</p><p>商业模式类型讨论 – 10</p><ul><li>优先考察与互联网最相关的三个</li></ul><p>商业模式设计 – 20</p><ul><li>六种设计手段选两个考核</li></ul><p>商业模式评估 – 10</p><ul><li>三种评估手段选一个考核（复杂的手段会被适当地提示和约减，修订：2024年总体评估与SWOT在大作业中被合并了，因此你可以认为是一种评估手段，也可以认为是两种）</li></ul><h3 id="2-需求部分（40分）"><a href="#2-需求部分（40分）" class="headerlink" title="2.需求部分（40分）"></a>2.需求部分（40分）</h3><p>需求获取（20分）</p><ul><li>需求获取上半段（10分）：<ul><li>确定项目前景与范围 – 目标模型</li><li>涉众分析 – 涉众评估之Power-Interest、Power-Attitude模型、涉众共赢之Stakeholder-Issue模型</li></ul></li><li>需求获取下半段（10分）：<ul><li>面谈、原型、观察三大获取手段的联系与区别</li><li>面谈问题的设计</li></ul></li></ul><p>需求分析（10分）</p><ul><li>需求分析的根本任务与活动</li></ul><p>需求验证与管理（10分）</p><ul><li>需求验证基本活动</li><li>需求管理任务与活动</li><li>需求变更控制过程与组织、需求变更注意事项</li></ul><h2 id="Part-2-知识点总结"><a href="#Part-2-知识点总结" class="headerlink" title="Part 2 知识点总结"></a>Part 2 知识点总结</h2><h3 id="1-商业模式画布绘制"><a href="#1-商业模式画布绘制" class="headerlink" title="1.商业模式画布绘制"></a>1.商业模式画布绘制</h3><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241215201746151.png" alt="1"></p><h4 id="1-1-客户细分（CS）"><a href="#1-1-客户细分（CS）" class="headerlink" title="1.1 客户细分（CS）"></a>1.1 客户细分（CS）</h4><p><strong>一家企业想要获得的和期望服务的不同的目标人群和机构</strong>的划分方式：</p><ul><li><p>大众市场（mass market）消费电子、大型零售商（找人群共性）</p></li><li><p>小众市场（niche market）：产业链上的供应商-采购商（强业务特征）</p></li><li><p>求同存异的客户群体（segmented）：各类产品线、诺基亚（某业务下基于客户共性的细分）</p></li><li><p>多元化客户群体（diversified）：3M、YAMAHA、AMAZON&#x2F;阿里、SAMSUNG、华为（垄断地位、技术领先与外拓、团队能力与开拓意识强）</p></li><li><p>多边平台&#x2F;市场（multi-sided platforms&#x2F;markets）：大型互联网平台、B站（大流量、上升为生活方式的使用习惯，多种收益流的平衡与补贴）</p></li></ul><p>客户细分条件：</p><ul><li>需求催生新供给</li><li>需要新分销渠道和客户关系类型</li><li>产生的利润率不同</li><li>愿意为某方面的特殊改进买单</li></ul><h4 id="1-2-价值主张（VP）"><a href="#1-2-价值主张（VP）" class="headerlink" title="1.2 价值主张（VP）"></a>1.2 价值主张（VP）</h4><p><strong>为某一客户群体提供能为其创造价值的产品和服务</strong></p><ul><li>一家公司为特定客户群体提供的利益集合或组合</li><li>解决客户的问题或满足其需求，使其选择一家而放弃另一家</li></ul><p>有益于价值创造的因素：</p><ul><li>创新：满足<strong>客户未曾察觉全新需求（没有类似产品的）</strong>，可以是非技术创新的</li><li>让事情更简单（痛点）：价格、缩减成本、便利性&#x2F;实用性</li><li>让事情更“复杂”（收益）：定制、设计、品牌地位、可获得性</li><li>让事情“透明”（痛点）：风险控制、一站式服务</li></ul><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241215202651536.png" alt="2"></p><h4 id="1-3-渠道通路（CH）"><a href="#1-3-渠道通路（CH）" class="headerlink" title="1.3 渠道通路（CH）"></a>1.3 渠道通路（CH）</h4><p><strong>一家企业如何同它的客户群体达成沟通并建立联系，以向对方传递自身的价值主张</strong></p><ul><li><p>企业与客户交互体系：交流、分销、销售渠道（+售后），是用户的交互触点</p></li><li><p>作用：了解产品与服务、评估价值主张；购买产品与服务、传递价值主张；提供售后支持</p></li><li><p><strong>商业真正的秘密，与产品设计的关系微妙（实现层面重合度小，却又容易受到产品口碑风险的冲击，需要做到真正的匹配），容易积累收益但波动性极大、风险高</strong></p></li><li><p><strong>一定要重视渠道 – 设计运维一体化，最容易产生新闻的地方，要能够从渠道构建与运维看出隐含的价值主张与客户关系</strong></p></li><li><p>渠道五个阶段</p><ul><li>认知：我们如何在客户中提升公司产品和服务的认知？</li><li>评估：我们如何帮助客户评估公司价值主张？</li><li>购买：我们如何协助客户购买特定的产品和服务？</li><li>传递：我们如何把价值主张传递给客户？</li><li>售后：我们如何提供售后支持？</li></ul></li><li><p>一个渠道可包含一个或全部五个阶段</p></li><li><p>一个组织可选用自有渠道、合作方渠道、或混用，以追求获益与成本的平衡以及最佳的客户体验</p></li></ul><h4 id="1-4-客户关系（CR）"><a href="#1-4-客户关系（CR）" class="headerlink" title="1.4 客户关系（CR）"></a>1.4 客户关系（CR）</h4><p><strong>一家企业针对某个客户群体所建立的客户关系的类型</strong></p><ul><li>靠人员维护VS自动化设备</li><li><strong>动机：开发新客户、留住原客户、增加销售量或客单价</strong>（携程杀熟、杀苹果用户）</li><li>免费推广-<strong>提升忠诚度（全家桶、归属感、情怀）</strong>-提高客单价</li><li>新手礼包&#x2F;老用户激活礼包-品牌宣传与建设&#x2F;用户等级-老客户专属套餐</li></ul><p>客户关系类型：</p><ul><li>私人服务</li><li>专属私人服务</li><li>自助服务</li><li>自动化服务</li><li>社区</li><li>客户共同创造</li><li>多边平台商业模式：尽可能多的容纳新用户类型并促进各方交互</li></ul><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241215222405092.png" alt="3"></p><h4 id="1-5-收入来源（R-）"><a href="#1-5-收入来源（R-）" class="headerlink" title="1.5 收入来源（R$）"></a>1.5 收入来源（R$）</h4><p><strong>企业从每一个客户群体获得的现金收益</strong></p><ul><li>两类收益来源：一次性交易收入、持续收入</li><li>定价机制：<ul><li>固定（基于静态变量）：目录价、基于产品特性、基于客户群、基于数量</li><li>浮动（基于动态变量）：谈判&#x2F;议价、收益管理、实时市场价格、拍卖</li></ul></li></ul><p>收入来源的方式：</p><ul><li>资产销售 asset sale：实物产品所有权转让，消费者拥有处置的全部权利</li><li>使用费 usage fee：电信、宾馆、快递、<em>付费网游点卡、公共交通车票</em></li><li>会员费 subscription fee：健身卡、付费网游月卡、<em>公共交通月票</em>、音乐会员</li><li>租赁 lending&#x2F;renting&#x2F;leasing：共享单车&#x2F;汽车&#x2F;<strong>充电宝</strong>，特定资产在特定时间的使用权转移并获益</li><li>许可使用费 licensing：专利授权、版权（图片、音乐、字体）、<strong>加盟或特许经营</strong></li><li>经纪人佣金 brokerage fees：信用卡（交易手续费）、支付平台（交易与提现手续费）、中介</li><li>广告费 advertising：传媒、品牌策划、软件业与服务业；<em>广告费增长乏力，分蛋糕的太多</em></li></ul><p>进一步谈论：三级价格歧视（差异定价）</p><ul><li>按人（杀价、拍卖、杀熟）</li><li>按量（批发、团购、套餐、优惠券、峰谷阶梯定价）</li><li>按类（可选择的差异化服务：氪金、VIP、加急、视频会员、精装与典藏、机票折扣、社交裂变与私域流量）</li></ul><h4 id="1-6-核心资源（KR）"><a href="#1-6-核心资源（KR）" class="headerlink" title="1.6 核心资源（KR）"></a>1.6 核心资源（KR）</h4><p><strong>保证一个商业模式顺利运行所需的最重要的资产。</strong></p><p>用于：价值主张的创造与提供、开拓市场、维护客户关系并获益。</p><p>可以自主拥有或者寻求合作。</p><p>“拥有”意味着额外的管理、折旧和风险，“合作”意味着让出的利润空间与不可持续的风险。</p><p>核心意味着稀缺与不可替代，需要花费巨大的成本维系。核心中的核心：对细分客户的认知和对价值主张的塑造。</p><p>类型：</p><ul><li>实物资源 physical：生产设备、房屋、车辆、机器、系统、销售点管理系统、分销渠道</li><li>知识性资源 intellectual：品牌（可口可乐）、专利（高通与华为）、知识产权与体系（微软、SAP）</li><li>人力资源 human：普遍存在，对于创新性和知识密集产业最重要（如IT业），出色的营销团队</li><li>金融资源 financial：车贷、GE的膨胀与衰落、电商金融</li></ul><h4 id="1-7-关键业务（KA）"><a href="#1-7-关键业务（KA）" class="headerlink" title="1.7 关键业务（KA）"></a>1.7 关键业务（KA）</h4><p><strong>保障其商业模式正常运行所需做的最重要的事情。</strong></p><ul><li>与价值主张强相关，价值主张的具象化</li></ul><p>类型：</p><ul><li>生产：包含分销网络、渠道等</li><li>解决方案：知识管理与持续的培训</li><li>平台&#x2F;网络：XX网、Visa卡、操作系统、应用商店、游戏平台</li></ul><p>企业如何构建自身技术护城河？</p><ul><li>商业模式创新 – 构建不可替代的关键业务 – 支撑服务升级 – 基础设施投资 –底层技术突破 – 拥有&#x2F;强化核心资源</li></ul><h4 id="1-8-重要合作（KP）"><a href="#1-8-重要合作（KP）" class="headerlink" title="1.8 重要合作（KP）"></a>1.8 重要合作（KP）</h4><p><strong>保证一个商业模式顺利运行所需的供应商和合作伙伴网络。</strong></p><ul><li>非竞争者之间的战略联盟</li><li>竞争者之间的战略合作</li><li>新业务的合资公司</li><li>稳定供应关系的供应商和采购商</li></ul><p>合作动机：</p><ul><li>优化与规模效应——提高业务效率：降低成本，外包或共享基础设施</li><li>特殊资源及活动的获得——获得核心资源：高技术产品、销售团队、特许商品、渠道</li><li>降低风险和不确定性——降低业务风险</li></ul><h4 id="1-9-成本结构（C-）"><a href="#1-9-成本结构（C-）" class="headerlink" title="1.9 成本结构（C$）"></a>1.9 成本结构（C$）</h4><p><strong>运营一个商业模式所发生的全部成本。</strong></p><p>导向：</p><ul><li>成本导向：成本最小化，创造并维持极尽精简的成本结构</li><li>价值导向：高端的价值主张与高度的个性化服务</li></ul><p>特点：</p><ul><li>固定成本：管理员工工资，租金，生产设备</li><li>可变成本：加工工人工资，加班费，广告推广费，水电，原材料消耗</li><li>规模经济：大宗购买，大规模生产摊薄的固定成本</li><li>范围经济：渠道的复用（摊薄部分可变成本）</li></ul><h3 id="2-商业模式类型讨论"><a href="#2-商业模式类型讨论" class="headerlink" title="2.商业模式类型讨论"></a>2.商业模式类型讨论</h3><h4 id="2-1-多边平台商业模式"><a href="#2-1-多边平台商业模式" class="headerlink" title="2.1 多边平台商业模式"></a>2.1 多边平台商业模式</h4><p>多边平台将两个或更多独立但相互依存的客户群体进行连接</p><ul><li><p><strong>促进群体互动造价值</strong></p></li><li><p>一个多边平台的价值提升在于它所吸引的用户数量的增加</p></li></ul><blockquote><p>谷歌的商业模式：平台推广</p><p>建立并维护搜索引擎的基础设施</p><p>三大功能：Google.com,AdWords,AdSense的管理</p><p>AdWords——搜索栏广告；AdSense——网站内广告</p><p>将平台推广给新用户、新内容提供商、新广告商</p><p>如：Gmail,Chrome,GoogleMap,Android-GMS</p></blockquote><p>总结：</p><ul><li>价值主张一般体现在如下三方面：吸引用户、群体配对、利用平台交易渠道降低交易成本</li><li>客户群体相互依存，无法独立</li><li>核心资源是平台，成本主要来自于平台的维护和开发。三项关键活动：平台管理、服务实现、平台升级</li><li>多个收益流，补贴正确的客户群是定价决策的关键</li></ul><h4 id="2-2-免费商业模式"><a href="#2-2-免费商业模式" class="headerlink" title="2.2 免费商业模式"></a>2.2 免费商业模式</h4><p>至少有一个关键的客户群体可以持续免费地享受服务</p><ul><li><strong>其它方面补贴免费产品</strong></li><li>不付费客户所得到的财务支持来自于另一个客户群体</li><li>对价格为0的商品的需求要数倍于定价为1分钱或更高的商品</li></ul><p>三种可行的免费商业模式：</p><ul><li>共同点：至少一个群体将得到免费的商品</li><li>广告模式：基于多变平台的免费商品</li><li>免费增值：免费的基本服务，可选的增值服务</li><li>诱饵&amp;陷阱：以免费或很便宜的初始价格吸引客户，并引导其重复购买</li></ul><h5 id="2-2-1-广告"><a href="#2-2-1-广告" class="headerlink" title="2.2.1 广告"></a>2.2.1 广告</h5><p>示例：Metro、Facebook</p><p>总结：</p><ul><li>关键业务：好的产品和服务以及高流量会吸引广告商，进而补贴产品和服务。要考虑广告费能否支撑起产品服务质量。</li><li>成本：平台的开发和维护，以及可能的获客与维系成本。</li></ul><h5 id="2-2-2-免费增值"><a href="#2-2-2-免费增值" class="headerlink" title="2.2.2 免费增值"></a>2.2.2 免费增值</h5><p>收入形式：大量用户从免费服务获益，少量用户为增值服务付费。两个关键指标：关注免费用户服务成本和增值用户转化率。</p><p>示例：百度网盘、OneDrive；开源：Redhat(GPL许可证)；Skype；微信与腾信增值服务</p><p>保险：倒转的免费增值。大部分客户定期支付小额保费以补贴一小部分产生实际索赔的客户。瑞士REGA直升机救援。常见的强制险：五险一金、出国旅游意外险。</p><p>总结：</p><ul><li><p>核心资源：平台是最重要的资产，产生三部分成本：可观的固定成本、免费账户的低边际成本服务、增值账户成本</p></li><li><p>关键业务：客户关系自动且低成本，免费用户向增值用户转化率是重要指标</p></li><li><p>收入来源三个重要公式：</p><p>收入&#x3D; 用户数量×增值用户比重×增值服务价格×增长率×顾客流失率</p><p>服务成本 &#x3D; 免费用户数×免费服务成本+增值用户数×增值服务成本</p><p>运营利润 &#x3D; 收入 - 服务成本 - 固定成本 - 获客成本</p></li><li><p>平台发展新趋势：高水平、差异化的产品与服务（为免费增值提供空间）</p></li></ul><p>反转免费模式举例：Cookpad食谱网站。发展思路：丰富企业服务与媒体功能，推进线下运营与会员转化。</p><h5 id="2-2-3-诱饵-陷阱"><a href="#2-2-3-诱饵-陷阱" class="headerlink" title="2.2.3 诱饵&amp;陷阱"></a>2.2.3 诱饵&amp;陷阱</h5><p>示例：免费手机、吉列剃须刀</p><p>总结：</p><ul><li>核心业务：产品与后续产品之间要有紧密连接，从而使得极小收益的初始购买为后续高收益产品或服务的重复购买创造可能</li><li>关注后续产品交付，需要强大品牌支撑</li><li>重要成本结构：初始产品补贴与后续产品的成本</li><li>慢慢融入平台与免费增值：新套餐体验+自动续费；游戏本体+DLC</li></ul><h4 id="2-3-长尾商业模式"><a href="#2-3-长尾商业模式" class="headerlink" title="2.3 长尾商业模式"></a>2.3 长尾商业模式</h4><p><strong>专注于多种类产品销售。</strong></p><p>提供相当多种类的小众产品，每类卖出量相对很少，但汇总的销售收入可以与传统模式销售媲美。</p><ul><li>行业内20%的产品占据绝大多数销量</li><li>长尾模式专注于销售剩下80%内尽可能多的品类，并获得可媲美主流产品销售的收入</li><li>在高效的互联网渠道加持下，专注某领域的部分单品销售也能构成长尾</li></ul><p>出现的原因：</p><ul><li>生产工具的普及</li><li>销售渠道的普及</li><li>连接供需双方的搜寻成本降低</li></ul><p>示例：</p><ol><li>图书出版：生产与渠道的工具化，资产生产与销售转向佣金与平台使用费</li><li>乐高数字在线：生产（本身标准化程度高）与渠道的复用，提高用户忠诚度，挖掘用户额外需求</li></ol><p>为长尾内容服务的主流类型平台：</p><ul><li><p>B站——官方号，Up主，二创</p></li><li><p>Steam——正版代理，创意工坊</p></li></ul><p>为长尾内容服务的长尾类型平台：A站</p><p>长尾的发展趋势：坚持——转化</p><ul><li>长尾之后：突破因传统生产、设计、营销导致的二八曲线，长尾部分扁平化；形成若干“小众中心”，并分别向“大众中心”转化</li></ul><h3 id="3-商业模式设计"><a href="#3-商业模式设计" class="headerlink" title="3.商业模式设计"></a>3.商业模式设计</h3><p>六种商业模式设计方法：客户洞察、构思、视觉化思考、模型构建、讲故事、场景。</p><p>设计的三个相互重叠的空间：灵感、构思、实施。</p><h4 id="3-1-客户洞察"><a href="#3-1-客户洞察" class="headerlink" title="3.1 客户洞察"></a>3.1 客户洞察</h4><p>客户视角是商业模式的指导性原则，客户的观点决定了我们选择怎样的价值主张、渠道、客户关系和收益来源。</p><ul><li>成功的创新需要深入理解客户的环境、日常工作、担忧和渴望</li></ul><p>客户洞察的难点：</p><ul><li>透彻理解客户：需要人类学、社会学理论，以及与实地调研结合</li><li>需要有所取舍</li></ul><p>辅助工具：移情图</p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241216152722168.png" alt="4"></p><blockquote><p>补充：</p><p>变需要为核心（人为核心），洞察力是设计思维的关键来源之一。</p><p>从设计到设计思维的演化，本质上是由创造产品演化到分析人与产品的关系，进而演化到人与人的关系。</p><p>设计思维的任务：观察结果转化为洞察，洞察再转为改善人们生活的产品和服务。</p></blockquote><p>客户洞察的核心：换位思考。</p><ul><li>第一层：功能——与观察的用户互换身份</li><li>第二层：认知——体会用户的感受与潜在需求</li><li>第三层：情感——寻找能触动和推动目标人群的想法</li></ul><h4 id="3-2-构思"><a href="#3-2-构思" class="headerlink" title="3.2 构思"></a>3.2 构思</h4><p>一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程被称作构思。</p><p>两个步骤：生成大量创意——对创意进行整合并挑选</p><ul><li>生成阶段要重视数量；可行的创意可以是颠覆性的，也可以是领域的扩展</li></ul><p>提出新创意的两个出发点：</p><ul><li>从画布中寻找创新的焦点</li><li>不断提出“如果…会怎样”的问题</li></ul><p>商业模式创新的焦点：</p><ul><li>资源驱动：创新来源于组织现有的基础设施或合作伙伴资源</li><li>供给驱动：创造全新的价值主张，并影响到其他模块</li><li>客户驱动：基于客户需求、可获得性或便利性的提升，并影响其他模块</li><li>财务驱动：由新收益来源、定价机制或者被缩减的成本驱动的创新</li><li>多点驱动：多焦点驱动的创新，并对其他模块产生深远影响</li></ul><p>构思的流程与团队建设：</p><ul><li>团队组建：多样化创新团队；成员多样化；引导积极倾听</li><li>钻研：创新所需要的知识：总体研究、客户与潜在客户、新技术调研、现有商业模式评估等</li><li>开拓：从九大模块中任意一点出发作为创新起点；数量是关键；重在创意，避免过早评论价值</li><li>甄选标准呢：在业务背景下包含：预期实施时间、潜在收入、可能的客户阻力、对竞争优势的影响</li><li>构建原型（模型）：确立标准后从创意中整理一个最优短名单，由此构建3-5个创新的商业模式，再利用画布进行勾勒和讨论</li></ul><p>头脑风暴（构思的重要手段）的规则：</p><ul><li>保持聚焦</li><li>执行规则</li><li>视觉化思考</li><li>准备</li></ul><blockquote><p>补充：明晰思维过程</p><p>构思的三个空间:相互重叠。灵感：从各个可能的源头收集；构思：将灵感转为想法；实施：把最佳想法发展成考虑全面的具体实施计划</p></blockquote><h4 id="3-3-视觉化思考"><a href="#3-3-视觉化思考" class="headerlink" title="3.3 视觉化思考"></a>3.3 视觉化思考</h4><p>视觉化思考:抽象的东西具体化、复杂的概念简单化</p><p>两项技术:如何使用便利贴+如何将草图与商业模式画布结合</p><p>四个流程:理解、对话、探索、沟通</p><p>视觉化的作用:</p><ul><li>理解商业模式的本质:视觉化的语言,抓住全貌,看到关键</li><li>提升对话效率:共同的参照点,统一的语言,一致的理解</li><li>探索创意:激发创意,演习,隐藏要素</li><li>提升沟通:统一公司内部的理解,内部推销,外部推销</li></ul><p>可视化的关键点:强调重点,区分差异,明确联系</p><h4 id="3-4-模型构建"><a href="#3-4-模型构建" class="headerlink" title="3.4 模型构建"></a>3.4 模型构建</h4><p>与视觉化思考一样,模型构建可以使抽象的概念具体化,帮助探索新的创意</p><p>这里的模型,可以是草图,画布或财务报表</p><p>设计态度:专注探索，全面考虑，快速放弃，选出值得优化的想法，接受不确定性</p><p>控制规模:通过绘制很多（粗略的和细致的）模型来代表各种战略选择，再通过对每个模型添加和移除元素的方式来探索新想法</p><ul><li>随手素描</li><li>精心描绘的画布</li><li>商业案例</li><li>实地验证</li></ul><h4 id="3-5-讲故事"><a href="#3-5-讲故事" class="headerlink" title="3.5 讲故事"></a>3.5 讲故事</h4><p>故事是一个理想的热身工具,为深度讨论商业模式与其内在逻辑做好准备</p><ul><li>将故事与画布结合,利用叙事性克服听众对不熟悉模式的抵触,放下对陌生事物的怀疑</li><li>叙事性:时间的演化</li></ul><p>为什么要讲故事:</p><ul><li>介绍新想法:尝试融入组织战略</li><li>向投资人推销:争取外部资源</li><li>吸引员工:抓住组员的注意力和好奇心</li><li>让未来触手可及:激发创意,辩证变革</li></ul><p>故事的视角:</p><ul><li>以员工为视角:1.观察到的新商业模式所解决的客户问题2.新商业模式如何比旧模式更好的利用资源、业务和伙伴关系（降本增效、开源节流）3.员工承载了组织内部工作与商业模式，以及转向新模式的原因</li><li>以客户为视角:1.客户面临的挑战与必须完成的工作，以及组织如何为其创造价值2.描述她得到的东西、这些东西如何融入她的生活、以及她愿意为哪些东西付费3.可以添加一些戏剧性和情感因素，描述你的组织如何让她的生活更简单，并尝试加入组织如何提供帮助，并需要哪些资源和活动4.故事需要真实可信，避免油腔滑调或居高临下的口吻</li></ul><p>讲故事的方法;图片和旁白,视频,角色扮演,文字和图片,连环图画</p><p>讲述视觉化的故事:利用画布草图逐一介绍一个完整的视觉化故事</p><h4 id="3-6-场景"><a href="#3-6-场景" class="headerlink" title="3.6 场景"></a>3.6 场景</h4><p>将模型构建中明确方向具体化,从而给出有见地的设计</p><p>两种场景:</p><ul><li>不同的客户结构:结合客户洞察描绘出独特、具体的图景</li><li>未来可能的竞争环境</li></ul><p>场景的连接</p><ul><li>场景原定义：影视用语，指特定时间、空间内发生的行动，或指由人物关系构成的具体画面，是通过人物行动来表现剧情的一系列特定过程</li><li>基于场景的（构建产品）思维方式：将互联网视为连接不同个体制造场景（空间）的工具，以及完成连接的高效率方法 – 代表：朋友圈&#x2F;小红书</li><li>从而达成：形成（产品）体验、促成（客户）消费、创造个体生存意义</li></ul><p>互联网场景定义 – 与互联网行为相关的，通过支付完成闭环的应用形态，包含以下两类典型场景（可兼具）：</p><ul><li>超级入口：触发用户沉浸式体验或长时间停留的应用形态（游戏、社交、购物等）</li><li>支付场景：应用移动支付完成交易的场景</li></ul><h3 id="4-商业模式评估"><a href="#4-商业模式评估" class="headerlink" title="4.商业模式评估"></a>4.商业模式评估</h3><h4 id="4-1-外部环境分析"><a href="#4-1-外部环境分析" class="headerlink" title="4.1 外部环境分析"></a>4.1 外部环境分析</h4><h5 id="4-1-1-市场影响力"><a href="#4-1-1-市场影响力" class="headerlink" title="4.1.1 市场影响力"></a>4.1.1 市场影响力</h5><ul><li>市场问题——从客户和供给的角度识别出驱动和改变你的市场的关键问题</li><li>市场分类——识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体</li><li>需求和诉求——列举市场需求并分析这些需求被满足的程度</li><li>切换成本——客户转投竞争对手，需要改变哪些方面</li><li>收入影响力——识别与收入吸引力和定价能力相关的因素</li></ul><h5 id="4-1-2-行业影响力（竞争分析）"><a href="#4-1-2-行业影响力（竞争分析）" class="headerlink" title="4.1.2 行业影响力（竞争分析）"></a>4.1.2 行业影响力（竞争分析）</h5><ul><li>主流竞争对手——识别他们以及他们的相对优势</li><li>挑战者——新出现的玩家以及他们商业模式的不同</li><li>替代产品和服务——（包括其他市场和行业在内的）替代产品与服务</li><li>供应商与价值链上的其他厂商——当前价值链上的关键玩家与新兴玩家</li><li>利益相关者——那些人会影响你的组织和商业模式</li></ul><h5 id="4-1-3-关键趋势（远见）"><a href="#4-1-3-关键趋势（远见）" class="headerlink" title="4.1.3 关键趋势（远见）"></a>4.1.3 关键趋势（远见）</h5><ul><li>技术趋势——威胁和推动发展当前商业模式的技术趋势</li><li>行业管理趋势——影响商业模式的管理规定和管理趋势</li><li>社会和文化趋势——可能影响商业模式的社会趋势</li><li>社会经济趋势——总结和你的商业模式有关的主要社会经济趋势</li></ul><h5 id="4-1-4-宏观经济影响"><a href="#4-1-4-宏观经济影响" class="headerlink" title="4.1.4 宏观经济影响"></a>4.1.4 宏观经济影响</h5><ul><li>全球市场影响——从宏观经济角度总结当前整体情况</li><li>资本市场——与你的资本需求相关的当前资本市场情况</li><li>大宗商品和其他资源——关注你的商业模式所需的资源价格与趋势</li><li>经济基础设施——你的业务市场的经济基础设施</li></ul><h4 id="4-2-整体评估"><a href="#4-2-整体评估" class="headerlink" title="4.2 整体评估"></a>4.2 整体评估</h4><p>对Amazon.com进行整体评估：优势与劣势，扩展机会等等</p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103200332259.png" alt="5"></p><h4 id="4-3-SWOT评估"><a href="#4-3-SWOT评估" class="headerlink" title="4.3 SWOT评估"></a>4.3 SWOT评估</h4><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241216102804122.png" alt="6"></p><p>对上述四个角度的评估分析，需要结合九大模块进行详细分析。</p><ol><li>价值主张评估：各项价值主张之间相互联系，相互促进；产品与服务的强耦合：服务中使用的产品和环境能否满足服务的需要，服务能否有效支持产品传递和售后</li><li>成本&#x2F;收入评估：是否利润高成本低、收入\成本可预期、收益是否稳定&amp;多样化&amp;可持续、收入账期是否合理、客户需要与定价机制是否合理、运营效率&amp;能否扩大规模后受益</li><li>客户界面评估：客户连接、分类、拉新的质量，客户忠诚度；渠道的效率、效果、曝光度&amp;匹配度、是否整合且产生规模经济；产品品牌、是否良好匹配客户、切换成本是否较高</li><li>基础设施评估：核心资源的排他性、可预测性、时效性；关键业务的独特性与完成质量；自身是否聚焦且能与重要合作伙伴展开良好合作</li><li>对价值主张的威胁：可替代性</li><li>对成本&#x2F;收入的威胁：利润的威胁、是否单一、缩水、无法预测、无法支撑</li><li>对客户界面的威胁：市场竞争、渠道威胁、客户关系恶化</li><li>对基础设施的威胁：供应不足、干扰、合作关系波动</li><li>价值主张中的机会：整合、服务化与拓展（补充和外延，其他工作）</li><li>成本&#x2F;收入中的机会：可重复（会员自动续费）、交叉销售、开源节流</li><li>客户界面中的机会：增长的市场、客户细分、渠道优化与去中间商，客户关系加强和取舍</li><li>基础设施中的机会：强化核心、减轻负担、转让闲置</li></ol><blockquote><p>交叉销售:通过客户关系管理发现现有顾客的多种需求，并通过满足其需求而销售多种相关服务或产品的一种新兴营销方式</p><p>成熟电商平台包含：网站+物流仓储+供应链+金融服务</p></blockquote><h4 id="4-4-蓝海战略"><a href="#4-4-蓝海战略" class="headerlink" title="4.4 蓝海战略"></a>4.4 蓝海战略</h4><p>蓝海战略是通过根本性的差异化来创造全新的行业，而不是模仿现有商业模式在当前行业中竞争。</p><ul><li>价值创新：创造新的、未充分竞争的市场空间，<strong>所谓“价值创新”就是“在提升价值的同时降低成本”</strong></li><li>通常还与开拓未被开发的客户群体相结合</li></ul><p>蓝海战略的四项行动架构（增加价值，减少成本）：</p><ul><li>行业中哪些理所应当的要素应被删除</li><li>哪些要素应被大幅消减至行业标准以下</li><li>哪些要素应该被大幅调整到行业标准之上</li><li>哪些行业中从未提供的要素是应该被创造出来的</li></ul><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241216110239645.png" alt="7"></p><p>整合蓝海战略与商业模式画布：</p><ul><li>商业模式右半部关注价值、聚焦客户，左半部分关注成本和基础设施。右侧的改变会对左半部分产生影响</li><li>蓝海战略强调在增加价值的同时减少成本，通过删除和消减低价值产品或服务来降低成本，通过提升和创造对成本影响弱的高价值功能或服务来实现</li></ul><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20241216113854718.png" alt="8"></p><p>举例：太阳马戏团、任天堂</p><p>考虑的具体角度:</p><ol><li>探索成本影响：哪些活动、资源和合作伙伴关系的成本最高？如果消减或删除这些成本项，会发生什么？在删减或消除代价高昂的KR、KA或KP后，如何利用低成本的元素来代替它们创造价值？</li><li>探索价值主张：哪些低价值的功能或者服务可以被删除或消减？可以通过新增或加强哪些功能或服务来产生有价值的客户新体验？价值主张的改变对成本有何影响？价值主张的改变如何改变商业模式客户侧内容？</li><li>探索对客户的影响：你可以聚焦哪些新的客户群体，哪些客户群体可以消减或删除？新的客户群体真正希望你帮他们完成哪些工作？这些客户倾向于何种联络方式，他们期望与你建立何种关系？服务新客户群体对成本有何影响？</li></ol><p>辩证地对待蓝海战略：必要性和风险</p><ul><li><p>必要性：逃离“王慧文四杀”。当一个专注于特定领域的公司一家独大时，会为了继续扩大规模而使用非常规手段消灭竞争，利用垄断优势剥削上下游，恶化口碑。之后会出现戴维斯双杀：利润率翻倍但股价不涨（没有发展预期），每股收益与市盈率下降；在中国会出现优秀人才大规模离开，用户体验下降导致口碑大规模恶化。在某个领域取得绝对优势后，无法通过开拓新的赛道满足企业继续成长的压力，导致采用非常规手段争抢和压榨领域内达到上限的利润和资源，最终自我毁灭（内卷化）。</p></li><li><p>风险：空心化、外部潮流和形势变更</p><ul><li>过于探索客户——偏离：人类兴趣变化快</li><li>过于探索成本——外包异常：经济全球化的蝴蝶效应</li><li>过于探索客户与价值主张：聚焦某个明星品类</li><li>对于探索成本：迷信利润率</li></ul><p>导致“护城河”性质的业务、后续发展的持续动力、或用户信赖的基础丧失</p></li></ul><h3 id="5-需求概述"><a href="#5-需求概述" class="headerlink" title="5.需求概述"></a>5.需求概述</h3><h4 id="5-1-需求定义"><a href="#5-1-需求定义" class="headerlink" title="5.1 需求定义"></a>5.1 需求定义</h4><ul><li>用户为了解决问题或达到某些目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求而需要具备的条件或能力</li><li>对（1）或（2）中的一个条件或一种能力的一种文档化表述</li></ul><h4 id="5-2-问题域"><a href="#5-2-问题域" class="headerlink" title="5.2 问题域"></a>5.2 问题域</h4><ul><li>问题的产生地：当现实的状况与人们的期望产生差距时，就产生了问题。</li><li>要解决问题，就需要改变现实当中某些实体的状态或改变实体状态变化的演进顺序，使其达到期望的状态或演进顺序。</li><li>这些实体和状态构成了问题解决的基本范围，称为该问题的问题域（Problem Domain）。</li></ul><h4 id="5-3-解系统"><a href="#5-3-解系统" class="headerlink" title="5.3 解系统"></a>5.3 解系统</h4><ul><li>软件系统通过影响问题域，能够帮助人们解决问题，称为解系统。</li><li>问题域是自治的，它有自己的运行规律，而且这些规律不会因为解系统的引入而发生改变。</li><li>用户应关注问题域，开发者应以问题域为中心思考</li></ul><h4 id="5-4-需求的层次性"><a href="#5-4-需求的层次性" class="headerlink" title="5.4 需求的层次性"></a>5.4 需求的层次性</h4><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103203307721.png" alt="9"></p><p>业务需求</p><ul><li><p>系统建立的战略出发点，表现为高层次的目标（Objective），描述了组织为什么要开发系统</p></li><li><p>为了满足用户的业务需求，需求工程师需要描述系统高层次的解决方案（逐一细化），定义系统应该具备的特性（System Feature，SF）</p><ul><li>参与各方必须要对高层次的解决方案达成一致，以建立一个共同的前景（Vision） </li><li>特性说明了系统为用户提供的各项功能，它限定了系统的范围（Scope） </li><li><strong>项目的前景和范围明确了软件（某版本）的开发范畴</strong></li><li>BR向SF<em>的转化过程可以利用商业模式画布</em></li></ul></li></ul><p>用户需求</p><ul><li><p>执行实际工作的用户对系统所能完成的具体任务的期望，描述了系统能够帮助用户做些什么</p><ul><li>直接用户</li><li>间接用户：通用、公共服务软件等用户无法确定的系统</li></ul></li><li><p>基本表达方式：<strong>用户可以使用系统完成</strong>任务</p><ul><li>用户任务应是有价值的活动（<strong>客户洞察</strong>） ，并具有较强的目标性（<strong>细化的讲故事与场景</strong>） </li><li>对所有的用户需求，都应该有充分的问题域知识作为背景支持</li></ul></li><li><p>特性</p><ul><li>模糊、不清晰：允许使用形容词和副词 </li><li>多特性混杂：允许混合功能和非功能性需求 </li><li>多逻辑混杂：一条用户需求所代表的任务需多次系统交互才能完成</li></ul></li><li><p>需求开发阶段可视作从用户需要解决的问题到用户与系统的一系列交互的转化，此过程中用户的输入与获得的反馈不断精化，但系统本身仍被视作一个整体，留待后续设计阶段确定模块划分与结构</p></li></ul><p>系统需求</p><ul><li><p>用户对系统行为的期望，一系列的系统行为联系在一起可以帮助用户完成任务，满足业务需求</p></li><li><p>系统需求可以直接映射为系统行为（对应需求规格说明），定义了系统中需要实现的功能，描述了开发人员需要实现什么</p></li><li><p>将用户需求转化为系统需求的过程是一个复杂的过程</p><ul><li>首先需要分析问题领域及其特性，从中发现问题域和计算机系统的共享知识，建立系统的知识模型；</li><li>然后将用户需求部署到系统模型当中，即定义系列的系统行为，让它们联合起来实现用户需求，每一个系统行为即为一个系统需求。</li><li>该过程就是需求工程当中最为重要的需求分析活动，又称建模与分析活动。</li></ul></li></ul><h4 id="5-5-需求分类"><a href="#5-5-需求分类" class="headerlink" title="5.5 需求分类"></a>5.5 需求分类</h4><p>功能需求</p><ul><li>必备，价值的来源</li><li>和系统主要工作相关的需求，即在不考虑物理约束的情况下，用户希望系统所能够执行的活动，这些活动可以帮助用户完成任务。功能需求主要表现为系统和环境之间的行为交互。</li><li>是软件产生价值的基础</li><li>最为复杂</li><li>在所有需求中占比可达90%甚至更高。</li><li>最需要按照BR（SF）、UR、SR三个层次进行展开</li><li><strong>价值主张</strong> <strong>–</strong> <strong>关键业务</strong> <strong>–</strong> <strong>功能需求，一般可以用可视化、故事和场景进行描述</strong></li></ul><p>性能需求</p><ul><li><p>动态性（系统实际运行状态）需要专门模拟</p></li><li><p>系统整体或系统组成部分应该拥有的性能特征，例如CPU使用率、内存使用率等。</p></li><li><p>速度（Speed），系统的响应时间。</p><p>所有的用户查询都必须在10秒内完成。</p></li><li><p>容量（Capacity），系统所能存储的数据量。</p><p>系统应该能够存储至少10万条销售记录。</p></li><li><p>吞吐量（Throughput），系统在连续的时间内完成的事务数量，例如。</p><p>解释器每分钟应该至少解析5000条没有错误的语句。</p></li><li><p>负载（Load），系统可以承载的并发工作量。</p><p>系统应该允许200个用户同时进行正常的工作。</p></li><li><p>实时性（Time-Critical），严格的实时要求。</p><p>监测到病人异常后，监控器必须在0.5秒内发出警报。</p></li></ul><p>质量属性</p><ul><li>从设计（尤其是体系结构设计）的角度来讲</li><li>系统完成工作的质量，即系统需要在一个“好的程度”上实现功能需求，例如可靠性程度、可维护性程度等。</li><li>系统为了满足规定的及隐含的所有要求而需要具备的要素称为质量（包含性能需求）</li><li>质量属性是为了度量质量要素而选用的特征</li><li>质量模型就是能够为质量需求的描述和评价提供工作基础的特征集及特征之间的联系</li></ul><p>对外接口</p><ul><li><p>从封装和信息隐藏，以及多平台交互的角度来讲</p></li><li><p>系统和环境中其他系统之间需要建立的接口，包括硬件接口、软件接口、数据库接口等等。</p></li><li><p>解系统和其他系统之间的软硬件接口</p><ul><li><p>接口的用途</p></li><li><p>接口的输入输出</p></li><li><p>数据格式</p></li><li><p>命令格式</p></li><li><p>异常处理要求</p></li></ul></li><li><p>用户界面</p><ul><li>可以作为需求，写在SRS（Software Requirement Specification，需求规格说明）中</li><li>也可以利用专门的人机交互设计文档记录</li></ul></li></ul><p>约束</p><ul><li>容易忽略</li><li>进行系统构造时需要遵守的约束，例如编程语言、硬件设施等 </li><li>总体上限制了开发人员设计和构建系统时的选择范围</li><li>系统开发及运行的环境<ul><li>包括目标机器、操作系统、网络环境、编程语言、数据库管理系统等。</li></ul></li><li>问题域内的相关标准（<strong>商业模式评估</strong>）<ul><li>包括法律法规、行业协定、企业规章等。</li></ul></li><li>商业规则（<strong>商业模式设计</strong>）<ul><li>用户在任务执行中的一些潜在规则也会限制开发人员设计和构建系统的选择范围</li></ul></li></ul><h4 id="5-6-优秀需求的特性"><a href="#5-6-优秀需求的特性" class="headerlink" title="5.6 优秀需求的特性"></a>5.6 优秀需求的特性</h4><p>完备性、正确性、可行性、必要性、无歧义、可验证</p><h3 id="6-需求获取"><a href="#6-需求获取" class="headerlink" title="6.需求获取"></a>6.需求获取</h3><h4 id="6-1-需求获取上半段"><a href="#6-1-需求获取上半段" class="headerlink" title="6.1 需求获取上半段"></a>6.1 需求获取上半段</h4><h5 id="6-1-1-确定项目前景与范围-–-目标模型"><a href="#6-1-1-确定项目前景与范围-–-目标模型" class="headerlink" title="6.1.1 确定项目前景与范围 – 目标模型"></a>6.1.1 确定项目前景与范围 – 目标模型</h5><ol><li>确定项目前景和范围的活动：所有的涉众都从共同认同的项目前景出发，理解和描述问题域及需求，范围内的事物和事件是描述的目标</li><li>问题分析：<ul><li>获取并明确问题</li><li>发现深层问题</li><li>发现业务需求</li></ul></li><li>目标分析：基于业务需求的问题分析，寻找问题背后的问题。</li><li>业务过程分析：每一个明确、一致的问题都意味着涉众存在一些相应的期望目标，即业务需求</li><li>定义系统边界</li><li>项目前景和范围文档</li></ol><p>目标模型：</p><ul><li>目标是系统被开发的目的</li><li>目标规格的基本模式：实现、终止、保持、避免、优化</li><li>软目标和硬目标</li><li>高层次目标和低层次目标</li><li>功能目标和非功能目标</li><li>目标模型的关系：精化关系、阻碍关系、支持与冲突关系</li><li>目标精化与实现是目标模型的重要任务之一</li><li>目标支持与冲突是目标模型的重要任务之二</li></ul><p>目标精化：一个高层次目标G可以精化为低层次目标</p><ul><li>如果一系列子目标{G1,G2,…,Gn}的完成有助于目标G的完成，那么G与{G1,G2,…,Gn}之间就是AND 精化关系。此时任意两子目标Gi与Gj之间是互补的。</li><li>如果任一子目标Gi都是G的替代方案，那么G与{G1,G2,…,Gn}之间就是OR 精化关系。此时，任意两子目标Gi与Gj之间是互相替代的。</li><li>目标精化的结束条件与约束：子目标展开到单一事务时终止</li></ul><p>目标阻碍：如果子目标O的达成会使得高层目标G失败，则O与G的关系就是阻碍关系；阻碍目标也可以继续AND精化、OR精化；阻碍关系本身是一种特殊的精化——反向精化</p><p>目标实现：</p><ul><li>将最底层目标分配给主体（人+系统）</li><li>设计实现最底层目标的操作（任务：细粒度用例&#x2F;场景）</li></ul><h5 id="6-1-2-涉众分析"><a href="#6-1-2-涉众分析" class="headerlink" title="6.1.2 涉众分析"></a>6.1.2 涉众分析</h5><p>涉众：所有能够影响软件系统的实现，或者会被实现后的软件系统所影响的，关键个人和团体；涉众分析围绕一个组织的各个部门内的员工所负责的业务展开。</p><p>涉众识别：</p><p>1.基本原则</p><ul><li><p>涉众类别需要细分，发现所有类别</p><ul><li>每一类涉众的所有成员都能够一致、稳定的从相同立场、相同视角来看待相同的软件系统</li></ul></li><li><p>发现比较关键的涉众</p><ul><li>需要分析他们各自的赢利条件，以在相互妥协中尽力实现一个共赢的结局</li></ul></li><li><p>涉众群体不是固定不变的，需要持续维护</p><ul><li>对涉众的理解不是一个完成之后就可以结束的活动，而是应该在完成之后继续保持适当的关注</li></ul></li></ul><p>2.识别方法</p><ul><li>简单方法：先膨胀后收缩(Expand -&gt; Shrink)</li><li>经验方法：检查列表（Checklist）</li><li>经典方法：涉众网络</li></ul><p>（1）先膨胀后收缩</p><ul><li><p>膨胀。在该阶段，需求工程师在收集到背景资料后，凭借自己的经验，尽可能多地列出涉众类别，越多越好。</p></li><li><p>收缩。在该阶段，需求工程师判断是否有两类或多类涉众的立场是一样的，将一样的多个类别进行合并。</p></li><li><p>简单易用。如果涉众群体比较复杂，可能会出现遗漏。</p></li></ul><p>（2）检查列表</p><ul><li>根据实践总结的常用涉众列表</li></ul><p>（3）涉众网络</p><ol><li>从一些比较容易发现的涉众出发，通常包括客户、管理者和相关的投资者</li><li>由初始涉众集体讨论，列出一个涉众类别列表</li><li>对上一步产生的涉众类别列表进行分析 ，缩减为一个关键涉众类别列表 </li><li>由上一步的各个关键涉众类别选择代表，集中讨论，列出新的涉众类别列表 <ul><li>如果涉众类别列表趋于稳定，就结束涉众识别过程 ，否则转向第2步</li></ul></li></ol><p>3.涉众描述</p><ul><li>简单特征<ul><li>个人特征：年龄、性别、技能、身体状况…</li><li>工作特征：任务</li><li>地理和社会特征：国家、文化背景、社会关系</li></ul></li><li>对项目的关注点和兴趣所在，态度是反对还是赞同；</li><li>对项目的期望，成为项目赢家的条件；</li><li>可能受到的项目的影响，影响的具体内容及影响程度；</li><li>可以对项目施加的影响，力量的施加点及其强度。</li></ul><p>4.涉众评估</p><p>（1）优先级评估</p><ul><li>涉众并不是完全平等的，有些涉众比其他涉众更为重要 </li><li>优先考虑涉众的基本特征，尤其是任务特征</li></ul><p>（2）<strong>风险评估</strong></p><ul><li><strong>基于涉众特征与态度化解涉众风险策略</strong></li><li><strong>power-interest和power-attitude模型</strong></li></ul><p><strong>案例：</strong></p><ul><li><p><strong>风险：“老二次元”用户群体的保守</strong></p></li><li><p><strong>化解：围绕内容与内容的UGC，实现“老二次元”出圈与一般用户的进入；共青团的入驻；品牌形象的打造</strong></p></li></ul><p>（3）<strong>共赢分析</strong></p><ul><li><p><strong>Stakeholder&#x2F;Issue关系图</strong></p></li><li><p><strong>如果某个Stakeholder-Issue关系上所寄予的期望与项目的业务需求无法保持一致，那么它关联的涉众就在该Issue的问题上和项目整体目标存在冲突</strong> </p><ul><li><p><strong>涉众和项目负责人互相调整、折中</strong> </p></li><li><p><strong>重新评估项目的可行性</strong></p></li></ul></li></ul><p>5.涉众代表选择</p><ul><li><p>完整采样: 每种涉众类别都有自己的代表</p></li><li><p>态度积极: 愿意提供帮助</p></li><li><p>数量适中</p><ul><li>太少 : 个人看法倾轧群体共同看法 </li><li>太多: 达成一致困难 </li><li>代表数量的准确数字要视项目的上下文环境来确定, 一般6-10</li></ul></li><li><p>比例恰当</p><ul><li>计算机技能</li><li>业务技能</li></ul></li><li><p>用户源替代：<strong>因为业务关系而和用户频繁接触的人</strong> ，能够代替他们发表看法</p></li></ul><p>6.参与策略制定</p><ul><li>让代表们在合适的时间参与合适的工作</li></ul><p>（1）用户参与</p><ul><li>建立和用户的直接联系</li><li>用户参与软件系统开发的整个过程</li><li>反馈设计：最终的软件系统是和用户的活动行为密切相关的</li></ul><p>（2）目标模型</p><p>主体依赖模型</p><ul><li><p>分析涉众互动，识别关键涉众类别</p></li><li><p>目标依赖（goal dependency）：依赖者希望被依赖者满足一个条件，但不会规定怎样满足该条件。</p></li><li><p>软目标依赖（soft goal dependency）：一种特殊类型的目标依赖，其条件是无法量化描述的。</p></li><li><p>任务依赖（task dependency）：依赖者希望被依赖者执行特定任务。任务依赖比目标依赖更加具体，因为满足条件可以执行很多任务，被依赖者有自己的选择权。而任务依赖直接为被依赖者规定了任务。</p></li><li><p>资源依赖（resource dependency）：依赖者希望被依赖者提供资源实体（抽象信息或者实物材料）为自己所用，但不关注提供资源需要被依赖者执行的行为和解决的问题。</p></li></ul><p>评估涉众</p><ul><li>拥有者的目标模型</li><li>将目标模型的Goal分配到Actor</li><li>根据Goal的优先级安排Actor的优先级</li><li>根据Goal的风险确定Actor的风险</li><li>根据目标分析深入分析Actor间的互动<ul><li>发现Actor之间的冲突</li><li>根据Goal的冲突情况协商解决Actor间冲突</li></ul></li></ul><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103223254035.png" alt="10"></p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103223308541.png" alt="11"></p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103223407323.png" alt="12"></p><h4 id="6-2-需求获取下半段"><a href="#6-2-需求获取下半段" class="headerlink" title="6.2 需求获取下半段"></a>6.2 需求获取下半段</h4><h5 id="6-2-1-面谈、原型、观察三大获取手段的联系与区别"><a href="#6-2-1-面谈、原型、观察三大获取手段的联系与区别" class="headerlink" title="6.2.1 面谈、原型、观察三大获取手段的联系与区别"></a>6.2.1 面谈、原型、观察三大获取手段的联系与区别</h5><p>面谈：与用户创造性地交流，充分发掘用户潜在想法</p><ul><li>集体面谈：快速方法</li><li>调查表：用户分散</li><li>头脑风暴：“发明”需求</li></ul><p>原型：帮助消除用户或需求工程师想法中的不确定性</p><p>观察：需求工程师亲自（涉身）观察并发掘情景性需求</p><blockquote><p>三者之间的联系和区别：(GPT版本)</p><p>联系</p><ol><li><strong>目标一致</strong>：面谈、原型和观察的共同目标是为了理解用户的需求、期望和痛点，从而为后续的设计、开发及优化提供依据。它们都是为了从用户那里获取有价值的信息。</li><li><strong>用户为中心</strong>：这三种方法都以用户为中心，强调通过与用户的互动或观察来获取需求，确保开发出的产品或系统能最大限度地满足用户的实际需求。</li><li><strong>补充性</strong>：这三种方法通常可以互为补充。在实际的需求获取过程中，结合多种方法会获得更全面的视角。例如，通过面谈获得用户的直观反馈，通过原型验证和细化需求，通过观察揭示用户的潜在需求。</li></ol><p>区别</p><ol><li><strong>形式与方式</strong>：<ul><li><strong>面谈</strong>：通过与用户进行一对一或小组形式的对话，直接从用户口中获取需求。面谈的形式灵活，可以是结构化的，也可以是非结构化的，适用于获取明确的需求、用户的意见和建议。</li><li><strong>原型</strong>：通过构建产品的原型（可以是低保真或高保真的）来展示产品的界面和功能。原型可以帮助用户更加直观地理解和表达需求，尤其是对复杂的功能或界面设计具有很好的验证效果。</li><li><strong>观察</strong>：通过观察用户在实际工作或使用过程中与产品、系统的互动，来发现用户的需求或问题。观察可以揭示用户未能意识到的潜在需求或习惯性操作，尤其适用于收集隐性需求。</li></ul></li><li><strong>获取方式的主动性</strong>：<ul><li><strong>面谈</strong>：用户的反馈是通过主动交流获取的，用户可以表达他们的想法、疑虑和期望，获取的信息通常比较直接和明确。</li><li><strong>原型</strong>：原型的制作和展示通常是由设计者主导，用户通过与原型的互动反馈信息。这种方式通常是在已有设计基础上进行的需求确认或需求验证。</li><li><strong>观察</strong>：观察是一种相对被动的方式，研究者或开发者通过观察用户的实际行为，分析其需求或潜在问题。观察能够揭示一些用户自己未能意识到的需求，尤其是在自然环境中的使用场景下。</li></ul></li><li><strong>获取的需求类型</strong>：<ul><li><strong>面谈</strong>：侧重于获取显性需求，即用户明确知道并能表达出来的需求。这些需求通常是功能性需求、性能需求等。</li><li><strong>原型</strong>：原型主要用于验证需求或迭代需求，尤其适用于确定产品的界面、功能流程和交互方式。通过原型可以更好地明确用户的实际需求，并进行细化或调整。</li><li><strong>观察</strong>：侧重于发现隐性需求，尤其是用户在使用产品时的潜在痛点、非言语行为或用户未表达出来的需求。通过观察，研究者可以更全面地了解用户的行为模式和需求。</li></ul></li><li><strong>适用场景</strong>：<ul><li><strong>面谈</strong>：适用于在初期需求获取阶段，特别是当用户能明确表达需求时。适用于需求较为清晰、具体的场景。</li><li><strong>原型</strong>：适用于需求确认、设计验证、原型测试等阶段，尤其是需要通过具体界面来验证用户需求和体验时。</li><li><strong>观察</strong>：适用于当用户未能表达清楚需求或有潜在需求时，尤其是在复杂系统或行为习惯较为隐蔽的场景下，如用户操作过程中的瓶颈、痛点或不一致的操作模式。</li></ul></li></ol><p>总结</p><ul><li><strong>面谈</strong>更适用于获取显性、明确的用户需求，强调与用户的直接沟通。</li><li><strong>原型</strong>则通过展示和迭代产品界面，帮助用户更直观地理解需求，验证和细化需求。</li><li><strong>观察</strong>通过间接的方式从用户行为中提取信息，揭示用户的潜在需求，尤其是那些用户自己未必能够意识到的需求。</li></ul><p>这三种方法虽然有所不同，但在实际项目中，它们往往是相互配合、互为补充的。合理组合和应用这些方法，可以帮助团队更全面、更准确地获取用户需求，确保产品的成功。</p></blockquote><h5 id="6-2-2-面谈问题的设计"><a href="#6-2-2-面谈问题的设计" class="headerlink" title="6.2.2 面谈问题的设计"></a>6.2.2 面谈问题的设计</h5><p>问题类型：</p><ol><li>开放式问题</li></ol><ul><li>被会见者对答复的选择可以是开放和不受限制的，他们可能答复两个词，也可能答复两段话。</li><li>在希望得到丰富（具有一定深度和广度）信息时，开放式问题比较合适</li><li>Ex. “你觉得把所有的经理都置于一个内联网内怎么样？”</li></ul><ol start="2"><li>封闭式问题</li></ol><ul><li>答案有基本的形式，被会见者的回答是受到限制的</li><li>Ex. “下列信息中哪个对你最有用：（1）填好的客户投诉单；（2）访问web站点的客户的电子邮件投诉；（3）与客户面对面的交流；（4）退回的货物。”</li></ul><ol start="3"><li>探究式问题</li></ol><ul><li>深入探讨某个问题</li><li>Ex. 为什么？你能举个例子吗？你能详细描述一下吗？</li></ul><ol start="4"><li>诱导性问题</li></ol><ul><li>诱导问题的答案</li><li>Ex. “你和其他经理一样，都同意把财产管理计算机化，是吗”</li></ul><ol start="5"><li>双筒问题</li></ol><ul><li>有两个问题</li><li>Ex. “每天你通常会做什么决策，你是怎样做的”</li></ul><ol start="6"><li>元问题</li></ol><ul><li>关于面谈本身的问题</li><li>Ex. 我的问题看起来相关吗？你的回答正式吗？你是回答这些问题的最佳人选吗？我问了太多的问题吗？我还应该见什么人？</li></ul><p>过程：准备–&gt;主持–&gt;报告整理</p><p>面谈背后的要点：取得共情和目标的平衡</p><p>面谈前期以开放式问题为主，决策层和专家为主；后期以封闭式问题为主，抓住主题和线索，问题要有针对性，事先准备面谈记录材料</p><h3 id="7-需求分析"><a href="#7-需求分析" class="headerlink" title="7.需求分析"></a>7.需求分析</h3><h4 id="7-1-根本任务"><a href="#7-1-根本任务" class="headerlink" title="7.1 根本任务"></a>7.1 根本任务</h4><p>建立分析模型：</p><ul><li>将复杂的系统分解成为简单的部分以及它们之间的联系，确定本质特征和用户达成对信息内容的共同理解</li><li>分析的活动主要包括识别、定义和结构化，它的目的是获取某个可以转换为知识的事物的信息</li><li>建模方法：抽象、分解、投影</li><li>模型种类：业务模型、分析模型、计算模型</li></ul><p>创建解决方案：</p><ul><li>将一个问题分解成独立的、更简单和易于管理的子问题来帮助寻找解决方案</li><li>创建解决方案的过程是创造性的</li><li>帮助开发者建立问题的定义，并确定被定义的事物之间的逻辑关系</li></ul><h4 id="7-2-活动"><a href="#7-2-活动" class="headerlink" title="7.2 活动"></a>7.2 活动</h4><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103213352859.png" alt="13"></p><p>需求细化、确定需求优先级、需求协商。还有背景分析；问题分析、目标分析、业务分析，确定系统边界；需求建模。</p><h3 id="8-需求验证与管理"><a href="#8-需求验证与管理" class="headerlink" title="8.需求验证与管理"></a>8.需求验证与管理</h3><h4 id="8-1-需求规格说明"><a href="#8-1-需求规格说明" class="headerlink" title="8.1 需求规格说明"></a>8.1 需求规格说明</h4><p>需求规格说明目标是定义用户需求——准确描述需求及其解决方案。</p><p>优秀需求规格说明文档的特性：</p><ul><li>完备性</li><li>一致性</li><li>根据重要性和稳定性分级</li><li>可修改</li><li>可跟踪</li></ul><h4 id="8-2-需求验证基本活动"><a href="#8-2-需求验证基本活动" class="headerlink" title="8.2 需求验证基本活动"></a>8.2 需求验证基本活动</h4><p>需求验证是专指在需求规格说明完成之后，对需求规格说明文档进行的验证活动（默认之前的需求获取已获得用户确认）。</p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103210841513.png" alt="14"></p><p>需求验证方法：</p><ul><li>评审：由作者之外的其他人来检查产品问题的方法，是主要的静态分析手段</li><li>原型与模拟：涉及到复杂的动态行为时，成本较高</li><li>开发测试用例：以需求为线索，开发测试用例套件；使用测试技术确定输入&#x2F;输出数据，开发测试用例</li><li>用户手册编制：验证功能需求；验证项目范围；验证异常流程需求；验证环境与约束需求</li><li>利用跟踪关系：利用完整的需求工程流程</li><li>自动化分析：用大模型生成测试断言</li></ul><h4 id="8-3-需求管理任务与活动"><a href="#8-3-需求管理任务与活动" class="headerlink" title="8.3 需求管理任务与活动"></a>8.3 需求管理任务与活动</h4><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103210102760.png" alt="15"></p><h4 id="8-4-需求变更控制过程与组织、需求变更注意事项"><a href="#8-4-需求变更控制过程与组织、需求变更注意事项" class="headerlink" title="8.4 需求变更控制过程与组织、需求变更注意事项"></a>8.4 需求变更控制过程与组织、需求变更注意事项</h4><p>需求变化：需求的变化是正当和不可避免的。</p><ul><li>问题发生了改变</li><li>环境发生了改变</li><li>需求基线存在缺陷</li><li>用户变动</li><li>用户对软件的认识变化</li><li>相关产品的出现</li></ul><p>变更控制过程：以可控、一致的方式进行需求基线中需求的变更处理，包括对变化的评估、协调、批准或拒绝、实现和验证。</p><p><img src="/2025/01/03/command-and-innovation-of-commercial-modes-review/image-20250103210410448.png" alt="16"></p><p>变更控制委员会：评价需求的变更，做出批准或者拒绝变化的决定，并确保已批准变化的实现。</p><p>变更控制委员会可能由来自下列部门的人员组成：</p><ul><li>项目或程序管理部门</li><li>产品管理或者需求分析部门</li><li>开发部门</li><li>测试或者质量保障部门</li><li>市场或客户代表</li><li>编写用户文档的部门</li><li>技术支持或帮助部门</li><li>配置管理部门</li></ul><p>注意事项：</p><ul><li>认识到变更的必要性，并为之制定计划</li><li>维护需求基线，审计变更记录</li><li>管理范围蔓延</li><li>灵活应对变更请求</li><li>使用辅助工具</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Command and Innovation of Commercial Modes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Machine Learning Review</title>
      <link href="/2025/01/03/machine-learning-review/"/>
      <url>/2025/01/03/machine-learning-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是我的2024Fall机器学习课程的复习笔记。参考教材为周志华老师的西瓜书，配套参考的有南瓜书和李航的《统计学习方法》。<br>笔记如下:<a href="/file/machine-learning-review.pdf" download="foundations-of-data-science-review.pdf">notes</a></p>]]></content>
      
      
      <categories>
          
          <category> Artificial Intelligence </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韵外之致，意在笔先————从宋元时期窥探书法的笔法与意蕴</title>
      <link href="/2024/12/27/calligraphy-in-song-yuan-dynasties/"/>
      <url>/2024/12/27/calligraphy-in-song-yuan-dynasties/</url>
      
        <content type="html"><![CDATA[<p>书法艺术是中国古代优秀的艺术文化，从商周的甲骨文到如今的硬笔书法，绵延千年，展现出其悠久的历史底蕴和文化感染力。从美术的角度来看，书法是中国古代人民对线条和结构布局的深刻理解与体悟，书法本身也经历了一系列变革，在魏晋时达到一个顶峰，以二王、锺繇为代表，在唐朝达到另一个顶峰，涌现出一大批书法名家，如颜真卿、柳公权、欧阳询、褚遂良、虞世南、怀素等等，他们都各自形成了自己的书体，开创了书法史上的一个璀璨时代。而本文取唐后的宋元时期，这一时期的书家对线条和笔法的研究颇深，以行书和草书为著，是书法史上极为重要的一环。</p><p>李建中《贵宅帖》中：宋人尚意，表现在书法上，重行草、崇流美的尚意书风，韵外之致，意在笔先，不仅在当时成为一种时尚，而且对后世有深远影响。书法所形成的意韵小到线条笔法，大到气势、章法、结构，所谓韵外之致，意在笔先，就是以笔法为重点讨论书法的韵味。宋元时期，书法虽无唐朝盛世的辉煌，但也涌现出一批富有个性的书家，他们以表现自我意识为主，崇尚个人意趣，展现出一股别样的风气。</p><p>自我意识，乃是一个书家所必须具备的素质。反映在创作上，就是创新的思想和不拘泥于古人，基本上人们都是从临摹学起，以古人的贴或碑为蓝本，学习笔画、字形、笔法、结构、章法，学的少了就固守于其中难以从其他的书家中学习，学的多了则难免不精，易泛泛流俗，没有自己的标准和定性。宋朝前期受宋太宗“帖学”的影响颇深，阻碍了书法的创新发展，欧阳修则提出学书法不能摹仿古人，要自成一体，由此诞生了宋四家。</p><p>宋四家均受褚遂良、颜真卿的深刻影响，笔法的势迥异。我本人推米芾为尊，《苕溪诗帖》浑厚中结合了灵动，厚重之余平添几分婉转，《蜀素贴》整体要平和、中正舒缓许多。米芾的字多为斜势，如同山巅的奇石，跌宕欹侧，同时他充分利用了毛笔的笔锋，八面为锋，可谓奇绝险峻，他对笔法的研究和运用炉火纯青，当为宋四家之首。苏轼，字如其人，《寒食帖》道尽了其平生豁达，他的字看似平平无奇，朴素乏味，实则内含一种汪洋浩荡之势，变化莫测。苏轼仕途不顺，被贬黄州，但他并非一蹶不振之人，而是乐观豁达，自在洒脱。他长于楷书、行书，笔法肉丰骨劲，自然天成。黄庭坚与苏轼一样，为尚意之派，然有人评其笔法如死蛇挂树，毫无美感，乍看黄的用笔，会觉得他用笔软弱随意，没有力度和形体，但实则他的行书凝练有力，结构奇特，每一笔极尽伸展，线条如长枪大戟，结字蕴含深意，并且他的字连贯度极好，章法堪称一绝，代表作为《诸上座贴》。宋四家中最年长者即为蔡襄，蔡襄为人忠厚、正值，讲求信义，他的书法也端庄浑厚、淳淡婉美，相比苏黄，他的书法或许缺少些许意趣，但相比唐朝，又不完全遵循古法，起到了承上启下的重要作用，同时也有所创新，婉约优美，谦谦君子。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy2.jpeg" alt="东坡"></p><p>宋四家体现了宋朝书法的顶尖水平，其用笔、写意均可称道，我觉得他们摆脱了传统楷书、行书的绝对规整和绮丽浮夸，各自有各自的特点，且将书法的笔法进行了延拓，如米芾对于外拓的运用、对于倚斜和平衡的把握，黄庭坚对长画和字形的研究，更可贵的是意的参杂，如苏轼《寒食帖》中自我的纾解和旷达洒脱的人生态度。俗话说：“字如其人。”此言不假，宋四家为代表，古代的众多书家亦如此，他们临池妙翰，不仅仅只是为了追求书法境界的至臻至善，更是其人生意趣和人生追求的真切反映。</p><p>谈到元朝，首推书法大家赵孟頫，在我看来，他是书法史上的一位集大成者。子昂琴棋书画具绝，书法上承袭二王、师法李北海，自创行楷，行书更是冠绝当世，小楷也是上佳。李北海的字我觉得与《唐集王圣教序》神似，用笔典雅端庄又不失行书的秀丽连贯，而赵孟頫根本上还是取法二王，颇得几分精华。行楷是介于楷书和行书之间的一种书体，赵孟頫首次为行楷定性，我学行楷是从他的《胆巴碑》入手，《胆巴碑》是他晚年的行楷作品，充分体现了他行楷的味道，作品整体笔法秀媚，苍劲浑厚。而最能体现他行楷特点的应该是他50岁所写的《三门记》，尤其是其中的各种“钩”画和“捺”画，是赵体笔法中区别于其他书体的最大特色。“钩”画果断凌厉，“捺”画则完美诠释了何为一波三折，优美秀丽。行书方面，子昂的字体飘逸秀美、遒劲圆熟，代表作有《洛神赋》、《秋兴赋》、《闲居赋》。我觉得赵体在结字方面也有诸多功夫，形神不散、严谨又活泼，比如“也”字，既可扁平，又可修长，卧钩既可收敛，又可舒展。</p><p>在我看来，宋元时期的书法最重要的在于书法的意，此时的书法家注重在笔墨之间表现“气、骨、神、韵”，其中“气”指书法的气势和力度，“骨”指笔画的骨骼结构，“神”是指书法作品所表现出的精神内核，“韵”则是指语言表达的韵律感受。在书法的低级阶段，人们以象为先，注重形体的相似，简单来说，写得越像越好，把握住一种字体的形，但这并不意味着把握了书写这种字体的方法，死板模仿人人都会，难在理解字体的用笔和章法结构。每一种字体都有其特殊的用笔方法，或是中锋、侧锋，或是外拓、内擫，比如米芾将外拓笔法运用熟练至极，字体斜中取势，不偏不倚。而且真正好的临帖应该是临其神，摹其韵，我们可以看到，世间流传的《兰亭序》均为摹本，最著名的是冯承素本，其次还有褚遂良本、虞世南本等等，除冯承素摹本外其他的摹本均参杂了一些书法家本人的一些气韵，不墨守成规，也正是体现了书法家本身的一些思考。在书法的创作阶段，书法家是绝不能把别人的一种字体完全搬过来的，这里需要所谓的自我意识，书法家在平时已经形成了一套自己的用笔方法和习惯，对笔法、结构、章法也具有自己的理解和体悟，那么此时就会转化成作品。一幅好的书法作品，或者说是合格的书法作品，首先要有自己的思考，其次是对“气、骨、神、韵”的运用。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy3.jpg" alt="定风波"></p><p>韵外之致，意在笔先，宋元时期为我们呈现出了意在书法上的绝妙运用，这是作者自己意趣和品性的体现，姑且称之为书法中的意识流，近代书法尚古，回溯古法，而现代许多书家又尚意，但很多书家备受争议，如兰亭奖得主崔寒柏。书法中对意的理解和追求从未停止，无论何种书体，都是作者自身对书法艺术、对意蕴的思考和感悟，而宋元时期则为我们提供了丰富的意的含义。笔下生辉，我们需要的，是生于古法、成于今朝的笔法，是能体现别样思考和精神境界的意蕴。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Calligraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据时代的认知革命</title>
      <link href="/2024/12/27/huge-data-era-cognitive-revolution/"/>
      <url>/2024/12/27/huge-data-era-cognitive-revolution/</url>
      
        <content type="html"><![CDATA[<p>信息文明的发展是以大数据为基础的。</p><p>传统数据：可结构化</p><p>大数据：非结构化、半结构化</p><p>个人认知-&gt;集体认知-&gt;人工智能</p><h2 id="一．大数据：信息时代的根基"><a href="#一．大数据：信息时代的根基" class="headerlink" title="一．大数据：信息时代的根基"></a>一．<strong>大数据：信息时代的根基</strong></h2><p>什么是大数据？</p><p>大数据是指无法在可容忍的时间内用传统信息技术和软硬件工具对其进行感知、获取、管理、处理和服务的数据集合。</p><p>大数据&#x3D;传统的小数据+现代的大记录。</p><p>①　全数据：各个角度，不一定大。</p><p>②　小数据：以单个人为研究对象，重点在于研究的深度。用大数据得到规律，用小数据去匹配个人。</p><p>③　形态多：非结构化数据的大量涌现。如：网页、在线评论等。形态多不只意味着种类众多，还包含了混杂性。</p><p>④　结构化数据与非结构化数据的混杂。</p><p>⑤　速度快：数据的时效性，如人口普查。实时性：如体育赛事直播，交通路况。数据生产速度快；数据处理速度快；数据的价值随时间流逝而折扣。</p><p>⑥　价值大但密度低：大数据蕴涵着巨大的潜能和未知的属性。</p><p>一个观点：任何数据都可以是结构化数据。非结构化是暂时的，是人类的认知尚未达到某种水平。换言之，非结构化是非建模。</p><p>认知的角度论：不同人对于同一事物的认知不同，同一人对于不同事物的认知亦然，同一个人从不同角度对事物的认知也不同，角度决定认知的方向，认知的方向决定认知的思维策略。</p><p>认知的本质论：认知本质就是一个复杂的过程，所谓认知的概念是人脑提出来的，千年前或尚无认知一说，千年后认知也必然不同，不同的认知都是为了揭示事物的本质。</p><p>数据的精确与模糊：传统时代人们追求统计的方便和准确。大数据时代，舍恩伯格提出：“执迷于精确性是信息缺乏时代和模拟时代的产物”。</p><h2 id="二．大数据的哲学思考"><a href="#二．大数据的哲学思考" class="headerlink" title="二．大数据的哲学思考"></a>二．<strong>大数据的哲学思考</strong></h2><p>本体论：世界可分为三类体：第一体即物理实体，是由自然界物质以及人类所创造的各种实体设备、人造材料所构成的物质与材料世界。第二体即意识人体，指作为地球生命体代表的人体，构成社会的基本要素，人体具有自身的智能反应和智慧的意识活动。第三体即数字虚体，指存在于计算机和网络设备之中的所有数字代码集合体，基于计算机实现，由于网络通信而增强。</p><p>生存论：人类在这样的“镜像世界”的虚拟空间中获得了一种“镜像化生存”。“镜像的自我”，如照片，视频，vlog等。虚拟世界的个人记录，当人死后依据保留下来的数据性格仍可将其复活。如Twitter的Liveson功能，“生命虽逝，推文不止”。</p><p>方法论：抛弃对因果关系的追求而仅仅满足于获得相关关系。“知道是什么就够了，没必要知道为什么。在大数据时代，我们不必非得知道现象背后的原因，而是要让数据自己发声。“</p><p>对相对关系的分析构成了大数据预测的核心。任何的预测本身就是一种对被预测现象的干预过程，因此当所有人都知道这种预测之后，这种预测也就失效了。</p><p>克里斯·安德森：数据的洪流或将带来理论的终结。原先两个不同体系间需要搭建严格的逻辑范式来转换，而在大数据的支持下，只需数据足够多，通过匹配检索即可完成。</p><p>反对：一方面，大数据只能从过去的经验中学习，从而预测未来的趋势，但如果某件事在过去从未发生过，那么就无法预测。另一方面，我们需警惕大数据可能带来的无法预测的后果，如果一旦短时间内在大量数据中出现某种协同性偏差，就很容易导致滚雪球效应。</p><h2 id="三．从科学哲学视角研究大数据"><a href="#三．从科学哲学视角研究大数据" class="headerlink" title="三．从科学哲学视角研究大数据"></a>三．<strong>从科学哲学视角研究大数据</strong></h2><p>Jim Gray：科学研究范式四个阶段：</p><p>①　实验科学</p><p>②　理论科学</p><p>③　计算科学</p><p>④　数据密集型科学</p><p>数据驱动型方法论：</p><p>①　存在某种直觉的合理性，从存在的数据中所作出的归纳被证明是科学推理的一种关键形式，并且可以指导并渗透于实验的研究之中。</p><p>②　从数据中获得有意义的模式的过程中机器的核心作用，并且因此引出自动化推理的核心作用。</p><p>数据自然界：数据成为了和自然与社会相平行的一个新的领域。大数据科学流程间实现高度的自动化过程。”数据挖掘“，”机器学习“。</p><p>大数据的科学建模与科学说明：</p><p>只要数据的广度和精度足够充足，大数据就足以表征复杂对象。Pietsch将其称为”水平式建模”。科学对世界的理解通常总是预设统一论的解释。某个现象是通过和其他现象相互关联起来并且减少独立假设的数量而得以理解的。人们认知新事物是通过已知事物进行类比模拟。</p><p>复杂科学中的现象，比如社会科学，可能完全无法获得统一论的说明，因为缺乏普遍性的规律。</p><h2 id="四．大数据统计学的革命及其哲学意义"><a href="#四．大数据统计学的革命及其哲学意义" class="headerlink" title="四．大数据统计学的革命及其哲学意义"></a>四．<strong>大数据统计学的革命及其哲学意义</strong></h2><p>统计：参数化-&gt;非参数化</p><p>大数据：层级式建模-&gt;水平式建模</p><p>大数据科学的理论负载性与因果结构</p><p>结论：大数据是信息时代的复杂性科学。</p><p>①　大数据科学是符合信息时代特征的新的知识发现方式。</p><p>②　大数据时代信息技术成为了知识发现的主体。</p><p>③　大数据直接面对全体数据，分析的样本为全体数据，科学建模并不具有传统科学所具有的分层模型特征，而是水平式的。</p><p>④　大数据可以实现面向个体或者部分个体的微观规律的知识，具有高度语境特异性的特点。</p><p>⑤　信息技术的发展使我们存储和处理数据的能力极大增长，并造成了数据的爆炸，因此是促成大数据的外在成因。而统计科学思维和方法上的革命是内因。</p><h2 id="五．信息媒介与人的关系"><a href="#五．信息媒介与人的关系" class="headerlink" title="五．信息媒介与人的关系"></a>五．<strong>信息媒介与人的关系</strong></h2><p>媒介技术与人的双向延申：</p><p>技术哲学家卡普：“器官投影说”。</p><p>一方面从地位，技术是连接人类和自然的纽带，工具和机械作为技术的物化状态，是人体器官向大自然的外化、投影和延申。另一方面从功能，技术扩展、强化和补充了人体器官的各种技能，增强了人类控制和改造自然的能力。</p><p>人类的技术工具和器物是人体器官的投影，要理解作为技术文化的技术工具，我们必须先要理解人体的外形和功能，人体器官本身是创造技术人工物的外形和功能的尺度。</p><p>这种用人的身体来类比技术工具的本质有其合理性。一方面，早期对于技术本质的认识尚不深刻；另一方面，技术就是人的一种存在方式。</p><p>媒介理论学家麦克卢汉：“媒介延申论”。</p><p>媒介是人的延申。</p><p>传统传播学意义上：某种工具，提供了人们交流和传播的渠道。麦克卢汉的媒介还涉及多种完全不同类型的技术性工具，一切能延申人体和感官的技术工具都可以称为媒介。一切人造的东西都可以当做是过去用身体或身体的一部分所行使的功能的延申。</p><p>第二种理解：媒介即环境。</p><p>每当一种新的媒介出现时，人们会感到新奇，并且主动地关注到新媒介的存在，而当这种媒介逐渐融入人们的日常生活时，人们就不会对它感到惊讶了，它变成人熟知的环境背景。</p><p>人类媒介发展史：</p><ul><li>口语传播时代</li><li>印刷传播时</li><li>电子传播时代</li></ul><p>麦克卢汉的“全球村“：时空压缩；即时互动；整体思维与共时思维；感官的电子膨胀；感觉的电子化；情感模式。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Foundations of Data Science Review</title>
      <link href="/2024/12/27/foundations-of-data-science-review/"/>
      <url>/2024/12/27/foundations-of-data-science-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是我的2024Fall数据科学基础复习笔记（Review Notes of Foudations of Data Science）这门课由尹一通（尹神）和刘明谋老师开设，课程主页:<a href="https://tcs.nju.edu.cn/wiki/index.php?title=%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80_(Fall_2024)">2024 Fall 数据科学基础 NJU TCS GROUP</a></p><p>笔记如下:<a href="/file/foundations-of-data-science-review.pdf" download="foundations-of-data-science-review.pdf">notes</a><br>如有疏漏和错误欢迎指正。最后的期末考试以基本概念为主（统计部分不考），平时作业难度很大，有些是MU,GS,BHK（教材和参考书）的课后习题。</p><p>课程感受:尹神讲了前几次课给大家开了头，后续都是刘老师讲授的，这门课英文课件英文作业，个人认为对于概念理解应该会更好，但是需要投入较长时间。课程包括了经典概率论的所有内容，并且充满了TCS的味道，随机图和随机游走随机可见，随机过程的部分难度较大，马尔科夫链和贝叶斯估计以及假设检验那里和机器学习相关性非常大。</p><p>期末考试反馈：难度比预想的大多了，三个多选一个填空，第一个多选是$\sigma$代数，第二个是强大数定理和弱大数定理，第三个是OST定理的停时，填空是一个投色子的问题，求方差和协方差比较简单。第一个大题是balls into bins模型，难度很大，考察了一个概率的放缩，最后一问考察了一个期望。第二大题第一个是随机图问题，考察了3-clique的期望数量，以及使用chernoff bound等估计最大团的k值；第二个是一个抽取小球的排列问题，只有当小球的序号满足顺序才能取出不放回，从序号1开始，求一共需要的轮数T的期望和方差。第三大题是连续性随机变量，第一个是均匀分布，考察了$Pr(max{X,Y}-min{X,Y})\leq 1$,第二问是给出了X的pdf为$f(x) &#x3D; 2x$后计算上面的概率；第二个问题是给出了一个平面直角坐标系下的图来计算期望和条件期望。第四大题考察了测度集中不等式和LLN以及CLT，其中第三个题目考察了正太分布以及简单的计算，使用$\Pi(x)$表示，对于阶的估计和不等式的选取有一定条件。</p><p>这里给出balls into bins的一个参考链接：<a href="https://tcs.nju.edu.cn/wiki/index.php?title=%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95_(Fall_2020)/Balls_into_bins">balls into bins</a></p>]]></content>
      
      
      <categories>
          
          <category> TCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability </tag>
            
            <tag> Random Process </tag>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Compiler Review</title>
      <link href="/2024/12/26/compiler-review/"/>
      <url>/2024/12/26/compiler-review/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://cubicy.icu/compiler-construction-principles/">编译原理课程笔记（All-in-One速通版）</a></p><h2 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h2><h3 id="1-1-正则表达式"><a href="#1-1-正则表达式" class="headerlink" title="1.1 正则表达式"></a>1.1 正则表达式</h3><h3 id="1-2-有穷自动机"><a href="#1-2-有穷自动机" class="headerlink" title="1.2 有穷自动机"></a>1.2 有穷自动机</h3><p>NFA</p><p>DFA</p><p>NFA到DFA的转化：子集构造法（闭包）</p><p>DFA最小化：可区分状态的计算</p><h2 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h2><h3 id="2-1-语法分析器"><a href="#2-1-语法分析器" class="headerlink" title="2.1 语法分析器"></a>2.1 语法分析器</h3><p>从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成。</p><ul><li>对于语法错误的程序，报告错误信息</li><li>对于语法正确的程序，生成语法分析树</li></ul><h3 id="2-2-上下文无关文法CFG"><a href="#2-2-上下文无关文法CFG" class="headerlink" title="2.2 上下文无关文法CFG"></a>2.2 上下文无关文法CFG</h3><p>终结符，非终结符，开始符号，产生式</p><p>推导和归约：逆过程</p><p>最左推导，最右推导，最左归约，最右规约</p><p>在自顶向下的分析中，总是采用<strong>最左推导</strong>；在自底向上的分析中，总是采用<strong>最左归约</strong></p><p>句型：文法G下可能推导出的一个符号序列，包含终结符&#x2F;非终结符，可以为空。</p><p>句子：只包含终结符的句型。</p><p>语言：文法G可产生的所有句子的集合。</p><p>正则文法VS上下文无关文法</p><p>Chomsky范式：</p><ul><li>0型文法&#x3D;短语结构文法 递归可枚举</li><li>1型文法&#x3D;上下文有关文法</li><li>2型文法&#x3D;CFG</li><li>3型文法&#x3D;RE</li></ul><h3 id="2-3-CFG的分析树Parse-Tree"><a href="#2-3-CFG的分析树Parse-Tree" class="headerlink" title="2.3 CFG的分析树Parse Tree"></a>2.3 CFG的分析树Parse Tree</h3><p>根节点&#x3D;文法初始符号；叶节点&#x3D;终结符；内部节点&#x3D;非终结符；父节点-&gt;{叶节点}&#x3D;产生式</p><h3 id="2-4-编程语言的文法设计"><a href="#2-4-编程语言的文法设计" class="headerlink" title="2.4 编程语言的文法设计"></a>2.4 编程语言的文法设计</h3><p>核心：无二义性</p><p>二义性来源：存在两个不同的最左推导</p><p>解决方法：确保只有一种最左推导，规定符号优先级，规定符号结合性</p><h3 id="2-5-自顶向下"><a href="#2-5-自顶向下" class="headerlink" title="2.5 自顶向下"></a>2.5 自顶向下</h3><p>每一步需要考虑：</p><ul><li>替换哪个非终结符</li><li>应用哪个产生式替换</li></ul><h4 id="2-5-1-递归下降分析"><a href="#2-5-1-递归下降分析" class="headerlink" title="2.5.1 递归下降分析"></a>2.5.1 递归下降分析</h4><p>适用于LL(k)文法</p><p>从根节点开始，尝试应用一个产生式，产生一个句型；递归下降到下一层，对句型中非终结符也尝试一个产生式；发生错误则选择其他的产生式，如果所有产生式都错误，失败，回溯到上层选择其他产生式。太慢！</p><h4 id="2-5-2-LL（1）和预测分析法"><a href="#2-5-2-LL（1）和预测分析法" class="headerlink" title="2.5.2 LL（1）和预测分析法"></a>2.5.2 LL（1）和预测分析法</h4><p>预测分析法：接收LL（k）文法</p><ul><li>第一个L: “left to right” 从左到右扫描</li><li>第二个L: “left-most derivation” 最左推导</li><li>k: 向前看k个token确定推导选用的产生式（一般不明确说k就是k&#x3D;1）</li></ul><p>这里添加了约束使其无需回溯！</p><p>FISRT集和FOLLOW集：</p><p>LL(1)预测分析实现方式：计算First,Follow-&gt;构造预测分析表-&gt;预测分析</p><p>在预测分析表中，如果某一格存在多个产生式，就说明无法确定选取哪个产生式（也即：产生了冲突），也就说明不是LL(1)文法！</p><blockquote><p>LL（1）的优劣：</p><ul><li>运行高效</li><li>递归实现符合文法结构、适合手动构造&amp;自动生成</li><li>能分析的文法类型受限</li></ul></blockquote><h4 id="2-5-3-消除左递归、提左公因子"><a href="#2-5-3-消除左递归、提左公因子" class="headerlink" title="2.5.3 消除左递归、提左公因子"></a>2.5.3 消除左递归、提左公因子</h4><p>LL（1）文法是无二义性、无左递归、无左公因子的。</p><p>左递归文法：有非终结符A使得$A\Rightarrow* A\alpha$，形如$S\rightarrow Sa$的称为立即&#x2F;直接左递归。</p><p><img src="/2024/12/26/compiler-review/image-20241218103228714.png" alt="1"></p><p>左公因子的文法：$P\rightarrow \alpha\beta|\alpha\gamma$</p><p>同一非终结符的多个候选式存在共同前缀，可能导致回溯。</p><p>解决：$P\rightarrow \alpha Q,Q\rightarrow \beta|\gamma$</p><h4 id="2-5-4-错误恢复"><a href="#2-5-4-错误恢复" class="headerlink" title="2.5.4 错误恢复"></a>2.5.4 错误恢复</h4><h3 id="2-6-自底向上"><a href="#2-6-自底向上" class="headerlink" title="2.6 自底向上"></a>2.6 自底向上</h3><p>从串w归约为文法开始符号S的过程。</p><p>需要考虑：</p><ul><li>何时归约（归约哪些符号串？）</li><li>归约到哪个非终结符号？</li></ul><p><img src="https://cubicy.icu/compiler-construction-principles/grammars.png" alt="grammars"></p><p>LR（k）文法：</p><ul><li>每一个LL（k）语法也是LR（k）的</li><li>不要求无左公因式</li><li>可以处理左递归文法</li><li>“L”: left-to-right scanning 自左向右扫描</li><li>“R”: right-most derivation in reverse 最右推导的逆</li><li>“k”: 向前看的字符的个数(k省略时取1)</li><li>子集（详见<a href="https://cubicy.icu/compiler-construction-principles/#grammars-set">该图</a>）：LR(1), LALR(1), SLR, LR(0), …</li></ul><h4 id="2-6-1-移进——归约Shift-Reduce"><a href="#2-6-1-移进——归约Shift-Reduce" class="headerlink" title="2.6.1 移进——归约Shift-Reduce"></a>2.6.1 移进——归约Shift-Reduce</h4><p>核心：将字符串一分为二。右侧是未被parser检查的，左侧包含终结符与非终结符。</p><p><img src="https://cubicy.icu/compiler-construction-principles/sr.png" alt="shift reduce"></p><p>LR分析采用最右推导的逆过程——最左归约。</p><p>采用栈进行移进归约。</p><p>表驱动的LR分析。</p><h4 id="2-6-2-LR（0）"><a href="#2-6-2-LR（0）" class="headerlink" title="2.6.2 LR（0）"></a>2.6.2 LR（0）</h4><p>核心：维护栈顶内容对于所有产生式右侧的进度。</p><p>项：一个产生式加上其在某处的一个点</p><p>LR（0）自动机的构造：DFA与分析表</p><p>GOTO集合</p><p><img src="https://cubicy.icu/compiler-construction-principles/lr-dfa-eg.png" alt="lr-dfa example"></p><p>DFA到分析表：Action表项和Goto表项</p><p><img src="/2024/12/26/compiler-review/image-20241218114809116.png" alt="2"></p><p><img src="https://cubicy.icu/compiler-construction-principles/lr0-stack-table.png" alt="lr0-stack-table"></p><p>LR实际上只有状态栈，符号信息可从相应状态中获取。</p><p>对于LR（0）中的0：项中没有向前看符号等信息，不关心后面的token，是否规约&#x2F;使用何产生式规约完全取决于栈顶状态。</p><p>局限性：移进——规约冲突。</p><h4 id="2-6-3-SLR（1）"><a href="#2-6-3-SLR（1）" class="headerlink" title="2.6.3 SLR（1）"></a>2.6.3 SLR（1）</h4><p>SLR（1）&#x3D;Simple LR（1），称为SLR文法，其实就是对LR（0）稍微修改</p><p>SLR的DFA和LR（0）的一样，但LR（0）的分析表中有一些规约是非法的，需要删去。</p><p> 在生成分析表的具体步骤上：</p><ul><li>LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的rnrn项</li><li>SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$</li></ul><p>局限性：不能消除所有移进规约冲突，如果产生冲突对应的终结符t恰好在Follow集中，就无法消除。</p><h4 id="2-6-4-LR（1）"><a href="#2-6-4-LR（1）" class="headerlink" title="2.6.4 LR（1）"></a>2.6.4 LR（1）</h4><p>包含后继token来消除一些规约动作。相当于分裂一些LR（0）的状态，精确指明何时应该规约。</p><p>LR（1）项的形式：$A\rightarrow \alpha\cdot\beta,a$</p><p>逗号后的a是向前看符号，即表明向前看一个终结符，可以是$</p><p>计算Closure，Goto表，Action表</p><p><img src="https://cubicy.icu/compiler-construction-principles/lr1-items.png" alt="lr1 items"></p><p>局限性：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。</p><p>话虽如此，文法仍然可能因为RR冲突和SR冲突而导致其不属于LR（1）！</p><p>所以在SLR（1）和LR（1）之间折中得到了LALR（1）</p><h4 id="2-6-5-LALR（1）"><a href="#2-6-5-LALR（1）" class="headerlink" title="2.6.5 LALR（1）"></a>2.6.5 LALR（1）</h4><p>LALR &#x3D; Look-Ahead LR，把LR（1）中只有向前看符号不同的项合并。</p><p>定义：把LR（1）中项的集合里所有向前看符号去掉，剩下的称为核，把LR（1）中所有核相同的状态两两合并为一个状态。新状态的项是两个旧状态的项的并。</p><p>代价：可能有RR冲突。</p><h3 id="2-7-语法分析杂项"><a href="#2-7-语法分析杂项" class="headerlink" title="2.7 语法分析杂项"></a>2.7 语法分析杂项</h3><h4 id="2-7-1-YACC"><a href="#2-7-1-YACC" class="headerlink" title="2.7.1 YACC"></a>2.7.1 YACC</h4><p>yacc&#x3D;yet another compiler-compiler</p><ul><li>基于LALR（1）</li><li>BNF范式</li><li>GNU版本名为Bison</li><li>流程：</li></ul><ol><li>Yacc源程序(*.y) &gt;&gt; Yacc Compiler &gt;&gt; C语言实现的LALR分析器(y.tab.c)</li><li>y.tab.c &gt;&gt; C Compiler &gt;&gt; 分析器可执行文件(<em>.exe&#x2F;</em>.out)</li><li>输入 &gt;&gt; 分析器可执行文件 &gt;&gt; 输出</li></ol><p>消除二义性与解决冲突</p><ul><li>消除二义性：<ul><li>指定运算符优先级：先出现的优先</li><li>指定运算符结合律：<code>%left</code>（左结合，例如乘法加法） <code>%right</code>（右结合，例如一元运算符负号）</li></ul></li><li>冲突解决<ul><li>规约-规约冲突：先出现的产生式优先采用</li><li>移进-规约冲突：移进优先采用</li></ul></li><li>更通用的方法：通过改写文法，可以在消除冲突的同时减少二义性</li></ul><h4 id="2-7-2-错误恢复（续）"><a href="#2-7-2-错误恢复（续）" class="headerlink" title="2.7.2 错误恢复（续）"></a>2.7.2 错误恢复（续）</h4><ul><li>局部错误恢复：调整Parse过程的栈，使其恢复到正常从而继续进行Parsing</li><li>全局错误恢复：删除&#x2F;插入尽可能少的字符，使得源字符串成为合法的字符串</li></ul><h3 id="2-8-语法分析小结：文法对比"><a href="#2-8-语法分析小结：文法对比" class="headerlink" title="2.8 语法分析小结：文法对比"></a>2.8 语法分析小结：文法对比</h3><h4 id="2-8-1-SLR和LR（0）"><a href="#2-8-1-SLR和LR（0）" class="headerlink" title="2.8.1 SLR和LR（0）"></a>2.8.1 SLR和LR（0）</h4><p><img src="/2024/12/26/compiler-review/image-20241218205629813.png" alt="3"></p><h4 id="2-8-2-LL（1）和LR（1）"><a href="#2-8-2-LL（1）和LR（1）" class="headerlink" title="2.8.2 LL（1）和LR（1）"></a>2.8.2 LL（1）和LR（1）</h4><p><img src="/2024/12/26/compiler-review/image-20241218205740360.png" alt="4"></p><h4 id="2-8-3-LL（1）-LR（1）-SLR"><a href="#2-8-3-LL（1）-LR（1）-SLR" class="headerlink" title="2.8.3 LL（1） LR（1） SLR"></a>2.8.3 LL（1） LR（1） SLR</h4><p><img src="https://cubicy.icu/compiler-construction-principles/grammar-compare.png" alt="grammar-compare"></p><h3 id="2-9-抽象语法"><a href="#2-9-抽象语法" class="headerlink" title="2.9 抽象语法"></a>2.9 抽象语法</h3><h4 id="2-9-1-属性文法"><a href="#2-9-1-属性文法" class="headerlink" title="2.9.1 属性文法"></a>2.9.1 属性文法</h4><p>属性文法&#x3D;CFG+属性+属性计算规则</p><ul><li>属性:&#x3D; 描述文法符号的语义特征，比如表达式E的值可以记为E.val</li><li>属性计算规则(语义规则):&#x3D; 与产生式相关联、反映文法符号属性之间关系的规则，比如在乘法表达式中左侧的E.val要如何计算<ul><li>仅表明属性间“抽象”关系，不涉及计算次序等具体实现细节</li></ul></li><li>应用：<ul><li>“推导类”：例如很多语言的<strong>编译期求值</strong></li><li>“生成类”：生成AST， 中间代码等</li><li>…</li></ul></li><li>实现：例如在先前章节中Yacc等Parser生成器的<strong>语义动作</strong></li></ul><h4 id="2-9-2-语义动作"><a href="#2-9-2-语义动作" class="headerlink" title="2.9.2 语义动作"></a>2.9.2 语义动作</h4><p>我们可以给产生式绑定一个语义动作，使得按照这个产生式规约时&#x2F;推导时完成特定操作。</p><p>每个token都可能有独属于自己的 <strong>语义值(Semantic Value)</strong> 。每种token的语义值类型可以不同，我们把A的语义值的类型称为“A的关联类型”。</p><p>例如对于产生式 A→B C D</p><ul><li>语义动作返回值必须是<em>A的关联类型</em></li><li>这个值可以通过B C D各自的语义值进行运算得出</li></ul><h4 id="2-9-3-抽象解析树APT"><a href="#2-9-3-抽象解析树APT" class="headerlink" title="2.9.3 抽象解析树APT"></a>2.9.3 抽象解析树APT</h4><p>APT &#x3D; Abstract Parse Tree 是语义动作的一种应用。</p><p>能否<strong>通过描述语义动作直接实现整个编译器</strong>？可以，但是难以维护，且必须保证这些语义值的计算顺序和Parsing顺序完全一致。</p><ul><li>考虑分离语法解析（Parsing）和语义动作：一个可行方案是Parsing得到树，而后遍历以进行语义相关的操作。</li></ul><p>我们可以很容易得到一棵树：叶节点对应输入的token，内部节点对应一个语法规则。这被称为<strong>concrete parse tree</strong>.</p><p><img src="https://cubicy.icu/compiler-construction-principles/concrete-pt.png" alt="concrete-pt"></p><h4 id="2-9-4-抽象语法树AST"><a href="#2-9-4-抽象语法树AST" class="headerlink" title="2.9.4 抽象语法树AST"></a>2.9.4 抽象语法树AST</h4><p>可以提供一个<em>干净的</em>（不包含Parsing的那些繁文缛节）接口用于后续编译流程的实现或优化（编译器后端）。</p><p>生成方式：用<strong>具体语法</strong>（Parser生成器能懂的）为<strong>抽象语法</strong>（我们想要的、更可读的）生成抽象语法树：</p><p><img src="https://cubicy.icu/compiler-construction-principles/AST.png" alt="AST"></p><ul><li><p>为每一个非终结符定义一个类型声明，用于表示其关联类型。</p></li><li><p>产生式统一放进一个union里，每一个产生式就是union里的一个结构体，这个结构体用于储存其子节点：<br><img src="https://cubicy.icu/compiler-construction-principles/AST-def.png" alt="AST definition"></p></li><li><p>为每个产生式定义一个函数，除了计算需要的语义值返回以外，还将申请空间、分配新的树节点并设置好其子节点：</p><p><img src="https://cubicy.icu/compiler-construction-principles/AST-impl.png" alt="AST implementation"></p></li></ul><h2 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3.语义分析"></a>3.语义分析</h2><p>SDD是将文法符号和某些属性相关联，并通过语义规则来描述如何计算属性的值。</p><p>SDT在产生式体中加入语义动作，并在适当的时候执行这些语义动作。</p><h3 id="3-1-语法制导定义SDD"><a href="#3-1-语法制导定义SDD" class="headerlink" title="3.1 语法制导定义SDD"></a>3.1 语法制导定义SDD</h3><p>SDD是上下文无关文法和属性&#x2F;规则的结合。</p><ul><li>属性和文法符号相关联，按照需要来确定各个文法符号需要哪些属性</li><li>规则和产生式相关联</li></ul><p>对于文法符号X和属性a，用X.a表示分析树中的某个标号为X的节点的值。</p><p>一个分析树节点和它的分支对应于一个产生式规则，而对应的语义规则确定了这些节点上的属性的取值。</p><h4 id="3-1-1-分析树和属性值"><a href="#3-1-1-分析树和属性值" class="headerlink" title="3.1.1 分析树和属性值"></a>3.1.1 分析树和属性值</h4><p>假设我们需要知道一个表达式的类型，以及对应代码将它的值存放在何处，我们就需要两个属性：type,place</p><p><img src="/2024/12/26/compiler-review/image-20241228211612914.png" alt="5"></p><h4 id="3-1-2-继承属性和综合属性"><a href="#3-1-2-继承属性和综合属性" class="headerlink" title="3.1.2 继承属性和综合属性"></a>3.1.2 继承属性和综合属性</h4><p>综合属性：在分许树节点N上的非终结符号A的属性值由N对应的产生式所关联的语义规则来定义。通过N的子节点或N本身的属性值来定义。</p><p>继承属性：节点N的属性值由N的父节点所关联的语义规则来定义。依赖于N的父节点、N本身和N的兄弟节点上的属性值。</p><p>不允许N的继承属性通过N的子节点上的属性来定义。但是允许N的综合属性依赖于N本身的继承属性。</p><p>终结符号有综合属性，但是没有继承属性。</p><p><img src="/2024/12/26/compiler-review/image-20241228211957756.png" alt="6"></p><h4 id="3-1-3-S属性的SDD"><a href="#3-1-3-S属性的SDD" class="headerlink" title="3.1.3 S属性的SDD"></a>3.1.3 S属性的SDD</h4><p>只包含综合属性的SDD称为S属性的SDD。每个语义规则都根据产生式体中的属性值来计算头部非终结符号的属性值。</p><p>S属性的SDD可以和LR语法分析器一起实现。</p><p>语义规则不应该有复杂的副作用。</p><ul><li>要求副作用不影响其他属性的求值</li><li>没有副作用的SDD称为属性文法</li></ul><h4 id="3-1-4-L属性的SDD"><a href="#3-1-4-L属性的SDD" class="headerlink" title="3.1.4 L属性的SDD"></a>3.1.4 L属性的SDD</h4><p>每个属性：</p><ul><li>要么是综合属性</li><li>要么是继承属性，且产生式$A\rightarrow X_1X_2\cdots X_n$中计算$X_i.a$的规则只能使用：<ul><li>A的继承属性</li><li>$X_i$左边的文法符号$X_j$的继承属性或综合属性</li><li>$X_i$自身的继承或综合属性，且这些属性之间的依赖关系不形成环</li></ul></li></ul><h4 id="3-1-5-语法分析树上的SDD求值"><a href="#3-1-5-语法分析树上的SDD求值" class="headerlink" title="3.1.5 语法分析树上的SDD求值"></a>3.1.5 语法分析树上的SDD求值</h4><p>注释语法分析树：包含了各个节点的各属性值的语法分析树。</p><p>步骤：</p><ul><li>对于任意的输入串，首先构造出相应的分析树。</li><li>给各个结点（根据其文法符号）加上相应的属性值</li><li>按照语义规则计算这些属性值即可</li></ul><p><img src="/2024/12/26/compiler-review/image-20241228212714134.png" alt="7"></p><h4 id="3-1-6-依赖图"><a href="#3-1-6-依赖图" class="headerlink" title="3.1.6 依赖图"></a>3.1.6 依赖图</h4><p>描述了某棵特定的分析树上各个属性实例之间的信息流（计算顺序）。</p><p><img src="/2024/12/26/compiler-review/image-20241228213225620.png" alt="8"></p><h4 id="3-1-7-属性值的计算顺序"><a href="#3-1-7-属性值的计算顺序" class="headerlink" title="3.1 7 属性值的计算顺序"></a>3.1 7 属性值的计算顺序</h4><p>各个属性的值需要按照依赖图的拓扑顺序计算，如果有环则无法计算。</p><p>S属性的SDD：</p><ul><li>每个属性都是综合属性</li><li>都是根据子构造的属性计算出父构造的属性</li><li>在依赖图中，总是通过子节点的属性值来计算父节点的属性值。可以和自顶向下、自底向上的语法分析过程一起计算</li></ul><p>L属性的SDD：</p><ul><li>依赖图的边：继承属性从左到右，从上到下；综合属性从下到上</li><li>在扫描过程中，计算一个属性值时，和它相关的依赖属性都已经计算完毕</li></ul><p>受控的副作用：</p><ul><li>不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果</li><li>或者对求值过程添加简答的约束</li></ul><h3 id="3-2-SDT的应用例子"><a href="#3-2-SDT的应用例子" class="headerlink" title="3.2 SDT的应用例子"></a>3.2 SDT的应用例子</h3><h4 id="3-2-1-抽象语法树的构造"><a href="#3-2-1-抽象语法树的构造" class="headerlink" title="3.2.1 抽象语法树的构造"></a>3.2.1 抽象语法树的构造</h4><p><img src="/2024/12/26/compiler-review/image-20241228214334048.png" alt="9"></p><h4 id="3-2-2-自顶向下方式处理的L属性定义"><a href="#3-2-2-自顶向下方式处理的L属性定义" class="headerlink" title="3.2.2 自顶向下方式处理的L属性定义"></a>3.2.2 自顶向下方式处理的L属性定义</h4><p>类型结构：</p><p><img src="/2024/12/26/compiler-review/image-20241228214931075.png" alt="10"></p><p>类型的定义：类型包括两个部分：$T\rightarrow B C$</p><p>B是基本类型，C是分量。如：$int [3][4]$</p><h3 id="3-3-语法制导的翻译方案SDT"><a href="#3-3-语法制导的翻译方案SDT" class="headerlink" title="3.3 语法制导的翻译方案SDT"></a>3.3 语法制导的翻译方案SDT</h3><p>SDT是在产生式体中嵌入程序片段（语义动作）的上下文无关文法。</p><p>SDT的基本实现方法：</p><ul><li>建立语法分析树</li><li>将语义动作看成是虚拟的节点</li><li>从左到右、深度优先地遍历分析树，在访问虚拟节点时执行相应动作</li></ul><p>用SDT实现两类重要的SDD：</p><ul><li>基本文法是LR的，SDD是S属性的</li><li>基本文法是LL的，SDD是L属性的</li></ul><h4 id="3-3-1-后缀翻译方案"><a href="#3-3-1-后缀翻译方案" class="headerlink" title="3.3.1 后缀翻译方案"></a>3.3.1 后缀翻译方案</h4><p>后缀SDT：所有动作都在产生式最右端的SDT。</p><p>文法可以自底向上分析且SDD是S属性的，必然可以构造出后缀SDT。</p><p>构造方法：</p><ul><li>将每个语义规则看作是一个赋值语义动作</li><li>将所有的语义动作放在规则的最右端</li></ul><p><img src="/2024/12/26/compiler-review/image-20241228222737039.png" alt="11"></p><p>后缀SDT的栈实现：</p><p><img src="/2024/12/26/compiler-review/image-20241228222857499.png" alt="12"></p><p>产生式内部带有语义动作的SDT</p><p>消除左递归时SDT的转换</p><h4 id="3-3-2-L属性定义的SDT"><a href="#3-3-2-L属性定义的SDT" class="headerlink" title="3.3.2 L属性定义的SDT"></a>3.3.2 L属性定义的SDT</h4><p>将L属性的SDD转换为SDT：</p><ul><li>将每个语义规则看作是一个赋值语义动作</li><li>将赋值语义动作放到相应产生式的适当位置<ul><li>计算A的继承属性的动作插入到产生式体中对应的A的左边</li><li>计算产生式头的综合属性的动作在产生式的最右边</li></ul></li></ul><p><img src="/2024/12/26/compiler-review/image-20241228223441213.png" alt="13"></p><p><img src="/2024/12/26/compiler-review/image-20241228223511784.png" alt="14"></p><h4 id="3-3-3-递归下降法实现L属性的SDD"><a href="#3-3-3-递归下降法实现L属性的SDD" class="headerlink" title="3.3.3 递归下降法实现L属性的SDD"></a>3.3.3 递归下降法实现L属性的SDD</h4><p><img src="/2024/12/26/compiler-review/image-20241228223656073.png" alt="15"></p><p><img src="/2024/12/26/compiler-review/image-20241228223709170.png" alt="16"></p><p>边扫描边生成属性：当属性值的体积很大时，可以逐步生成属性的各个部分，并增量式添加到最终的属性值中。</p><p><img src="/2024/12/26/compiler-review/image-20241228223743158.png" alt="17"></p><h2 id="4-中间代码生成"><a href="#4-中间代码生成" class="headerlink" title="4.中间代码生成"></a>4.中间代码生成</h2><p>本章主要包括中间代码表示（抽象语法树和三地址代码）以及中间代码生成（表达式、类型检查、控制流）。</p><p>抽象语法树在语法分析已经讲过，静态类型检查和中间代码生成的过程都可以用语法制导的翻译来描述和实现。</p><h3 id="4-1-表达式的DAG"><a href="#4-1-表达式的DAG" class="headerlink" title="4.1 表达式的DAG"></a>4.1 表达式的DAG</h3><p>表达式的DAG能够指出表达式中的公共子表达式。</p><p>构造：可以用和构造AST一样的SDD来构造。</p><h3 id="4-2-三地址代码"><a href="#4-2-三地址代码" class="headerlink" title="4.2 三地址代码"></a>4.2 三地址代码</h3><p>一般写成：x &#x3D; y op z</p><p>运算分量：源程序中的名字作为三地址代码的地址；源程序中出现或生成的常量作为常量；还有编译器生成的临时变量。</p><p>指令集合：运算&#x2F;赋值指令；复制指令；无条件跳转指令；条件转移指令；过程调用&#x2F;返回；带下标的复制指令；地址&#x2F;指针赋值指令。</p><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226141240698.png" alt="18"></p><p>三地址指令的四元式表示方法： op  arg1  arg2  result</p><ul><li>op是运算符的内部编码</li><li>arg1,arg2,result是地址</li><li>如：x &#x3D; y + z $\Rightarrow$ + y z x</li><li>单目运算符不使用arg2</li><li>param运算不使用arg2和result</li><li>条件转移和非条件转移将目标符号放在result字段</li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226141818374.png" alt="19"></p><p>三地址的三元式表示方法： op  arg1  arg2</p><ul><li>x[i] &#x3D; y需要拆分成两个三元式：求x[i]的地址，然后再赋值</li><li>x &#x3D; y op z需要拆分为：<ul><li>（？（Line Number）） op y z</li><li>​                                             &#x3D;  x ?</li></ul></li></ul><h3 id="4-3-类型检查"><a href="#4-3-类型检查" class="headerlink" title="4.3 类型检查"></a>4.3 类型检查</h3><p>确定名字的类型和变量的存储空间布局（相对地址）。</p><p>类型表达式</p><p>结构等价和名等价</p><p>计算类型和宽度的SDT（type,width）</p><p>声明序列的SDT（还有符号表中的位置，offset）</p><p>表达式代码的SDD</p><ul><li>属性code表达代码</li><li>addr表示存放表达式结果的地址</li><li>new temp()可以生成一个临时变量</li><li>gen()生成一个指令</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226144046254.png" alt="20"></p><p>数组元素的寻址：</p><ul><li>数组元素存储在一块连续的存储空间中</li><li>n个数组元素是0,1,…,n-1编号的</li><li>假设每个数组元素宽度是w，那么数组A的第i个元素的开始地址为base+i*w，base是A[0]的相对地址</li><li>有时下标不一定从0开始</li><li>上述地址的计算是按行存放的</li></ul><p>数组引用的翻译</p><ul><li>L.addr指示一个临时变量，计算数组引用的偏移量</li><li>L.array是一个指向数组名字对应的符号表条目的指针，L.array.base为该数组的基地址</li><li>L.type是L生成的子数组的类型，对于任何数组类型t，其宽度由t.width给出,t.elem给出其数组元素的类型</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226145000354.png" alt="21"></p><p>类型系统：给每个组成部分赋予一个类型表达式；通过一组逻辑规则来表示这些类型表达式必须满足的条件</p><p>类型系统的分类：</p><ul><li>类型综合：根据子表示式的类型构造出表达式的类型</li><li>类型推导：根据语言结构的使用方式来确定该结构的类型</li></ul><p>类型转换的SDT</p><p>函数&#x2F;运算符的重载</p><h3 id="4-4-控制流语句"><a href="#4-4-控制流语句" class="headerlink" title="4.4 控制流语句"></a>4.4 控制流语句</h3><p>控制流语句的翻译：if-else语句和while语句</p><ul><li>需要将语句的翻译和布尔表达式的翻译结合在一起</li><li>布尔表达式是被用作语句中改变控制流的条件表达式，用来改变控制流或者计算逻辑值</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226152806234.png" alt="22"></p><p><img src="/2024/12/26/compiler-review/image-20241226152903476.png" alt="23"></p><p>避免冗余的goto语句：上面的goto L3是冗余的，可以替换成</p><ul><li>减少一条goto语句</li><li>引入一特殊符号fall（穿越，fall through），表示不要生成任何跳转指令</li><li>带穿越的语义规则</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226153254811.png" alt="24"></p><p>回填：为布尔表达式和控制流语句生成目标代码的关键问题：某些跳转指令应该跳转到哪里？</p><p>基本思想：例如： if(B) S</p><ul><li>记录B的代码中跳转指令goto  S.next, if … goto  S.next的位置，但是不生成跳转目标</li><li>这些位置被记录到B的综合属性B.falseList中</li><li>当S.next的值已知时（即S的代码生成完毕时），把S.nextList中的所有指令的目标都填上这个值</li></ul><p>生成跳转指令时暂时不指定跳转目标标号，而是使用列表记录这些不完整的指令；等知道正确的目标时再填写目标标号；每个列表中的指令都指向同一个目标。</p><p>布尔表达式的回填翻译：</p><ul><li>trueList：包含跳转指令的列表，这些指令在取值为真时执行</li><li>falseList：包含跳转指令的列表，这些指令在取值为假时执行</li><li>Makelist(i)：创建一个只包含i的列表</li><li>Merge(p1, p2)：将p1和p2指向的列表合并</li><li>Backpatch(p,i)：将i作为目标标号插入到p所指列表中的各指令中</li></ul><p>控制转移语句的回填：语句的综合属性：nextList</p><p>Break、Continue的处理</p><h2 id="5-运行时环境"><a href="#5-运行时环境" class="headerlink" title="5.运行时环境"></a>5.运行时环境</h2><h3 id="5-1-符号表"><a href="#5-1-符号表" class="headerlink" title="5.1 符号表"></a>5.1 符号表</h3><p>绑定：把类型、值等信息绑定到一个标识符上</p><p>环境：一些绑定的集合，体现了程序当前环境下已声明的一些变量&#x2F;函数等</p><p>符号表就是环境的一种实现方式。我们在遍历AST的过程中可以维护一个符号表用于语义分析。符号表中的重要组成部分就是各个局部变量及其作用域。</p><h3 id="5-2-存储分配的方式"><a href="#5-2-存储分配的方式" class="headerlink" title="5.2 存储分配的方式"></a>5.2 存储分配的方式</h3><p><img src="/2024/12/26/compiler-review/image-20241226094009289.png" alt="25"></p><p>目标程序的代码放置在代码区</p><p>静态区、堆区、栈区分别放置不同类型生命期的数据值</p><ul><li><p>静态分配：编译时刻。全局变量</p></li><li><p>动态分配：</p><ul><li><p>栈式存储：和过程的调用&#x2F;返回同步进行分配和回收，值的生命期和过程生命期相同</p></li><li><p>堆存储：数据对象比创建它的过程调用更长寿</p><p>手工进行回收</p><p>垃圾回收机制</p></li></ul></li></ul><h3 id="5-3-栈式分配"><a href="#5-3-栈式分配" class="headerlink" title="5.3 栈式分配"></a>5.3 栈式分配</h3><p>活动树：每个节点对应一个过程活动；根节点对应main的活动；过程p的某次活动对应的节点的所有子节点：此次活动调用的各个过程活动（从左到右，表示调用的先后顺序）</p><p>活动记录：过程调用和返回由控制栈进行管理，每个活跃的活动对应于栈中的一个活动记录；活动记录按照开始时间，从栈底到栈顶排列</p><p>调用代码序列：为活动记录分配空间，填写记录中的信息。返回代码序列恢复机器状态，使调用者继续运行</p><p>活动记录的布局规则</p><p><img src="/2024/12/26/compiler-review/image-20241226102330523.png" alt="26"></p><p>调用者&#x2F;被调用者的活动记录</p><p>栈中的变长数据：变长数组</p><p>非局部数据的访问：无嵌套和有嵌套</p><p>嵌套深度</p><p>访问链：当被调用过程需要其他地方的某个数据时需要使用访问链进行定位</p><p>访问链的维护：访问链的定义+作用域规则</p><p>显示表：提高访问效率。数组d为每个嵌套深度保留一个指针。指针d[i]指向栈中最高的、嵌套深度为i的活动记录</p><h3 id="5-4-堆管理"><a href="#5-4-堆管理" class="headerlink" title="5.4 堆管理"></a>5.4 堆管理</h3><p>堆空间用于存放生命周期不确定、或生存到被明确删除为止的数据对象</p><p>new、malloc</p><p>存储管理器：</p><ul><li>分配：为每个内存请求分配一段连续的、适当大小的堆空间</li><li>回收：把被回收的空间返回空闲空间缓冲池，以满足其他内存需求</li></ul><p>堆空间的碎片问题</p><p>堆空间分配方法：</p><ul><li>Best-fit:最小的满足的空间</li><li>First-fit:第一个满足的空间</li></ul><p>存在的问题：内存泄漏、悬空指针引用、空指针访问&#x2F;数组越界等</p><p>正确的编程模式：</p><ul><li>对象所有者</li><li>引用计数</li><li>基于区域的分配</li></ul><h3 id="5-5-垃圾回收"><a href="#5-5-垃圾回收" class="headerlink" title="5.5 垃圾回收"></a>5.5 垃圾回收</h3><p>垃圾的定义：</p><ul><li>狭义：不能被引用（不可达）的数据</li><li>广义：不需要再被引用的数据</li></ul><p>垃圾回收：自动回收不可达数据的机制</p><p>根集：不需要指针解引用就可以直接访问的数据，根集的成员都是可达的</p><p>改变可达对象集合的操作：</p><ul><li>对象分配</li><li>参数传递&#x2F;返回值</li><li>引用赋值</li><li>过程返回</li></ul><p>垃圾回收方法：捕获对象变得不可达的时刻，回收对象占用的空间；在需要时，标记出所有可达对象、回收其他对象</p><p>引用计数法</p><p>基于跟踪的垃圾回收（可达性分析）：</p><ul><li>标记-清扫式：直接、全面停顿。标记：从根集开始，跟踪并标记出所有可达对象；清扫：遍历整个堆区，释放不可达对象</li><li>标记-清扫式的优化：用一个列表记录所有已经分配的对象，不可达对象等于已分配对象减去可达对象（四种状态对应四个列表,scanned,unscanned,unreached,free）</li><li>压缩并标记：消除存储碎片：对可达对象进行重定位，把可达对象移动到堆区的一段，另一端空闲；空闲空间合并成单一块，分配内存时提高效率</li><li>拷贝回收器：堆空间被分为两个半空间，应用程序在某个半空间内分配存储，当充满这个半空间时，开始垃圾回收；回收时，可达对象被拷贝到另一个半空间；回收完成后，两个半空间角色对调</li></ul><h2 id="6-代码生成"><a href="#6-代码生成" class="headerlink" title="6.代码生成"></a>6.代码生成</h2><p>代码生成器的三个主要任务：指令选择、寄存器分配和指派、指令排序</p><h3 id="6-1-代码生成器设计中的问题"><a href="#6-1-代码生成器设计中的问题" class="headerlink" title="6.1 代码生成器设计中的问题"></a>6.1 代码生成器设计中的问题</h3><ul><li>输入IR的选择：三元式、四元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG</li><li>目标程序：RISC、CISC、可重定向代码、汇编语言</li><li>指令选择：IR层次、指令集特性、目标代码质量</li><li>寄存器分配和指派</li><li>求值顺序</li></ul><h3 id="6-2-目标语言"><a href="#6-2-目标语言" class="headerlink" title="6.2 目标语言"></a>6.2 目标语言</h3><p>指令集：</p><ul><li><p>加载：LD dst, addr</p><p>把地址addr中的内容加载到dst所指寄存器</p></li><li><p>保存：ST x, r</p><p>把寄存器r中的内容保存到x中</p></li><li><p>计算：OP dst,  src1,  src2</p><p>把src1和src2中的值运算后结果存放到dst中</p></li><li><p>无条件跳转：BR L</p><p>控制流转向标号L的指令</p></li><li><p>条件跳转：Bcond r,  L</p><p>对r中的值进行测试，如果为真则转向L</p></li></ul><p>寻址模式：</p><ul><li>变量x:指向分配x的内存位置</li><li>a(r):地址是a的左值加上r中的值</li><li>constant(r):寄存器中内容加上前面的常数即其地址</li><li>*r：寄存器r的内容为其地址</li><li>*constant(r):r中内容加上常量所指地址中存放的值为其地址</li><li>常量#constant</li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226201656884.png" alt="27"></p><h3 id="6-3-目标代码中的地址"><a href="#6-3-目标代码中的地址" class="headerlink" title="6.3 目标代码中的地址"></a>6.3 目标代码中的地址</h3><p>如何将IR中的名字转换成为目标代码中的地址？</p><ul><li>不同的区域中的名字采用不同的寻址方式</li></ul><p>如何为过程调用和返回生成代码？</p><ul><li>静态分配和栈式分配</li></ul><p>活动记录的静态分配：每个过程静态地分配一个数据区域，过程调用时在活动纪记录中存放返回地址；过程调用结束后控制权返回。</p><p>活动记录的栈式分配：运行时刻才能知道一个过程的活动记录的位置。将活动记录的位置存放在寄存器中，用偏移量来访问。</p><p><img src="/2024/12/26/compiler-review/image-20241226203153869.png" alt="28"></p><h3 id="6-4-基本块和流图"><a href="#6-4-基本块和流图" class="headerlink" title="6.4 基本块和流图"></a>6.4 基本块和流图</h3><p>中间代码的流图表示法：</p><ul><li>将中间代码划分为基本块</li><li>控制流只能从第一个指令进入</li><li>除基本块的最后一个指令外，控制流不会跳转&#x2F;停机</li><li>节点：基本块</li><li>边：指明了基本块的执行顺序</li></ul><p>作用：流图可以作为优化的基础</p><ul><li>指明了基本块之间的控制流</li><li>可以根据流图了解到一个值是否会被使用等信息</li></ul><p>划分基本块的算法：</p><ul><li>输入：三地址指令序列</li><li>输出：基本块列表</li><li>步骤：<ul><li>确定基本块的首指令：第一个三地址指令；任意一个条件或无条件转移指令的目标指令；紧跟在一个条件&#x2F;无条件转移指令之后的指令</li><li>确定基本块：每个首指令对应一个基本块；从首指令到下一个首指令</li></ul></li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226203912543.png" alt="29"></p><p>变量值的使用：活跃变量</p><p>流图的构造：</p><p><img src="/2024/12/26/compiler-review/image-20241226204305097.png" alt="30"></p><p>循环：程序的大部分运行时间花费在循环上</p><h3 id="6-5-基本块的优化"><a href="#6-5-基本块的优化" class="headerlink" title="6.5 基本块的优化"></a>6.5 基本块的优化</h3><p>基本块可以用DAG表示：</p><ul><li>每个变量有对应的DAG的结点，代表初始值</li><li>每个语句s有一个相关的节点N，代表计算得到的值<ul><li>N的子节点对应于（其运算分量当前值的）其他语句</li><li>节点N的标号是s的运算符</li><li>N和一组变量关联，表示s是在此基本块内最晚对它们定值的语句</li></ul></li></ul><p>从DAG，可以知道各个变量最后的值和初始值的关系</p><p>DAG的构造：</p><p><img src="/2024/12/26/compiler-review/image-20241226204948204.png" alt="31"></p><p>消除局部公共子表达式：</p><ul><li>在建立某个节点M之前，检查是否存在一个节点N，它和M具有相同的运算符和子节点（顺序也相同）</li><li>如果存在，则不需要生成新的节点，用N代表M</li></ul><p>消除死代码：在DAG上消除没有附加活跃变量的根节点</p><p>应用代数恒等式的优化</p><p>数组引用的DAG表示：</p><p><img src="/2024/12/26/compiler-review/image-20241226205748401.png" alt="32"></p><p><img src="/2024/12/26/compiler-review/image-20241226205906764.png" alt="33"></p><p>指针赋值&#x2F;过程调用</p><p>重组基本块：</p><ul><li>每个节点构造一个三地址语句，计算对应的值</li><li>结果应该尽量赋给一个活跃的变量</li><li>如果节点有多个关联的变量，则需要用复制语句进行赋值</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226210336656.png" alt="34"></p><p><img src="/2024/12/26/compiler-review/image-20241226210443928.png" alt="35"></p><p>重组时需要注意求值的顺序</p><ul><li>指令的顺序必须遵守DAG中结点的顺序</li><li>对数组的赋值必须跟在所有原来在它之前的赋值&#x2F;求值操作之后</li><li>对数组元素的求值必须跟在所有原来在它之前的赋值指令之后</li><li>对变量的使用必须跟在所有原来在它之前的过程调用和指针间接赋值之后</li><li>任何过程调用或者指针间接赋值必须跟在原来在它之前的变量求值之后</li></ul><h3 id="6-6-基本块的代码生成器"><a href="#6-6-基本块的代码生成器" class="headerlink" title="6.6 基本块的代码生成器"></a>6.6 基本块的代码生成器</h3><p>主要目标：尽量减少加载和保存指令，即最大限度利用寄存器</p><p>寄存器的使用方法：</p><ul><li>执行运算时，运算分量必须放在寄存器中</li><li>用于临时变量</li><li>存放全局的值</li><li>进行运行时刻管理（比如：栈顶指针）</li></ul><p>基本思路：依次考虑各三地址指令，尽可能把值保留在寄存器中，以减少寄存器&#x2F;内存之间的数据交换</p><p>基本数据结构：记录各个值对应的位置</p><ul><li>寄存器描述符：跟踪各个寄存器都存放了哪些变量的当前值</li><li>地址描述符：某个变量的当前值存放在哪个或哪些位置（包括内存位置和寄存器）上</li></ul><p>代码生成算法：</p><ul><li>遍历三地址指令</li><li>使用getReg（）函数选择寄存器</li><li>生成指令</li></ul><p>getReg（I）函数：</p><ul><li>根据寄存器描述符和地址描述符、数据流信息，为三地址指令I选择最佳的寄存器</li><li>得到的机器指令的质量依赖于getReg函数选取的寄存器的算法</li></ul><p>具体操作步骤：</p><p><img src="/2024/12/26/compiler-review/image-20241226211659625.png" alt="36"></p><p><img src="/2024/12/26/compiler-review/image-20241226211706659.png" alt="37"></p><p><img src="/2024/12/26/compiler-review/image-20241226211714351.png" alt="38"></p><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226211739967.png" alt="39"></p><p>getReg函数详解：</p><p><img src="/2024/12/26/compiler-review/image-20241227203429561.png" alt="40"></p><p><img src="/2024/12/26/compiler-review/image-20241227203438501.png" alt="41"></p><p><img src="/2024/12/26/compiler-review/image-20241227203446103.png" alt="42"></p><p><img src="/2024/12/26/compiler-review/image-20241227203503021.png" alt="43"></p><p>窥孔优化：使用一个滑动窗口来检查目标指令，在窥孔内实现优化</p><ul><li>冗余指令消除</li><li>控制流优化</li><li>代数简化</li><li>机器特有指令的使用</li></ul><p>寄存器分配和指派：</p><ul><li><p>简单的基本方法：把特定类型的值分配给特定的寄存器</p><p>缺点：寄存器的使用效率较低</p></li><li><p>全局寄存器分配：在循环中频繁使用的值存放在固定寄存器；分配固定多个寄存器来存放内部循环中最活跃的值。可以通过使用计数的方法来估算把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器</p></li></ul><p>使用计数</p><p>重写</p><h2 id="7-代码优化"><a href="#7-代码优化" class="headerlink" title="7.代码优化"></a>7.代码优化</h2><p>本章主要包括优化的来源、数据流分析和机器无关的优化</p><h3 id="7-1-优化的来源"><a href="#7-1-优化的来源" class="headerlink" title="7.1 优化的来源"></a>7.1 优化的来源</h3><p>代码优化是在目标代码中消除不必要的指令，把一个指令序列替换为一个完成相同功能的更快的指令序列。</p><p>编译器只能通过一些相对低层的语义等价转换来优化代码。</p><p>冗余运算的原因：源程序中的冗余；高级程序设计语言编程的副产品。</p><p>下面是语义不变的优化方法：</p><h3 id="7-2-全局公共子表达式"><a href="#7-2-全局公共子表达式" class="headerlink" title="7.2 全局公共子表达式"></a>7.2 全局公共子表达式</h3><p>如果E在某次出现之前必然已经被计算过，且E的分量在该次计算之后一直没有被改变，那么E的本次出现就是一个公共子表达式。</p><p>如果上一次E的值赋给了x，且x的值至今没有被修改过，那么我们就可以使用x，而不需要计算E。</p><p><img src="/2024/12/26/compiler-review/image-20241228092910723.png" alt="44"></p><h3 id="7-3-复制传播"><a href="#7-3-复制传播" class="headerlink" title="7.3 复制传播"></a>7.3 复制传播</h3><p>形如u&#x3D;v的复制语句使得语句后面的程序点上，u的值等于v的值。如果在某个位置上u一定等于v，那么可以把u替换为v。有时可以彻底消除对u的使用，从而消除对u的赋值语句。</p><p><img src="/2024/12/26/compiler-review/image-20241228093124550.png" alt="45"></p><h3 id="7-4-死代码消除"><a href="#7-4-死代码消除" class="headerlink" title="7.4 死代码消除"></a>7.4 死代码消除</h3><p>如果一个变量在某个程序点上的值可能会在之后被使用，那么这个变量在这个点上活跃；否则这个变量就是死的，此时对这个变量的赋值就是没有用的死代码。</p><p>死代码多半是因为前面的优化而形成的。</p><p><img src="/2024/12/26/compiler-review/image-20241228093333158.png" alt="46"></p><h3 id="7-5-代码移动"><a href="#7-5-代码移动" class="headerlink" title="7.5 代码移动"></a>7.5 代码移动</h3><p>循环不变表达式：循环的同一次运行的不同迭代中，表达式的值不变。</p><p>把循环不变表达式移动到循环入口之前计算可以提高效率。</p><p>循环入口：进入循环的跳转都以这个入口为目标。</p><p><img src="/2024/12/26/compiler-review/image-20241228093525542.png" alt="47"></p><h3 id="7-6-归纳变量和强度消减"><a href="#7-6-归纳变量和强度消减" class="headerlink" title="7.6 归纳变量和强度消减"></a>7.6 归纳变量和强度消减</h3><p>每次对x的赋值都使得x的值增加c，那么x就是归纳变量。把对x的赋值改成增量操作，可消减计算强度，提高效率。如果两个归纳变量步调一致，还可以删除其中的某一个。</p><p><img src="/2024/12/26/compiler-review/image-20241228093835971.png" alt="48"></p><h3 id="7-7-数据流分析"><a href="#7-7-数据流分析" class="headerlink" title="7.7 数据流分析"></a>7.7 数据流分析</h3><p>数据流分析是用于获取数据沿着程序执行路径流动的信息的相关技术，是优化的基础。</p><h4 id="7-7-1-数据流分析理论与框架"><a href="#7-7-1-数据流分析理论与框架" class="headerlink" title="7.7.1 数据流分析理论与框架"></a>7.7.1 数据流分析理论与框架</h4><p>在基本块中，数据的流动是线性的；全局的情况下，因存在循环、函数调用等情况，数据的流动变得复杂。</p><p>抽象解释框架：单调性、有界性</p><ul><li>程序状态是有限的</li><li>状态的变化是单调的</li></ul><p>理论：集合理论、偏序关系与半格</p><h4 id="7-7-2-数据流抽象"><a href="#7-7-2-数据流抽象" class="headerlink" title="7.7.2 数据流抽象"></a>7.7.2 数据流抽象</h4><p>程序点：三地址语句之前或之后的位置</p><ul><li>基本块内部：一个语句之后的程序点等于下一个语句之前的程序点</li><li>如果流图中有B1到B2的边，那么B2的第一个语句之前的点可能紧跟在B1的最后语句之后的点后面执行</li></ul><p>程序状态：在某个运行时刻，当指令指针指向这个程序点时，各个变量和动态内存中存放的值。</p><p>指令指针可能多次指向同一个程序点，因此一个程序点可能对应多个程序状态。</p><p>数据流分析把可能出现在某个程序点上的程序状态集合总结为一些特性。</p><h4 id="7-7-3-数据流分析模式"><a href="#7-7-3-数据流分析模式" class="headerlink" title="7.7.3 数据流分析模式"></a>7.7.3 数据流分析模式</h4><p>数据流值：某个程序点所有可能的状态集合的抽象表示。</p><p>域：所有可能的数据流值的集合。</p><p>数据流分析：对一组约束求解。</p><ul><li>IN[s]和OUT[s]</li></ul><p>基于语句语义的约束（传递函数）：</p><ul><li>IN[s] &#x3D; f_s(OUT[s])</li><li>OUT[s] &#x3D; f_s(IN[s])</li></ul><p>基于控制流的约束：</p><ul><li>IN[s_{i+1}] &#x3D; OUT[s_i]</li></ul><p>基本块上的数据流模式：</p><ul><li>基本块的控制流从头到尾不会中断，没有分支</li><li>基本块的效果就是各个语句的效果的复合</li><li>可以预先处理基本块内部的数据流关系，给出基本块对应的传递函数</li></ul><p>基本块之间的控制流约束：</p><ul><li>前向数据流问题：<ul><li>B的传递函数根据IN[B]计算得到OUT[B]</li><li>IN[B]和B的各前驱基本块的OUT值之间具有约束关系</li></ul></li><li>逆向数据流问题：<ul><li>B的传递函数根据OUT[B]计算得到IN[B]</li><li>OUT[B]和B的各后驱基本块的IN值之间具有约束关系</li></ul></li></ul><p><img src="/2024/12/26/compiler-review/image-20241228100214344.png" alt="49"></p><p>数据流方程通常没有唯一解。</p><h4 id="7-7-4-数据流分析框架"><a href="#7-7-4-数据流分析框架" class="headerlink" title="7.7.4 数据流分析框架"></a>7.7.4 数据流分析框架</h4><p>一个数据流分析框架（D，V，R，F）由下列元素组成：</p><ul><li>一个数据流方向D，包括前向和后向</li><li>一个半格（V，R）:V是程序状态的集合，R是集合的交运算或并运算，用于表示在基本块入口处对不同的前驱（或在出口处对不同的后驱）的程序状态的合并</li><li>一个从V到V的传递函数族F，用于刻画基本块内部每条语句对程序状态造成的变化</li></ul><p>May分析：用于分析在某一程序点上所有可能存在的程序状态。</p><p>Must分析：用于分析在某一程序点上一定存在的程序状态。</p><h4 id="7-7-5-到达定值分析"><a href="#7-7-5-到达定值分析" class="headerlink" title="7.7.5 到达定值分析"></a>7.7.5 到达定值分析</h4><p>如果存在一条从定值d后面的程序点到达某个点p的路径，且这条路径上d没有被杀死，那么定值d到达p。</p><p>杀死：路径上对x的其他定值杀死了之前对x的定值。</p><p>直观含义（define-use关系）：如果d到达p，那么在p点使用的值就可能是由d定值的。</p><p><img src="/2024/12/26/compiler-review/image-20241228101552867.png" alt="50"></p><p>应用：循环不变代码外提、常量传播等等。</p><p>语句&#x2F;基本块的传递方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228102238234.png" alt="51"></p><p><img src="/2024/12/26/compiler-review/image-20241228102245274.png" alt="52"></p><p>gen和kill的例子：</p><p><img src="/2024/12/26/compiler-review/image-20241228102315516.png" alt="53"></p><p>到达定值的控制流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228102924515.png" alt="54"></p><p><img src="/2024/12/26/compiler-review/image-20241228102941794.png" alt="55"></p><h4 id="7-7-6-活跃变量分析"><a href="#7-7-6-活跃变量分析" class="headerlink" title="7.7.6 活跃变量分析"></a>7.7.6 活跃变量分析</h4><p>分析x在p上的值是否会在某条从p出发的路径中使用。</p><p>一个变量x在p上活跃，当且仅当存在一条从p点开始的路径，该路径的末端使用了x，且路径上没有对x进行覆盖。</p><p>用途：寄存器分配、死代码删除等等。</p><p>数据流值：活跃变量的集合。</p><p>基本块内的数据流方程：基本块的传递函数仍然是生成——杀死形式，但是从OUT值计算出IN值。</p><ul><li>use_B：可能在B中先于定值被使用（gen）</li><li>def_B：在B中一定先于定值被使用（kill）</li></ul><p>示例：</p><p><img src="/2024/12/26/compiler-review/image-20241228104410581.png" alt="56"></p><p><img src="/2024/12/26/compiler-review/image-20241228104452689.png" alt="57"></p><p>活跃变量数据流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228104521883.png" alt="58"></p><h4 id="7-7-7-可用表达式分析"><a href="#7-7-7-可用表达式分析" class="headerlink" title="7.7.7 可用表达式分析"></a>7.7.7 可用表达式分析</h4><p>x+y在p点可用的条件：从流图入口节点到达p的每条路径都对x+y求值，且在最后一次求值之后再没有对x或者y赋值。</p><p>用途：寻找全局公共子表达式。</p><p>生成——杀死：</p><ul><li>杀死：基本块对x或y赋值，且没有重新计算x+y，那么它就杀死了x+y</li><li>生成：基本块求值x+y，且之后没有对x或y赋值，那么它就生成了x+y</li></ul><p>计算基本块生成的表达式：</p><p><img src="/2024/12/26/compiler-review/image-20241228105125226.png" alt="59"></p><p>示例：</p><p><img src="/2024/12/26/compiler-review/image-20241228105302443.png" alt="60"></p><p>可用表达式的数据流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228105329046.png" alt="61"></p><p>三种数据流方程的总结：</p><p><img src="/2024/12/26/compiler-review/image-20241228105347224.png" alt="62"></p><h3 id="7-8-机器无关的优化"><a href="#7-8-机器无关的优化" class="headerlink" title="7.8 机器无关的优化"></a>7.8 机器无关的优化</h3><h4 id="7-8-1-局部优化"><a href="#7-8-1-局部优化" class="headerlink" title="7.8.1 局部优化"></a>7.8.1 局部优化</h4><p>局部优化包括：DAG、公共子表达式消除、无用代码消除、常量折叠、代数恒等式替换等。</p><h4 id="7-8-2-全局优化"><a href="#7-8-2-全局优化" class="headerlink" title="7.8.2 全局优化"></a>7.8.2 全局优化</h4><p>全局优化管道：常量传播——公共子表达式消除——复制传播——常量折叠——控制流优化——无用代码消除——循环不变代码外提——归纳变量强度消减——控制流优化。</p><p>常量传播框架中的变量状态分为三种：</p><ul><li>所有符合该变量类型的常量值</li><li>NAC（Not A Constant）表示当前变量不是一个常量值，这代表该变量在到达程序点p的不同路径上的值不同，或是被赋予了一个输入变量的值</li><li>UNDEF，表示未定义的值。在到达程序点p的不同路径上存在至少一条路径未对变量的值进行定义</li></ul><h4 id="7-8-3-循环优化"><a href="#7-8-3-循环优化" class="headerlink" title="7.8.3 循环优化"></a>7.8.3 循环优化</h4><p>支配节点（必经节点）：</p><p><img src="/2024/12/26/compiler-review/image-20241228130435331.png" alt="63"></p><p>支配节点树：可以表示支配关系。根节点是入口节点，每个节点d支配且只支配树中的后代节点。</p><p>直接支配节点：从入口节点到达n的任何路径中，它是路径中最后一个支配n的节点。</p><p><img src="/2024/12/26/compiler-review/image-20241228130732424.png" alt="64"></p><p>深度优先排序</p><p>回边和可归约性</p><p>自然循环</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Software Testing Review</title>
      <link href="/2024/12/25/software-testing-review/"/>
      <url>/2024/12/25/software-testing-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是关于2024Fall聂长海老师的自动化测试的复习笔记，以聂老师的书《软件测试的概念和方法》为参考，主要记录了考试中可能出现的知识点，方便复习。<br>聂老师的组：<a href="https://gist.nju.edu.cn/">GIST</a></p><h2 id="1-简答题（20分，每题1分）"><a href="#1-简答题（20分，每题1分）" class="headerlink" title="1 简答题（20分，每题1分）"></a>1 简答题（20分，每题1分）</h2><h3 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1 什么是软件测试？"></a>1 什么是软件测试？</h3><p>软件测试就是在软件投入运行前，对软件需求分析、设计规格说明和编码实现的最终审查，它是软件质量保证的关键步骤。软件测试有八种定义。</p><h3 id="2-软件测试具有哪些特性？"><a href="#2-软件测试具有哪些特性？" class="headerlink" title="2 软件测试具有哪些特性？"></a>2 软件测试具有哪些特性？</h3><ul><li>存在性或永不过时性：任何软件都有缺陷，软件测试将因为软件的存在而存在</li><li>不完全性或抽样性：输入空间很庞大需要进行抽样</li><li>证错不证对性：只能证明软件的不正确性</li><li>检错保质性</li><li>综合性或多方求证性</li><li>测试效果评判准则</li></ul><h3 id="3-软件测试的对象包括哪些方面？"><a href="#3-软件测试的对象包括哪些方面？" class="headerlink" title="3 软件测试的对象包括哪些方面？"></a>3 软件测试的对象包括哪些方面？</h3><p>软件开发过程中的需求规格说明、概要设计规格说明、详细规格说明以及源程序都是。</p><h3 id="4-软件测试的目标是什么？"><a href="#4-软件测试的目标是什么？" class="headerlink" title="4 软件测试的目标是什么？"></a>4 软件测试的目标是什么？</h3><p>发现错误；检查系统是否满足需求。</p><h3 id="5写出你认为软件测试应该遵循的最重要的几条原则"><a href="#5写出你认为软件测试应该遵循的最重要的几条原则" class="headerlink" title="5写出你认为软件测试应该遵循的最重要的几条原则."></a>5写出你认为软件测试应该遵循的最重要的几条原则.</h3><p><img src="/2024/12/25/software-testing-review/image-20240922101504601.png" alt="软件测试原则"></p><h3 id="6-软件测试方法可以分为哪几类方法？"><a href="#6-软件测试方法可以分为哪几类方法？" class="headerlink" title="6 软件测试方法可以分为哪几类方法？"></a>6 软件测试方法可以分为哪几类方法？</h3><p>软件测试可以基于不同的角度和性质出发设计测试方法。如基于代码、基于用户、基于故障、基于输入、基于属性、基于性质、基于开发过程、基于规格、基于模型等等。具体的可以包括静态测试、动态测试；黑盒测试、白盒测试；针对不同开发方式和应用场景的软件测试；针对不同特性和方面的软件测试；针对不同开发阶段的以及一些特殊的测试方法。</p><h3 id="7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"><a href="#7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？" class="headerlink" title="7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"></a>7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？</h3><p><img src="/2024/12/25/software-testing-review/image-20241223094727805.png" alt="软件测试的信息流模型"><br>最关键的因素：与测试相关的软件配置、测试配置、测试工具。</p><h3 id="8-软件开发有哪些模型，软件测试分别处于什么位置？"><a href="#8-软件开发有哪些模型，软件测试分别处于什么位置？" class="headerlink" title="8 软件开发有哪些模型，软件测试分别处于什么位置？"></a>8 软件开发有哪些模型，软件测试分别处于什么位置？</h3><ul><li>大棒开发法：整个过程中</li><li>边写边改法：在测试环节中</li><li>瀑布模型：处于开发阶段的最后一步</li><li>快速原型开发模型：在原型开发、原型评价和系统实现当中</li><li>螺旋开发模型：处于每个开发阶段的测试阶段中</li><li>敏捷方法之XP：测试过程中</li></ul><h3 id="9-软件测试过程有哪些模型？这些模型各有什么特点？"><a href="#9-软件测试过程有哪些模型？这些模型各有什么特点？" class="headerlink" title="9 软件测试过程有哪些模型？这些模型各有什么特点？"></a>9 软件测试过程有哪些模型？这些模型各有什么特点？</h3><ul><li>V模型：左侧基于开发模型，右侧是对应的测试过程</li><li>W模型：开发和测试各是一个V</li><li>X模型：左半部分是针对单独程序片段进行的相互分离的编码和测试，经过多次交接，集成为可以执行的程序</li></ul><h3 id="10-作为一种职业，你认为软件测试员应该具备哪些专业基础？"><a href="#10-作为一种职业，你认为软件测试员应该具备哪些专业基础？" class="headerlink" title="10 作为一种职业，你认为软件测试员应该具备哪些专业基础？"></a>10 作为一种职业，你认为软件测试员应该具备哪些专业基础？</h3><p>探索精神、故障排除能手、不懈努力、创造性、追求完美、判断准确、老练稳重、说服力。</p><h3 id="11-在软件测试领域，最根本（关键）的问题在哪里？"><a href="#11-在软件测试领域，最根本（关键）的问题在哪里？" class="headerlink" title="11 在软件测试领域，最根本（关键）的问题在哪里？"></a>11 在软件测试领域，最根本（关键）的问题在哪里？</h3><p>软件测试的样例太多了，需要对样例进行涵盖和选择。</p><h3 id="11-软件测试工具大致可以分为几种？"><a href="#11-软件测试工具大致可以分为几种？" class="headerlink" title="11 软件测试工具大致可以分为几种？"></a>11 软件测试工具大致可以分为几种？</h3><p>测试管理工具、自动化功能测试工具、性能测试工具、单元测试工具、白盒测试工具、测试用例设计工具、根据是否收费还可以分为商业测试工具、开源和免费。</p><h3 id="12-软件测试管理具有什么作用？"><a href="#12-软件测试管理具有什么作用？" class="headerlink" title="12 软件测试管理具有什么作用？"></a>12 软件测试管理具有什么作用？</h3><p>对测试过程、测试人员及组织、测试文档、测试环境、测试质量都需要进行全面管理才能有效测试，确保软件质量。软件测试管理贯穿整个测试的全过程。</p><h3 id="13-简述软件测试发展的六个发展阶段。"><a href="#13-简述软件测试发展的六个发展阶段。" class="headerlink" title="13 简述软件测试发展的六个发展阶段。"></a>13 简述软件测试发展的六个发展阶段。</h3><ul><li>Debugging oriented (1950年左右)</li><li>Demonstration oriented (1960年左右)</li><li>Destruction oriented (1970年左右)</li><li>Evaluation oriented (1980年左右)</li><li>Prevention oriented (1990年以后)</li><li>Professional、education and research （2000年以后）</li></ul><h3 id="14-缺陷管理具体包括哪些功能？"><a href="#14-缺陷管理具体包括哪些功能？" class="headerlink" title="14 缺陷管理具体包括哪些功能？"></a>14 缺陷管理具体包括哪些功能？</h3><p>缺陷预防、缺陷发现、缺陷记录和报告、缺陷分类和跟踪、缺陷处理以及缺陷预测。</p><h3 id="15-什么是软件？"><a href="#15-什么是软件？" class="headerlink" title="15 什么是软件？"></a>15 什么是软件？</h3><p>软件是计算机程序、规程以及可能的相关文档和运行计算机系统需要的数据。软件&#x3D;程序+文档&#x3D;知识+使用&#x3D;服务+需求。</p><h3 id="16-什么是软件质量？"><a href="#16-什么是软件质量？" class="headerlink" title="16 什么是软件质量？"></a>16 什么是软件质量？</h3><p>软件产品满足规定和隐含需求能力有关的所有特征和所有特性的总和。包括产品质量、过程质量、静态质量与动态质量。</p><h3 id="17-什么是软件缺陷？"><a href="#17-什么是软件缺陷？" class="headerlink" title="17 什么是软件缺陷？"></a>17 什么是软件缺陷？</h3><p>将所有的软件问题统称为缺陷。包括：软件未达到产品说明书中已经标明的功能；软件出现了产品说明书中指明不会出现的错误等。</p><h3 id="18-软件测试发展的未来趋势是什么？"><a href="#18-软件测试发展的未来趋势是什么？" class="headerlink" title="18 软件测试发展的未来趋势是什么？"></a>18 软件测试发展的未来趋势是什么？</h3><p>物理运行——知识——软件优化。软件无处不在，软件定义一切，软件使能一切，智能化软件时代即将到来。</p><h3 id="19-软件测试有哪些停止准则？"><a href="#19-软件测试有哪些停止准则？" class="headerlink" title="19 软件测试有哪些停止准则？"></a>19 软件测试有哪些停止准则？</h3><ul><li>测试超过了预定时间</li><li>执行了所有的测试用例，但没有发现故障</li><li>使用特定的测试用例设计方案作为判断测试停止的准则</li><li>正面指出停止测试的具体要求</li><li>根据单位时间内查出故障的数量决定</li></ul><h3 id="20-解释软件的故障模型PIE。"><a href="#20-解释软件的故障模型PIE。" class="headerlink" title="20 解释软件的故障模型PIE。"></a>20 解释软件的故障模型PIE。</h3><ul><li>Execution执行：错误代码必须被执行到</li><li>Infection感染：触发了错误的中间状态</li><li>Propagation传播：错误的中间状态必须可以传播到最后的输出得以观测</li></ul><h2 id="2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"><a href="#2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）" class="headerlink" title="2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"></a>2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）</h2><table><thead><tr><th></th><th>1 黑盒测试</th><th>2 白盒测试</th></tr></thead><tbody><tr><td>3 静态测试</td><td>5</td><td>6，7，8，9</td></tr><tr><td>4 动态测试</td><td>19，20，21，22，23，24</td><td>10，11，12，13，14，15，16，17，18</td></tr></tbody></table><h3 id="1-黑盒测试"><a href="#1-黑盒测试" class="headerlink" title="1 黑盒测试"></a>1 黑盒测试</h3><p>把待测试程序或软件系统看成一个无法打开的黑匣子，完全不知道程序的内部结构和处理过程的前提下，在程序接口进行测试。</p><h3 id="2-白盒测试"><a href="#2-白盒测试" class="headerlink" title="2 白盒测试"></a>2 白盒测试</h3><p>把测试对象看成一个打开的盒子，允许软件程序员利用程序内部的逻辑结构及有关信息。</p><h3 id="3-静态测试"><a href="#3-静态测试" class="headerlink" title="3 静态测试"></a>3 静态测试</h3><p>在不执行代码的情况下进行的测试。</p><h3 id="4-动态测试"><a href="#4-动态测试" class="headerlink" title="4 动态测试"></a>4 动态测试</h3><p>在执行程序代码的情况下进行的测试。</p><h3 id="5-文档审查"><a href="#5-文档审查" class="headerlink" title="5 文档审查"></a>5 文档审查</h3><p>对测试的相关设计文档进行审查。</p><h3 id="6-同行评审"><a href="#6-同行评审" class="headerlink" title="6 同行评审"></a>6 同行评审</h3><p>软件设计人员和编码人员加上一两个其他程序员间互相审查代码。</p><h3 id="7桌面评审"><a href="#7桌面评审" class="headerlink" title="7桌面评审"></a>7桌面评审</h3><p>单人进行的代码检查或代码走查，由一个人阅读程序。</p><h3 id="8-代码走查"><a href="#8-代码走查" class="headerlink" title="8 代码走查"></a>8 代码走查</h3><p>程序员和测试人员组成的5人小组审查程序。</p><h3 id="9-代码审查"><a href="#9-代码审查" class="headerlink" title="9 代码审查"></a>9 代码审查</h3><p>编写受评审代码的程序员不能参与，每个评审人员从不同角度对代码进行评审。</p><h3 id="10语句覆盖"><a href="#10语句覆盖" class="headerlink" title="10语句覆盖"></a>10语句覆盖</h3><p>执行每条可执行语句，覆盖对象是每条可执行语句。</p><h3 id="11判定覆盖"><a href="#11判定覆盖" class="headerlink" title="11判定覆盖"></a>11判定覆盖</h3><p>从源代码中找出所有分支或决策点，执行所有分支或决策点的两种取值。</p><h3 id="12条件覆盖"><a href="#12条件覆盖" class="headerlink" title="12条件覆盖"></a>12条件覆盖</h3><p>让判定语句中的每个条件变量的真假值都能取到。</p><h3 id="13判定-条件覆盖"><a href="#13判定-条件覆盖" class="headerlink" title="13判定&#x2F;条件覆盖"></a>13判定&#x2F;条件覆盖</h3><p>不仅让判定语句中的每个条件变量的真假值都能取到，而且让判定语句取到真假值。</p><h3 id="14条件组合覆盖"><a href="#14条件组合覆盖" class="headerlink" title="14条件组合覆盖"></a>14条件组合覆盖</h3><p>设计测试用例让判定语句中的每个条件变量的真假值组合情况都执行。</p><h3 id="15-修改决策条件覆盖"><a href="#15-修改决策条件覆盖" class="headerlink" title="15 修改决策条件覆盖"></a>15 修改决策条件覆盖</h3><p>设计测试用例，让每个条件变量独立改变判定语句的真假值。保证每个变量真假值出现一次；整个判定式出现真假值；让每个变量独立影响判定式的真假值。</p><h3 id="16路径覆盖"><a href="#16路径覆盖" class="headerlink" title="16路径覆盖"></a>16路径覆盖</h3><p>设计足够的测试用例，覆盖程序中所有可能的路径。</p><h3 id="17-LCSAJ-覆盖"><a href="#17-LCSAJ-覆盖" class="headerlink" title="17 LCSAJ 覆盖"></a>17 LCSAJ 覆盖</h3><p>关注程序控制流的跳转情况。</p><h3 id="18数据流测试（定义-引用对覆盖）"><a href="#18数据流测试（定义-引用对覆盖）" class="headerlink" title="18数据流测试（定义&#x2F;引用对覆盖）"></a>18数据流测试（定义&#x2F;引用对覆盖）</h3><p>利用程序的数据流&#x2F;控制流图进行测试。每个测试用例包括输入、相关变量定义和使用对的位置、执行的控制流子路径、预期输出。</p><h3 id="19-等价类划分"><a href="#19-等价类划分" class="headerlink" title="19 等价类划分"></a>19 等价类划分</h3><p>把所有可能输入的数据划分成若干等价类。</p><h3 id="20-边界值分析"><a href="#20-边界值分析" class="headerlink" title="20 边界值分析"></a>20 边界值分析</h3><p>通常输入等价类与输出等价类的边界。应该选取正好等于、刚刚大于，或刚刚小于边界的值作为测试数据，而不是选取等价类的典型值或任意值作为测试数据。</p><h3 id="21-因果图与决策表"><a href="#21-因果图与决策表" class="headerlink" title="21 因果图与决策表"></a>21 因果图与决策表</h3><p>因果图生成的就是决策表。适用于检查程序输入条件的各种组合情况。</p><h3 id="22-错误猜测"><a href="#22-错误猜测" class="headerlink" title="22 错误猜测"></a>22 错误猜测</h3><p>靠直觉和经验。基本思想是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h3 id="23-状态转换测试"><a href="#23-状态转换测试" class="headerlink" title="23 状态转换测试"></a>23 状态转换测试</h3><p>将测试对象抽象为一个状态转换图。</p><h3 id="24-语法测试"><a href="#24-语法测试" class="headerlink" title="24 语法测试"></a>24 语法测试</h3><p>基于输入接口的语法变异生成测试用例。</p><p>综合测试策略：先对软件进行黑盒测试，按照静态测试、动态测试依次进行。接着使用白盒测试方法，进行单元测试，对每个模块内部逻辑进行验证，结合黑盒测试和白盒测试，验证模块之间的交互，通过黑盒验证整个系统的功能，白盒确定系统内部的实现。</p><h2 id="3-简述软件开发过程中以下测试方法的特点"><a href="#3-简述软件开发过程中以下测试方法的特点" class="headerlink" title="3 简述软件开发过程中以下测试方法的特点"></a>3 简述软件开发过程中以下测试方法的特点</h2><h3 id="3-1单元测试（unit-testing）"><a href="#3-1单元测试（unit-testing）" class="headerlink" title="3.1单元测试（unit testing）"></a>3.1单元测试（unit testing）</h3><p>单元测试是在软件开发过程中进行的最低级别的测试活动，是针对软件设计的最小单位程序模块进行的正确性工作。</p><p>单元是软件里最小的、可以单独执行编码的单位。单元必须可测；单元的行为或输出是可观测的；有明确的可定义的边界或接口。</p><h3 id="3-2集成测试（integration-testing）"><a href="#3-2集成测试（integration-testing）" class="headerlink" title="3.2集成测试（integration testing）"></a>3.2集成测试（integration testing）</h3><p>集成测试是在单元测试的基础上，将所有已通过单元测试的模块，采用适当的集成策略，按照概要设计的要求组装为子系统或系统，目的是确保各单元模块组合在一起后能够按照概要设计要求运行，检测增量的行为是否正确。</p><p>主要检测模块之间的接口和各个模块集成后实现的功能。重点测试模块的接口、兼容性和全局数据结构。</p><p>桩程序和模拟程序。</p><h3 id="3-3系统测试（system-testing）"><a href="#3-3系统测试（system-testing）" class="headerlink" title="3.3系统测试（system testing）"></a>3.3系统测试（system testing）</h3><p>将整个软件系统视为一个整体来进行测试</p><p>重点测试软件产品的各项功能是否满足用户的要求</p><p>还包括性能、安全性、兼容性、可用性等软件特性及方面的测试 </p><h3 id="3-4验收测试（acceptance-testing）"><a href="#3-4验收测试（acceptance-testing）" class="headerlink" title="3.4验收测试（acceptance testing）"></a>3.4验收测试（acceptance testing）</h3><p>向未来的用户表明系统能够像预定要求那样工作。</p><ul><li>某些已经测试过的纯粹技术性的特点可能不需要再次测试</li><li>对用户特别感兴趣的功能或性能，可能需要再增加一些测试</li><li>通常主要使用生产中的实际数据进行测试</li><li>可能需要设计并执行一些与用户使用步骤有关的测试</li></ul><p>软件配置复查：保证软件配置的所有成分都齐全，各方面的质量都符合要求，文档与程序一致，具有维护阶段所必须的细节，而且已经编排好目录。</p><h3 id="3-5冒烟测试（smoke-testing）"><a href="#3-5冒烟测试（smoke-testing）" class="headerlink" title="3.5冒烟测试（smoke testing）"></a>3.5冒烟测试（smoke testing）</h3><p>“daily build and smoke test” – 即每天自动编译及smoke test，这里的smoke test仅仅是一个简单的测试，看看我们编译好的产品是否“冒烟”以检查每天编译的结果是否成功。</p><ul><li>测试周期短，响应速度快</li><li>能最小化集成风险</li><li>能减小产品低质量的风险</li><li>能简单化错误诊断</li></ul><h3 id="3-6回归测试（regression-testing）"><a href="#3-6回归测试（regression-testing）" class="headerlink" title="3.6回归测试（regression testing）"></a>3.6回归测试（regression testing）</h3><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p><p>要尽可能减少回归测试的执行时间和开销：测试资源受限时，测试用例约简、测试用例选择、测试用例排序。</p><h3 id="3-7-α测试（α-testing）"><a href="#3-7-α测试（α-testing）" class="headerlink" title="3.7 α测试（α testing）"></a>3.7 α测试（α testing）</h3><p>$\alpha$测试是由一个用户在开发环境下进行的测试，也可以是开发机构内部的用户在模拟实际操作环境下进行的测试。目的是评价软件产品的FLURPS（即功能、局域化、可使用性、性能和支持）。</p><h3 id="3-8-β测试（β-testing）"><a href="#3-8-β测试（β-testing）" class="headerlink" title="3.8 β测试（β testing）"></a>3.8 β测试（β testing）</h3><p>$\beta$测试是由软件的多个用户在实际使用环境下进行的测试。开发者通常不在测试现场。</p><h2 id="4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）"><a href="#4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）" class="headerlink" title="4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）"></a>4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）</h2><h3 id="4-1负载测试（Load-Testing）"><a href="#4-1负载测试（Load-Testing）" class="headerlink" title="4.1负载测试（Load Testing）"></a>4.1负载测试（Load Testing）</h3><p>给系统一个特定的条件，观察系统的反应情况，在不同的负载级别上逐步加大或减小。</p><h3 id="4-2压力测试（Stress-Testing）"><a href="#4-2压力测试（Stress-Testing）" class="headerlink" title="4.2压力测试（Stress Testing）"></a>4.2压力测试（Stress Testing）</h3><p>持续不断地对被测试系统增加压力，直到被压垮，从而确定系统能承受的最大压力。</p><p>压力测试主要考虑下面三个方面：长时间测试对软件造成的影响；大数据量对软件的影响；高频率数据对软件的影响。</p><h3 id="4-3性能测试（Performance-Testing）"><a href="#4-3性能测试（Performance-Testing）" class="headerlink" title="4.3性能测试（Performance Testing）"></a>4.3性能测试（Performance Testing）</h3><p>一般通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p><h3 id="4-4可靠性测试（Reliability-Testing）"><a href="#4-4可靠性测试（Reliability-Testing）" class="headerlink" title="4.4可靠性测试（Reliability Testing）"></a>4.4可靠性测试（Reliability Testing）</h3><p>可靠性测试是在给被测试系统加载一定业务压力的情况下，使系统运行一段时间，以此来测试系统是否稳定。</p><h3 id="4-5-容量测试（Volume-Testing）"><a href="#4-5-容量测试（Volume-Testing）" class="headerlink" title="4.5 容量测试（Volume Testing）"></a>4.5 容量测试（Volume Testing）</h3><p>一种是针对某些系统存储、传输、统计和查询等业务进行大数据量的独立数据容量测试；另外一种是与压力测试、负载测试、可靠性测试等相结合的极限状态下的综合数据容量测试。</p><h3 id="4-6安全性测试（Security-Testing）"><a href="#4-6安全性测试（Security-Testing）" class="headerlink" title="4.6安全性测试（Security Testing）"></a>4.6安全性测试（Security Testing）</h3><p>安全性测试是设计测试用例来突破程序安全检查的过程。</p><h3 id="4-7安装测试（Installation-Testing）"><a href="#4-7安装测试（Installation-Testing）" class="headerlink" title="4.7安装测试（Installation Testing）"></a>4.7安装测试（Installation Testing）</h3><p>安装测试是确保软件在正常情况和异常情况下能成功安装。</p><h3 id="4-8可用性测试（Usability-Testing）"><a href="#4-8可用性测试（Usability-Testing）" class="headerlink" title="4.8可用性测试（Usability Testing）"></a>4.8可用性测试（Usability Testing）</h3><p>可用性测试检查待测试软件的人机界面，通常要检查的部件包括界面布局和色彩、输入和输出格式、程序流程和拼写等，以发现其中的人为因素和易用性等问题。</p><h3 id="4-9稳定性测试（Stability-Testing）"><a href="#4-9稳定性测试（Stability-Testing）" class="headerlink" title="4.9稳定性测试（Stability Testing）"></a>4.9稳定性测试（Stability Testing）</h3><p>稳定性测试方法主要尝试检测软件在其使用过程中性能是否稳定，以及是否会崩溃。</p><h3 id="4-10-本地化和国际化测试-Localization-and-Internationalization-Testing"><a href="#4-10-本地化和国际化测试-Localization-and-Internationalization-Testing" class="headerlink" title="4.10 本地化和国际化测试(Localization and Internationalization Testing)"></a>4.10 本地化和国际化测试(Localization and Internationalization Testing)</h3><p>在软件设计中除了语言本身，还要考虑用户所在的国家、地理位置和文化等因素，这个过程称为软件的本地化，有时也称软件的国际化。</p><h3 id="4-11-可访问性测试（Accessibility-Testing）"><a href="#4-11-可访问性测试（Accessibility-Testing）" class="headerlink" title="4.11 可访问性测试（Accessibility Testing）"></a>4.11 可访问性测试（Accessibility Testing）</h3><p>主要检测软件系统对于残疾人是否具有可访问性。</p><h3 id="4-12授权测试（Authorization-Testing）"><a href="#4-12授权测试（Authorization-Testing）" class="headerlink" title="4.12授权测试（Authorization Testing）"></a>4.12授权测试（Authorization Testing）</h3><p>授权测试是一种测试授权过程健壮性的方法，该方法通过理解授权工作原理和过程，利用这些信息来试图规避授权机制。</p><h3 id="4-13容错性测试（Fault-Tolerance-Testing）"><a href="#4-13容错性测试（Fault-Tolerance-Testing）" class="headerlink" title="4.13容错性测试（Fault Tolerance Testing）"></a>4.13容错性测试（Fault Tolerance Testing）</h3><p>容错性测试是指检查软件在异常条件下自身是否具有防护性的措施或某种灾难性恢复的手段。</p><h3 id="4-14一致性测试（Conformance-Testing）"><a href="#4-14一致性测试（Conformance-Testing）" class="headerlink" title="4.14一致性测试（Conformance Testing）"></a>4.14一致性测试（Conformance Testing）</h3><p>一致性测试或类型测试是测试一个产品在效率或互通性方面是否符合某个指定的标准。</p><h3 id="4-15配置测试（Configuration-Testing）"><a href="#4-15配置测试（Configuration-Testing）" class="headerlink" title="4.15配置测试（Configuration Testing）"></a>4.15配置测试（Configuration Testing）</h3><p>软件与硬件之间的交互测试称为配置测试，主要检测各种硬件环境是否能够支持软件的正常运行。</p><h3 id="4-16文档测试-Document-Testing"><a href="#4-16文档测试-Document-Testing" class="headerlink" title="4.16文档测试(Document Testing)"></a>4.16文档测试(Document Testing)</h3><p>主要是对相关的设计报告和用户使用说明进行测试。</p><h3 id="4-17兼容性测试-Compatibility-Testing"><a href="#4-17兼容性测试-Compatibility-Testing" class="headerlink" title="4.17兼容性测试(Compatibility Testing)"></a>4.17兼容性测试(Compatibility Testing)</h3><p>兼容性测试是指待测试项目在特定的硬件平台上，不同的应用软件之间，不同的操作系统平台上，在不同的网络等环境中能正常的运行的测试。</p><h3 id="4-18-试玩-（Playtest）"><a href="#4-18-试玩-（Playtest）" class="headerlink" title="4.18 试玩 （Playtest）"></a>4.18 试玩 （Playtest）</h3><p>试玩测试是在一种游戏设计开发过程中，在游戏投放市场之前，为了检查发现游戏中潜在的错误，进一步改进游戏而采取的一种测试方法。请游戏玩家来玩这个游戏，可以是开放式的、封闭的或者β式的。</p><h3 id="4-19-可恢复性测试（Recovery-Testing）"><a href="#4-19-可恢复性测试（Recovery-Testing）" class="headerlink" title="4.19 可恢复性测试（Recovery Testing）"></a>4.19 可恢复性测试（Recovery Testing）</h3><p>测试软件系统在故障发生后，重新建立其性能水平并恢复受影响数据的能力。</p><h3 id="4-20-卸载测试（Uninstall-Testing）"><a href="#4-20-卸载测试（Uninstall-Testing）" class="headerlink" title="4.20 卸载测试（Uninstall Testing）"></a>4.20 卸载测试（Uninstall Testing）</h3><p>卸载测试是对软件的全部、部分或升级卸载处理过程的测试。</p><h3 id="4-21-能力测试-Facility-Testing"><a href="#4-21-能力测试-Facility-Testing" class="headerlink" title="4.21 能力测试(Facility Testing)"></a>4.21 能力测试(Facility Testing)</h3><p>判断目标文档中的每一项能力是否确实已经实现。</p><h3 id="4-22-健壮性测试（Robustness-Testing）"><a href="#4-22-健壮性测试（Robustness-Testing）" class="headerlink" title="4.22 健壮性测试（Robustness Testing）"></a>4.22 健壮性测试（Robustness Testing）</h3><p>健壮性是指在异常情况下，软件还能正常运行的能力。健壮性有两层含义：一是容错能力；二是恢复能力。</p><h3 id="4-23-穿越测试（By-pass-Testing）"><a href="#4-23-穿越测试（By-pass-Testing）" class="headerlink" title="4.23 穿越测试（By-pass Testing）"></a>4.23 穿越测试（By-pass Testing）</h3><p>穿越测试通过构造测试用例来故意违反各种安全约束，其目的是验证输入检查，检查系统的鲁棒性和评估系统的安全性。</p><h3 id="4-24-在线帮助测试（Online-Help-Testing）"><a href="#4-24-在线帮助测试（Online-Help-Testing）" class="headerlink" title="4.24 在线帮助测试（Online Help Testing）"></a>4.24 在线帮助测试（Online Help Testing）</h3><p>验证系统的实时在线帮助的可用性和正确性。</p><h3 id="4-25-数据转换测试（Data-Conversion-Testing）"><a href="#4-25-数据转换测试（Data-Conversion-Testing）" class="headerlink" title="4.25 数据转换测试（Data Conversion Testing）"></a>4.25 数据转换测试（Data Conversion Testing）</h3><p>验证已存在的数据转换是否有效。 </p><p>考虑的因素：审计能力，数据库验证，数据整理，恢复计划。</p><h3 id="4-26-备份测试（Backup-Testing）"><a href="#4-26-备份测试（Backup-Testing）" class="headerlink" title="4.26 备份测试（Backup Testing）"></a>4.26 备份测试（Backup Testing）</h3><p>备份测试的目的是验证系统在软件或硬件失效的事件中备份其数据的能力。</p><h3 id="4-27接口测试（Interface-Testing）"><a href="#4-27接口测试（Interface-Testing）" class="headerlink" title="4.27接口测试（Interface Testing）"></a>4.27接口测试（Interface Testing）</h3><p>接口测试是对软件需求规格说明中的接口需求逐项进行的测试。</p><h3 id="4-28-人机交互界面测试（User-Interface-Testing）"><a href="#4-28-人机交互界面测试（User-Interface-Testing）" class="headerlink" title="4.28 人机交互界面测试（User Interface Testing）"></a>4.28 人机交互界面测试（User Interface Testing）</h3><p>人机交互界面测试对所有人机交互界面提供的操作和显示界面进行测试，以检验是否满足用户要求。</p><h3 id="4-29-余量测试（Remainder-Testing）"><a href="#4-29-余量测试（Remainder-Testing）" class="headerlink" title="4.29 余量测试（Remainder Testing）"></a>4.29 余量测试（Remainder Testing）</h3><p>保证程序执行过程中遇到资源以外的情况时，仍能维持正常运行状态。</p><h3 id="4-30-协议测试（Protocol-Testing）"><a href="#4-30-协议测试（Protocol-Testing）" class="headerlink" title="4.30 协议测试（Protocol Testing）"></a>4.30 协议测试（Protocol Testing）</h3><p>对实现的协议的正确性和有效性进行判别。</p><h3 id="4-31-内存泄漏测试（Memory-Leak-Testing）"><a href="#4-31-内存泄漏测试（Memory-Leak-Testing）" class="headerlink" title="4.31 内存泄漏测试（Memory Leak Testing）"></a>4.31 内存泄漏测试（Memory Leak Testing）</h3><p>对软件运行可能存在的各种内存泄露进行检查。</p><h3 id="4-32-存储测试-Storage-Testing"><a href="#4-32-存储测试-Storage-Testing" class="headerlink" title="4.32 存储测试 (Storage Testing)"></a>4.32 存储测试 (Storage Testing)</h3><p>对系统的存储功能进行测试，包括存储文件和存储介质。</p><h3 id="4-33-软件老化（software-aging）"><a href="#4-33-软件老化（software-aging）" class="headerlink" title="4.33 软件老化（software aging）"></a>4.33 软件老化（software aging）</h3><p>软件老化是在长期运行的软件系统上，由于错误条件的积累和资源的逐步消耗导致软件系统的性能逐渐下降、错误率不断上升并最终出现故障的一类问题。</p><h3 id="4-34-不稳定性测试（flaky-testing）"><a href="#4-34-不稳定性测试（flaky-testing）" class="headerlink" title="4.34 不稳定性测试（flaky testing）"></a>4.34 不稳定性测试（flaky testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h2 id="5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"><a href="#5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）" class="headerlink" title="5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"></a>5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）</h2><h3 id="5-1组合测试（Combinatorial-Testing）"><a href="#5-1组合测试（Combinatorial-Testing）" class="headerlink" title="5.1组合测试（Combinatorial Testing）"></a>5.1组合测试（Combinatorial Testing）</h3><p>组合测试是一种充分考虑各种因素及其相互作用的科学实用的软件测试方法，通过设计一组数量较少的测试用例，直接检测各种影响因素及其组合对软件产生的影响。</p><h3 id="5-2蜕变测试（Metamorphic-Testing）"><a href="#5-2蜕变测试（Metamorphic-Testing）" class="headerlink" title="5.2蜕变测试（Metamorphic Testing）"></a>5.2蜕变测试（Metamorphic Testing）</h3><p>蜕变测试一般指在预期输出无法给出的情况下，通过设计各种输入关系，观察输出是否满足预期的性质，用以判断软件的正确性。是一种基于性质的软件测试。</p><h3 id="5-3基于规格说明的软件测试-Specification-Based-Software-Testing"><a href="#5-3基于规格说明的软件测试-Specification-Based-Software-Testing" class="headerlink" title="5.3基于规格说明的软件测试(Specification Based Software Testing)"></a>5.3基于规格说明的软件测试(Specification Based Software Testing)</h3><p>基于规格说明的测试是验证软件的实现与规格说明的一致性。是一种黑盒测试技术。</p><h3 id="5-4基于模型的软件测试（model-based-testing）"><a href="#5-4基于模型的软件测试（model-based-testing）" class="headerlink" title="5.4基于模型的软件测试（model based testing）"></a>5.4基于模型的软件测试（model based testing）</h3><p>基于模型的软件测试可以根据软件行为模型和结构模型生成测试用例。它利用模型来描述系统的行为、特性和需求，以便自动生成测试用例、执行测试和验证系统的正确性。</p><p>软件测试模型包括有限状态机、UML、文法等。需要测试人员具备一定的理论基础和工具使用能力。</p><h3 id="5-5基于错误的软件测试-fault-based-testing"><a href="#5-5基于错误的软件测试-fault-based-testing" class="headerlink" title="5.5基于错误的软件测试(fault based testing)"></a>5.5基于错误的软件测试(fault based testing)</h3><p>基于错误的软件测试针对待测试软件中可能存在的某种软件错误，设计相应的测试用例，当运行这组测试用例时，如果没有发现错误，则认为该软件中不存在这类错误。</p><h3 id="5-6基于搜索的软件测试-Search-Based-Testing"><a href="#5-6基于搜索的软件测试-Search-Based-Testing" class="headerlink" title="5.6基于搜索的软件测试(Search Based Testing)"></a>5.6基于搜索的软件测试(Search Based Testing)</h3><p>基于搜素的软件测试是一种利用元启发式搜索技术自动生成测试数据的测试方法，可以进行结构测试、功能测试、灰盒测试、非功能性测试。</p><h3 id="5-7统计测试-Statistics-Testing"><a href="#5-7统计测试-Statistics-Testing" class="headerlink" title="5.7统计测试(Statistics Testing)"></a>5.7统计测试(Statistics Testing)</h3><p>统计测试是一种根据定义好的概率分布来随机选择测试用例的软件测试方法。</p><h3 id="5-8基于操作剖面的测试-Operational-Profile-Based-Testing"><a href="#5-8基于操作剖面的测试-Operational-Profile-Based-Testing" class="headerlink" title="5.8基于操作剖面的测试(Operational Profile Based Testing)"></a>5.8基于操作剖面的测试(Operational Profile Based Testing)</h3><p>基于操作剖面的测试是一种统计测试方法，它按照人们对软件各项功能的使用概率选择测试用例。</p><h3 id="5-9变异测试（Mutation-Testing）"><a href="#5-9变异测试（Mutation-Testing）" class="headerlink" title="5.9变异测试（Mutation Testing）"></a>5.9变异测试（Mutation Testing）</h3><p>变异测试通过在程序中植入一些程序员容易犯的错误，或利用相关的启发式方法植入一些错误，这些错误都是通过对原来的程序做一些句法上的修改，从而形成一组新的程序，称之为变异体，通过运行针对原程序的测试用例集，如果这些原来的测试用例能够发现变异体中错误，称之为杀死变异体，否则称为变异体存活。最后通过分析被杀死的变异体数量和存活的变异体数量，来推测软件程序中可能仍潜在的错误数量，评估针对原有程序的测试用例集的测试充分性程度。</p><p>结果：如果一个测试用例集能杀死所有植入错误的变异体，则这个测试用例集就有可能有能力检测出所有可能潜在的错误。</p><h3 id="5-10脆弱性测试（flaky-Testing）"><a href="#5-10脆弱性测试（flaky-Testing）" class="headerlink" title="5.10脆弱性测试（flaky Testing）"></a>5.10脆弱性测试（flaky Testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h3 id="5-11基于性质的软件测试方法-Property-Based-Testing"><a href="#5-11基于性质的软件测试方法-Property-Based-Testing" class="headerlink" title="5.11基于性质的软件测试方法(Property-Based Testing)"></a>5.11基于性质的软件测试方法(Property-Based Testing)</h3><p>基于性质的测试通常假设待测试程序满足给定性质，围绕给定性质进行测试，验证软件是否满足其定义的性质。</p><h3 id="5-12极限测试-Extreme-Testing"><a href="#5-12极限测试-Extreme-Testing" class="headerlink" title="5.12极限测试(Extreme Testing)"></a>5.12极限测试(Extreme Testing)</h3><p>先创建单元测试和验收测试，然后再创建代码库，这种形式的测试叫极限测试，也叫测试驱动开发。</p><p>验收测试是极限测试类型，其目的是判断应用程序是否满足如功能性和易用性等需求。在设计或计划阶段，由开发人员和客户来设计验收测试。</p><h3 id="5-13模糊测试（Fuzzing-Testing）"><a href="#5-13模糊测试（Fuzzing-Testing）" class="headerlink" title="5.13模糊测试（Fuzzing Testing）"></a>5.13模糊测试（Fuzzing Testing）</h3><p>模糊测试主要用于发现程序内部的安全漏洞和其他缺陷。通过向程序输入随机、无效或意外的数据，测试人员可以观察系统的反应，从而识别潜在的错误、崩溃和安全漏洞。</p><p>模糊测试是一种通过提供非预期的输入并监视异常结果来发现软件故障的方法。</p><h3 id="5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）"><a href="#5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）" class="headerlink" title="5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）"></a>5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）</h3><p>自适应测试也称为软件测试的控制论方法：是软件控制论的重要组成部分，它把软件测试的问题归结为控制问题，被测试软件当做被控制对象，软件测试策略当作相应的控制器，这样被测试软件和测试策略就构成一个闭环反馈控制系统。通过控制理论指导软件测试过程，从而希望达到科学有效地测试软件的目的。</p><p>自适应控制系统是通过在线实时了解被控对象，不断调节控制器，使系统的性能达到技术要求或最优。</p><p>缺点：反馈机制不够成熟。</p><h3 id="5-15导向性随机测试（Concolic-Testing）"><a href="#5-15导向性随机测试（Concolic-Testing）" class="headerlink" title="5.15导向性随机测试（Concolic Testing）"></a>5.15导向性随机测试（Concolic Testing）</h3><p>导向性随机测试是一种将具体执行与符号执行相结合的自动化测试方法，其目标是通过生成测试输入来执行程序中的所有可行路径，以发现程序缺陷。</p><h3 id="5-16图形用户界面测试（GUI-Testing）"><a href="#5-16图形用户界面测试（GUI-Testing）" class="headerlink" title="5.16图形用户界面测试（GUI Testing）"></a>5.16图形用户界面测试（GUI Testing）</h3><p>GUI测试是一种软件测试过程，测试的对象是软件产品的图形用户界面，目的是确保图形用户界面符合用户要求或规格说明书要求。</p><h3 id="5-17随机测试-Random-Testing"><a href="#5-17随机测试-Random-Testing" class="headerlink" title="5.17随机测试(Random Testing)"></a>5.17随机测试(Random Testing)</h3><p>在待测试软件所有可能的输入中，随机选择和产生测试输入并对待测试软件进行测试，这种测试方法叫做随机测试。</p><h3 id="5-18自适应随机测试-Adaptive-Random-Testing"><a href="#5-18自适应随机测试-Adaptive-Random-Testing" class="headerlink" title="5.18自适应随机测试(Adaptive Random Testing)"></a>5.18自适应随机测试(Adaptive Random Testing)</h3><p>一个测试用例如果没有发现软件故障，那么另一个相近或相似的测试用例可能也不会发现软件故障，因此在选择下一个测试用例时，要尽可能选择距离该测试用例远一点的测试。即使得测试用例尽可能均匀分散开。</p><p>自适应随机测试方法强调在随机选择测试用例的过程中，要使得测试用例尽可能均匀地分散开，这样随机产生的测试用例才有可能有更多机会发现软件故障。</p><h3 id="5-19反随机测试（Antirandom-Testing）"><a href="#5-19反随机测试（Antirandom-Testing）" class="headerlink" title="5.19反随机测试（Antirandom Testing）"></a>5.19反随机测试（Antirandom Testing）</h3><p>首先为待测试软件随机生成一个测试用例，随后每一个测试用例的生成都要求与已生成的测试用例保持最大的距离。</p><p>第一个测试用例是随机的，后面的测试用例可以看作是确定的。</p><h3 id="5-20结对测试-Pair-Testing"><a href="#5-20结对测试-Pair-Testing" class="headerlink" title="5.20结对测试(Pair Testing)"></a>5.20结对测试(Pair Testing)</h3><p>结对测试是由两个测试人员结对在一起对待测试软件进行测试的方法，一个测试人员控制鼠标和键盘，另一个测试人员做记录，一起讨论测试场景，提问题。结对的两个测试人员一般一个是专业测试人员，一个是开发人员或业务分析员。</p><h3 id="5-21在线测试（Online-Testing）"><a href="#5-21在线测试（Online-Testing）" class="headerlink" title="5.21在线测试（Online Testing）"></a>5.21在线测试（Online Testing）</h3><p>在线测试，也称为动态测试，该方法在待测试软件运行过程中动态产生测试用例，而不是事先产生测试用例。在线测试还存在很多问题，如覆盖性度量、测试场景的控制、故障的分析、重现及避免相同故障的重复出现等。</p><h3 id="5-22探索性测试（Exploratory-Testing）"><a href="#5-22探索性测试（Exploratory-Testing）" class="headerlink" title="5.22探索性测试（Exploratory Testing）"></a>5.22探索性测试（Exploratory Testing）</h3><p>这种测试方法强调测试人员个人的自由和责任，可以充分发挥他们的创造性和积极性，它把测试过程看成是一种与测试相关的学习，测试设计、测试执行和测试结果的解释同时进行且相互促进。</p><p>探索性测试的特点：强调测试设计与测试执行的同时性，这种同时性是相对传统软件测试过程中的先设计后测试来说的。测试工程师通过测试来不断学习被测试系统，通过学习来改进测试过程。探索性测试强调自由性和创造性。</p><h3 id="5-23反模型测试（Anti-model-Testing）"><a href="#5-23反模型测试（Anti-model-Testing）" class="headerlink" title="5.23反模型测试（Anti-model Testing）"></a>5.23反模型测试（Anti-model Testing）</h3><p>反模型测试和基于模型的测试方法相反，它一开始没有模型可用，通过执行一些抽样出来的测试用例，观察系统行为，并将这些信息综合起来，通过分析推理形成关于系统的一个抽象的模型。</p><h3 id="5-24成分测试（Compositional-Testing）"><a href="#5-24成分测试（Compositional-Testing）" class="headerlink" title="5.24成分测试（Compositional Testing）"></a>5.24成分测试（Compositional Testing）</h3><p>用分治法把复杂的大规模软件测试分解为测试该软件的各个组成成分。</p><p>成分测试是一种在软件工程中用于验证软件组件的技术。它关注于系统的组成部分——例如软件模块、组件或服务——如何组合在一起，以及这些组合如何影响系统的整体性能和行为。</p><h3 id="5-25-有限状态机测试（FSM-Testing）"><a href="#5-25-有限状态机测试（FSM-Testing）" class="headerlink" title="5.25 有限状态机测试（FSM Testing）"></a>5.25 有限状态机测试（FSM Testing）</h3><p>有限状态机测试是一种基于有限状态机理论的测试方法，广泛应用于软件系统和硬件设计的测试中。有限状态机（FSM）是一种数学模型，用于描述系统在不同状态之间的转移和行为。FSM Testing 的主要目标是验证系统在不同输入下的状态转移是否符合预期，确保软件或硬件的功能正确性。</p><h3 id="5-26-基于Petri网的测试（Petri-Net-based-Testing）"><a href="#5-26-基于Petri网的测试（Petri-Net-based-Testing）" class="headerlink" title="5.26 基于Petri网的测试（Petri Net based Testing）"></a>5.26 基于Petri网的测试（Petri Net based Testing）</h3><p>Petri网是一种图形化的形式化语言表示法, 该方法采用具有形式语义的图形语言, 既有严格的数学定义，又有直观的图形表示。</p><p>FSM一般是顺序性的，它定义的状态一般都是全局的状态；而Petri网一般是并行的，它定义的状态一般都是分布式的。</p><h3 id="5-27-基于模型检查的测试（Model-Checking-based-Testing）"><a href="#5-27-基于模型检查的测试（Model-Checking-based-Testing）" class="headerlink" title="5.27 基于模型检查的测试（Model Checking based Testing）"></a>5.27 基于模型检查的测试（Model Checking based Testing）</h3><p>模型检测的基本思想：用状态迁移系统（S）表示系统的行为，用模态&#x2F; 时序逻辑公式（F）描述系统的性质.。这样“系统是否具有所期望的性质”就转化为数学问题“状态迁移系统S是否是公式F 的一个模型？”</p><p>将一个过程或系统抽象成一个有穷状态模型，加以分析验证。</p><p>与测试不同，模型检测不是针对某组输入，而是面向某类性质来检查系统是否合乎规约!</p><h3 id="5-28-TTCN测试（TTCN-Testing）"><a href="#5-28-TTCN测试（TTCN-Testing）" class="headerlink" title="5.28 TTCN测试（TTCN Testing）"></a>5.28 TTCN测试（TTCN Testing）</h3><p>TTCN（Testing and Test Control Notation）是一种专门为测试系统和协议设计的标准化测试语言，广泛应用于电信、网络和其他领域的系统验证与测试中。TTCN允许测试人员定义测试用例、测试脚本和测试执行过程，以确保被测试对象（被测系统）符合其设计规范。</p><h3 id="5-29-布尔规格测试（Boolean-Specification-Testing）"><a href="#5-29-布尔规格测试（Boolean-Specification-Testing）" class="headerlink" title="5.29 布尔规格测试（Boolean Specification Testing）"></a>5.29 布尔规格测试（Boolean Specification Testing）</h3><p>如何根据这些布尔表达式设计测试用例来测试根据这些布尔规格说明建立起来的软件，并发现其中隐藏的错误是布尔规格测试的关键问题。 </p><h3 id="5-30-基于统一建模语言测试（UML-Based-Testing）"><a href="#5-30-基于统一建模语言测试（UML-Based-Testing）" class="headerlink" title="5.30 基于统一建模语言测试（UML Based Testing）"></a>5.30 基于统一建模语言测试（UML Based Testing）</h3><p>UML是一种可视化的面向对象系统建模描述工具。所谓基于UML的测试，就是应用待测试软件系统的UML模型来获得软件测试的需求和覆盖准则。</p><h3 id="5-31-差分测试（differential-testing）"><a href="#5-31-差分测试（differential-testing）" class="headerlink" title="5.31 差分测试（differential testing）"></a>5.31 差分测试（differential testing）</h3><p>主要用于比较两个或多个实现（例如，不同版本的程序或不同的实现算法）在相同输入下的输出结果，以发现潜在的缺陷或不一致之处。差分测试常用于确保新版本的软件相对于旧版本或不同实现之间的兼容性和一致性。</p><h3 id="5-32故障注入测试（Fault-Injection-Testing）"><a href="#5-32故障注入测试（Fault-Injection-Testing）" class="headerlink" title="5.32故障注入测试（Fault Injection Testing）"></a>5.32故障注入测试（Fault Injection Testing）</h3><p>故障注入测试是一种强大的软件测试技术，其主要目的是通过故意向系统中注入故障，验证系统在面对错误或异常情况下的反应和处理能力。这种测试可以帮助开发者发现潜在问题，评估系统的健壮性、可靠性和容错能力。</p><h2 id="6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"><a href="#6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）" class="headerlink" title="6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"></a>6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）</h2><h3 id="6-1面向对象软件的测试-Object-Oriented-Software-Testing"><a href="#6-1面向对象软件的测试-Object-Oriented-Software-Testing" class="headerlink" title="6.1面向对象软件的测试(Object Oriented Software Testing)"></a>6.1面向对象软件的测试(Object Oriented Software Testing)</h3><p>面向对象软件测试是一种专门针对面向对象编程（Object-Oriented Programming, OOP）设计的软件测试方法。由于面向对象的程序具有独特的特性，如<strong>封装、继承、多态</strong>，传统的软件测试方法并不总是适用于这种编程范式。因此，面向对象软件测试的重点在于处理这些独特的特性，并在测试中有效地验证程序的正确性、性能和可靠性。</p><p>测试对象间的交互、继承关系和多态性，确保类之间的继承结构和方法重载、重写等特性不会引发错误。面向对象的软件测试需要关注更细致的粒度，如类的内部状态、对象间的消息传递和状态变更。</p><h3 id="6-2面向方面的软件测试-Aspect-Oriented-Software-Testing"><a href="#6-2面向方面的软件测试-Aspect-Oriented-Software-Testing" class="headerlink" title="6.2面向方面的软件测试(Aspect Oriented Software Testing)"></a>6.2面向方面的软件测试(Aspect Oriented Software Testing)</h3><p>该编程范型主要强调将软件系统特别是面向对象系统中的分布在各种类和对象中的关注点（即所谓横切关注点）分离出来，实现比原来系统更好的模块化。</p><p>面向方面编程的核心就是将分散在多个模块中的一些核心关注点、中心功能，如登录功能和认证功能等，从这些模块中分离出来，横切出来的关注点独立地实现为系统的一个方面，这个方面的具体实现可以利用传统方法，例如面向对象的方法。</p><h3 id="6-3面向服务的软件测试-Service-Oriented-Software-Testing"><a href="#6-3面向服务的软件测试-Service-Oriented-Software-Testing" class="headerlink" title="6.3面向服务的软件测试(Service Oriented Software Testing)"></a>6.3面向服务的软件测试(Service Oriented Software Testing)</h3><p>面向服务的软件测试原理主要依赖于服务导向架构（SOA）和微服务架构的核心概念。该测试方法关注于确保各个服务之间的正常交互和完整性，以提供高质量的系统。</p><p>主要测试服务的功能、服务间的通信（如消息队列、API接口）、服务的独立性及其异常处理。重点是验证服务的接口、协议兼容性和依赖关系。</p><h3 id="6-4构件软件测试-Component-Based-Software-Testing"><a href="#6-4构件软件测试-Component-Based-Software-Testing" class="headerlink" title="6.4构件软件测试(Component Based Software Testing)"></a>6.4构件软件测试(Component Based Software Testing)</h3><p>基于构件的软件测试，是指在构件（Component）基础上进行的测试过程，构件可以是软件系统中的独立模块、服务或功能单元。这种测试方法强调构件的可重用性和互操作性，以提高软件开发的效率和质量。</p><p>专注于验证和评估软件系统中各个独立组件的功能和交互。此方法适用于组件化的软件开发模型，其中软件系统由多个松耦合、可重用的组件构成。</p><h3 id="6-5-Web应用软件测试-WEB-Testing"><a href="#6-5-Web应用软件测试-WEB-Testing" class="headerlink" title="6.5 Web应用软件测试(WEB Testing)"></a>6.5 Web应用软件测试(WEB Testing)</h3><p>对于WEB应用软件来说，WEB应用软件的测试具有更大的挑战。测试也是为了发现软件的错误并最终修正错误而运行软件的过程，但由于基于WEB的系统和应用存在于网络上，并且和很多不同的操作系统、浏览器（或其他界面设备如PDA、手机等）、硬件平台、通信协议、后台应用进行交互。</p><p>WEB应用软件测试就是为了发现WEB应用中的内容、功能、易用性、导航、性能、容量、安全性等方面的错误，Web测试需要关注跨浏览器兼容性、页面加载速度、响应式设计、安全性（如XSS、SQL注入）、以及多用户并发操作等因素</p><h3 id="6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing"><a href="#6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing" class="headerlink" title="6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)"></a>6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)</h3><p>普适计算（又称无处不在计算）指的是计算设备无处不在地嵌入到环境中，测试需要关注多种设备的互联和环境感知。</p><p>测试需要考虑设备间的协同、网络带宽和延迟、环境变化对系统的影响等，还要考虑设备的电池寿命、隐私保护和数据传输安全等因素。</p><p>普适计算环境下的软件测试是指在一个无处不在且高度集成的计算环境中，对软件系统进行的测试。在这样的环境中，计算设备和服务可以无缝地集成到日常生活中，用户可能会通过多种设备和场景与软件互动。</p><p>普适计算软件测试面临的挑战：</p><ul><li>上下文背景是挥发性的和瞬发的</li><li>普适计算环境中的物理背景本质上是不稳定的，有干扰和不精确的</li><li>普适计算软件中的各个计算实体是独立的和自我为中心的</li></ul><h3 id="6-7云测试-Cloud-Testing"><a href="#6-7云测试-Cloud-Testing" class="headerlink" title="6.7云测试(Cloud Testing)"></a>6.7云测试(Cloud Testing)</h3><p> 云测试本质上是一种软件测试形式，其中网络应用程序使用云计算环境来模拟现实世界的用户流量作为负载和压力测试的一种方式，测试是利用云端的资源（如主机或服务等），此外，整个测试环境可以按需的从云端获得。</p><h3 id="6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things"><a href="#6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things" class="headerlink" title="6.8物联网环境下的软件测试(Software Testing for Internet of Things)"></a>6.8物联网环境下的软件测试(Software Testing for Internet of Things)</h3><p>物联网的定义是：通过射频识别（RFID）、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物体与互联网相连接，进行信息交换和通信，以实现对物体的智能化识别、定位、跟踪、监控和管理的一种网络。</p><p>物联网（IoT）测试是对物联网设备及其系统性能、功能和安全性的评估过程。</p><h3 id="6-9并行软件测试-Concurrent-Software-Testing"><a href="#6-9并行软件测试-Concurrent-Software-Testing" class="headerlink" title="6.9并行软件测试(Concurrent Software Testing)"></a>6.9并行软件测试(Concurrent Software Testing)</h3><p>并行软件是指设计为支持同时执行多个计算或操作的应用程序。这类软件可以通过多线程、分布式计算或多核心处理器来实现并行处理，从而提高性能和响应能力。</p><p>并行软件的测试通常指的是在开发并行处理或多线程应用程序时，针对这些并行特性进行的测试。</p><h3 id="6-10嵌入式软件测试-Embedded-Software-Testing"><a href="#6-10嵌入式软件测试-Embedded-Software-Testing" class="headerlink" title="6.10嵌入式软件测试(Embedded Software Testing"></a>6.10嵌入式软件测试(Embedded Software Testing</h3><p>嵌入式软件测试&#x2F;嵌入式测试或叫交叉测试（cross-test）的目的与非嵌入式软件是相同的。</p><p>嵌入式测试强调对硬件资源的高效利用和系统的实时性，需要考虑嵌入式系统的稳定性、响应时间、资源消耗等因素，且测试环境往往比较特殊。</p><h3 id="6-11高可信软件测试-High-Confidence-Software-Testing"><a href="#6-11高可信软件测试-High-Confidence-Software-Testing" class="headerlink" title="6.11高可信软件测试(High Confidence Software Testing)"></a>6.11高可信软件测试(High Confidence Software Testing)</h3><p>可信性是软件的行为及结果符合人们的预期，在操作失误、环境影响、外部攻击等干扰时，仍然可以提供连续的服务。 </p><p>软件可信性包含的特征属性有可用性（availability）、可靠性（reliablity）、安全性（security）、可维护（maintainability）、完整性（integrity）等。</p><p>测试过程中不仅需要进行功能验证，还要进行严格的容错、冗余性、安全性和恢复能力的测试，确保软件能够在关键情况下保持高可靠性。</p><h3 id="6-12网构软件测试（Internetware-testing）"><a href="#6-12网构软件测试（Internetware-testing）" class="headerlink" title="6.12网构软件测试（Internetware testing）"></a>6.12网构软件测试（Internetware testing）</h3><p>网构软件是指与网络紧密结合的软件，强调在分布式网络环境中运行。测试需要验证其在多变的网络环境中的表现。 </p><p>测试需关注网络变化（如延迟、带宽限制）对软件性能和稳定性的影响，特别是网络通信的可靠性和数据一致性。</p><h3 id="6-13移动应用软件测试（app-testing）"><a href="#6-13移动应用软件测试（app-testing）" class="headerlink" title="6.13移动应用软件测试（app testing）"></a>6.13移动应用软件测试（app testing）</h3><p>手机软件测试是确保移动应用质量和用户体验的重要过程。它涉及对手机应用程序进行功能、性能、安全性和用户体验等多方面的验证。</p><h3 id="6-14-人工智能软件测试（Artificial-intelligence-testing）"><a href="#6-14-人工智能软件测试（Artificial-intelligence-testing）" class="headerlink" title="6.14 人工智能软件测试（Artificial intelligence testing）"></a>6.14 人工智能软件测试（Artificial intelligence testing）</h3><p>人工智能软件的测试是一个复杂但至关重要的过程，涉及确保AI系统在不同场景下的有效性、可靠性和安全性。</p><p>特点：不确定性和不透明性；数据依赖性；动态变化；非确定性输出；伦理和法律合规性。</p><h3 id="6-15-区块链软件系统测试-blockchain-software-testing"><a href="#6-15-区块链软件系统测试-blockchain-software-testing" class="headerlink" title="6.15 区块链软件系统测试(blockchain software testing)"></a>6.15 区块链软件系统测试(blockchain software testing)</h3><p>区块链软件是指用于创建、管理和维护区块链网络的各种应用程序和平台。这些软件提供了一个去中心化的环境，用于交易、数据存储和智能合约等功能。</p><p>测试重点是验证区块链协议的实现，如交易验证、数据一致性、网络中节点的协作以及安全性。区块链软件测试是确保开发出安全、可靠和高效的区块链应用的关键步骤。</p><h3 id="6-16-云宇宙测试-metaverse-testing）"><a href="#6-16-云宇宙测试-metaverse-testing）" class="headerlink" title="6.16 云宇宙测试(metaverse testing）"></a>6.16 云宇宙测试(metaverse testing）</h3><p>元宇宙（metaverse）是一种虚拟空间，结合了增强现实（AR）、虚拟现实（VR）、区块链和社交网络等技术，允许用户在一个共享的数字世界中进行互动和体验。这个概念不仅限于单一的平台或应用，而是一个广泛的生态系统，用户可以在其中进行社交、游戏、工作、教育和创造。</p><p>元宇宙测试是在虚拟环境中评估、验证和优化不同功能和内容的过程。这可以涉及诸多方面，包括用户体验、性能、安全性和交互性等。</p>]]></content>
      
      
      <categories>
          
          <category> Software Engineering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
            <tag> Automated Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
