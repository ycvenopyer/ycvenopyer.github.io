<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>韵外之致，意在笔先————从宋元时期窥探书法的笔法与意蕴</title>
      <link href="/2024/12/27/calligraphy-in-song-yuan-dynasties/"/>
      <url>/2024/12/27/calligraphy-in-song-yuan-dynasties/</url>
      
        <content type="html"><![CDATA[<p>书法艺术是中国古代优秀的艺术文化，从商周的甲骨文到如今的硬笔书法，绵延千年，展现出其悠久的历史底蕴和文化感染力。从美术的角度来看，书法是中国古代人民对线条和结构布局的深刻理解与体悟，书法本身也经历了一系列变革，在魏晋时达到一个顶峰，以二王、锺繇为代表，在唐朝达到另一个顶峰，涌现出一大批书法名家，如颜真卿、柳公权、欧阳询、褚遂良、虞世南、怀素等等，他们都各自形成了自己的书体，开创了书法史上的一个璀璨时代。而本文取唐后的宋元时期，这一时期的书家对线条和笔法的研究颇深，以行书和草书为著，是书法史上极为重要的一环。</p><p>李建中《贵宅帖》中：宋人尚意，表现在书法上，重行草、崇流美的尚意书风，韵外之致，意在笔先，不仅在当时成为一种时尚，而且对后世有深远影响。书法所形成的意韵小到线条笔法，大到气势、章法、结构，所谓韵外之致，意在笔先，就是以笔法为重点讨论书法的韵味。宋元时期，书法虽无唐朝盛世的辉煌，但也涌现出一批富有个性的书家，他们以表现自我意识为主，崇尚个人意趣，展现出一股别样的风气。</p><p>自我意识，乃是一个书家所必须具备的素质。反映在创作上，就是创新的思想和不拘泥于古人，基本上人们都是从临摹学起，以古人的贴或碑为蓝本，学习笔画、字形、笔法、结构、章法，学的少了就固守于其中难以从其他的书家中学习，学的多了则难免不精，易泛泛流俗，没有自己的标准和定性。宋朝前期受宋太宗“帖学”的影响颇深，阻碍了书法的创新发展，欧阳修则提出学书法不能摹仿古人，要自成一体，由此诞生了宋四家。</p><p>宋四家均受褚遂良、颜真卿的深刻影响，笔法的势迥异。我本人推米芾为尊，《苕溪诗帖》浑厚中结合了灵动，厚重之余平添几分婉转，《蜀素贴》整体要平和、中正舒缓许多。米芾的字多为斜势，如同山巅的奇石，跌宕欹侧，同时他充分利用了毛笔的笔锋，八面为锋，可谓奇绝险峻，他对笔法的研究和运用炉火纯青，当为宋四家之首。苏轼，字如其人，《寒食帖》道尽了其平生豁达，他的字看似平平无奇，朴素乏味，实则内含一种汪洋浩荡之势，变化莫测。苏轼仕途不顺，被贬黄州，但他并非一蹶不振之人，而是乐观豁达，自在洒脱。他长于楷书、行书，笔法肉丰骨劲，自然天成。黄庭坚与苏轼一样，为尚意之派，然有人评其笔法如死蛇挂树，毫无美感，乍看黄的用笔，会觉得他用笔软弱随意，没有力度和形体，但实则他的行书凝练有力，结构奇特，每一笔极尽伸展，线条如长枪大戟，结字蕴含深意，并且他的字连贯度极好，章法堪称一绝，代表作为《诸上座贴》。宋四家中最年长者即为蔡襄，蔡襄为人忠厚、正值，讲求信义，他的书法也端庄浑厚、淳淡婉美，相比苏黄，他的书法或许缺少些许意趣，但相比唐朝，又不完全遵循古法，起到了承上启下的重要作用，同时也有所创新，婉约优美，谦谦君子。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy2.jpeg" alt="东坡"></p><p>宋四家体现了宋朝书法的顶尖水平，其用笔、写意均可称道，我觉得他们摆脱了传统楷书、行书的绝对规整和绮丽浮夸，各自有各自的特点，且将书法的笔法进行了延拓，如米芾对于外拓的运用、对于倚斜和平衡的把握，黄庭坚对长画和字形的研究，更可贵的是意的参杂，如苏轼《寒食帖》中自我的纾解和旷达洒脱的人生态度。俗话说：“字如其人。”此言不假，宋四家为代表，古代的众多书家亦如此，他们临池妙翰，不仅仅只是为了追求书法境界的至臻至善，更是其人生意趣和人生追求的真切反映。</p><p>谈到元朝，首推书法大家赵孟頫，在我看来，他是书法史上的一位集大成者。子昂琴棋书画具绝，书法上承袭二王、师法李北海，自创行楷，行书更是冠绝当世，小楷也是上佳。李北海的字我觉得与《唐集王圣教序》神似，用笔典雅端庄又不失行书的秀丽连贯，而赵孟頫根本上还是取法二王，颇得几分精华。行楷是介于楷书和行书之间的一种书体，赵孟頫首次为行楷定性，我学行楷是从他的《胆巴碑》入手，《胆巴碑》是他晚年的行楷作品，充分体现了他行楷的味道，作品整体笔法秀媚，苍劲浑厚。而最能体现他行楷特点的应该是他50岁所写的《三门记》，尤其是其中的各种“钩”画和“捺”画，是赵体笔法中区别于其他书体的最大特色。“钩”画果断凌厉，“捺”画则完美诠释了何为一波三折，优美秀丽。行书方面，子昂的字体飘逸秀美、遒劲圆熟，代表作有《洛神赋》、《秋兴赋》、《闲居赋》。我觉得赵体在结字方面也有诸多功夫，形神不散、严谨又活泼，比如“也”字，既可扁平，又可修长，卧钩既可收敛，又可舒展。</p><p>在我看来，宋元时期的书法最重要的在于书法的意，此时的书法家注重在笔墨之间表现“气、骨、神、韵”，其中“气”指书法的气势和力度，“骨”指笔画的骨骼结构，“神”是指书法作品所表现出的精神内核，“韵”则是指语言表达的韵律感受。在书法的低级阶段，人们以象为先，注重形体的相似，简单来说，写得越像越好，把握住一种字体的形，但这并不意味着把握了书写这种字体的方法，死板模仿人人都会，难在理解字体的用笔和章法结构。每一种字体都有其特殊的用笔方法，或是中锋、侧锋，或是外拓、内擫，比如米芾将外拓笔法运用熟练至极，字体斜中取势，不偏不倚。而且真正好的临帖应该是临其神，摹其韵，我们可以看到，世间流传的《兰亭序》均为摹本，最著名的是冯承素本，其次还有褚遂良本、虞世南本等等，除冯承素摹本外其他的摹本均参杂了一些书法家本人的一些气韵，不墨守成规，也正是体现了书法家本身的一些思考。在书法的创作阶段，书法家是绝不能把别人的一种字体完全搬过来的，这里需要所谓的自我意识，书法家在平时已经形成了一套自己的用笔方法和习惯，对笔法、结构、章法也具有自己的理解和体悟，那么此时就会转化成作品。一幅好的书法作品，或者说是合格的书法作品，首先要有自己的思考，其次是对“气、骨、神、韵”的运用。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy3.jpg" alt="定风波"></p><p>韵外之致，意在笔先，宋元时期为我们呈现出了意在书法上的绝妙运用，这是作者自己意趣和品性的体现，姑且称之为书法中的意识流，近代书法尚古，回溯古法，而现代许多书家又尚意，但很多书家备受争议，如兰亭奖得主崔寒柏。书法中对意的理解和追求从未停止，无论何种书体，都是作者自身对书法艺术、对意蕴的思考和感悟，而宋元时期则为我们提供了丰富的意的含义。笔下生辉，我们需要的，是生于古法、成于今朝的笔法，是能体现别样思考和精神境界的意蕴。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Calligraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据时代的认知革命</title>
      <link href="/2024/12/27/huge-data-era-cognitive-revolution/"/>
      <url>/2024/12/27/huge-data-era-cognitive-revolution/</url>
      
        <content type="html"><![CDATA[<p>信息文明的发展是以大数据为基础的。</p><p>传统数据：可结构化</p><p>大数据：非结构化、半结构化</p><p>个人认知-&gt;集体认知-&gt;人工智能</p><h2 id="一．大数据：信息时代的根基"><a href="#一．大数据：信息时代的根基" class="headerlink" title="一．大数据：信息时代的根基"></a>一．<strong>大数据：信息时代的根基</strong></h2><p>什么是大数据？</p><p>大数据是指无法在可容忍的时间内用传统信息技术和软硬件工具对其进行感知、获取、管理、处理和服务的数据集合。</p><p>大数据&#x3D;传统的小数据+现代的大记录。</p><p>①　全数据：各个角度，不一定大。</p><p>②　小数据：以单个人为研究对象，重点在于研究的深度。用大数据得到规律，用小数据去匹配个人。</p><p>③　形态多：非结构化数据的大量涌现。如：网页、在线评论等。形态多不只意味着种类众多，还包含了混杂性。</p><p>④　结构化数据与非结构化数据的混杂。</p><p>⑤　速度快：数据的时效性，如人口普查。实时性：如体育赛事直播，交通路况。数据生产速度快；数据处理速度快；数据的价值随时间流逝而折扣。</p><p>⑥　价值大但密度低：大数据蕴涵着巨大的潜能和未知的属性。</p><p>一个观点：任何数据都可以是结构化数据。非结构化是暂时的，是人类的认知尚未达到某种水平。换言之，非结构化是非建模。</p><p>认知的角度论：不同人对于同一事物的认知不同，同一人对于不同事物的认知亦然，同一个人从不同角度对事物的认知也不同，角度决定认知的方向，认知的方向决定认知的思维策略。</p><p>认知的本质论：认知本质就是一个复杂的过程，所谓认知的概念是人脑提出来的，千年前或尚无认知一说，千年后认知也必然不同，不同的认知都是为了揭示事物的本质。</p><p>数据的精确与模糊：传统时代人们追求统计的方便和准确。大数据时代，舍恩伯格提出：“执迷于精确性是信息缺乏时代和模拟时代的产物”。</p><h2 id="二．大数据的哲学思考"><a href="#二．大数据的哲学思考" class="headerlink" title="二．大数据的哲学思考"></a>二．<strong>大数据的哲学思考</strong></h2><p>本体论：世界可分为三类体：第一体即物理实体，是由自然界物质以及人类所创造的各种实体设备、人造材料所构成的物质与材料世界。第二体即意识人体，指作为地球生命体代表的人体，构成社会的基本要素，人体具有自身的智能反应和智慧的意识活动。第三体即数字虚体，指存在于计算机和网络设备之中的所有数字代码集合体，基于计算机实现，由于网络通信而增强。</p><p>生存论：人类在这样的“镜像世界”的虚拟空间中获得了一种“镜像化生存”。“镜像的自我”，如照片，视频，vlog等。虚拟世界的个人记录，当人死后依据保留下来的数据性格仍可将其复活。如Twitter的Liveson功能，“生命虽逝，推文不止”。</p><p>方法论：抛弃对因果关系的追求而仅仅满足于获得相关关系。“知道是什么就够了，没必要知道为什么。在大数据时代，我们不必非得知道现象背后的原因，而是要让数据自己发声。“</p><p>对相对关系的分析构成了大数据预测的核心。任何的预测本身就是一种对被预测现象的干预过程，因此当所有人都知道这种预测之后，这种预测也就失效了。</p><p>克里斯·安德森：数据的洪流或将带来理论的终结。原先两个不同体系间需要搭建严格的逻辑范式来转换，而在大数据的支持下，只需数据足够多，通过匹配检索即可完成。</p><p>反对：一方面，大数据只能从过去的经验中学习，从而预测未来的趋势，但如果某件事在过去从未发生过，那么就无法预测。另一方面，我们需警惕大数据可能带来的无法预测的后果，如果一旦短时间内在大量数据中出现某种协同性偏差，就很容易导致滚雪球效应。</p><h2 id="三．从科学哲学视角研究大数据"><a href="#三．从科学哲学视角研究大数据" class="headerlink" title="三．从科学哲学视角研究大数据"></a>三．<strong>从科学哲学视角研究大数据</strong></h2><p>Jim Gray：科学研究范式四个阶段：</p><p>①　实验科学</p><p>②　理论科学</p><p>③　计算科学</p><p>④　数据密集型科学</p><p>数据驱动型方法论：</p><p>①　存在某种直觉的合理性，从存在的数据中所作出的归纳被证明是科学推理的一种关键形式，并且可以指导并渗透于实验的研究之中。</p><p>②　从数据中获得有意义的模式的过程中机器的核心作用，并且因此引出自动化推理的核心作用。</p><p>数据自然界：数据成为了和自然与社会相平行的一个新的领域。大数据科学流程间实现高度的自动化过程。”数据挖掘“，”机器学习“。</p><p>大数据的科学建模与科学说明：</p><p>只要数据的广度和精度足够充足，大数据就足以表征复杂对象。Pietsch将其称为”水平式建模”。科学对世界的理解通常总是预设统一论的解释。某个现象是通过和其他现象相互关联起来并且减少独立假设的数量而得以理解的。人们认知新事物是通过已知事物进行类比模拟。</p><p>复杂科学中的现象，比如社会科学，可能完全无法获得统一论的说明，因为缺乏普遍性的规律。</p><h2 id="四．大数据统计学的革命及其哲学意义"><a href="#四．大数据统计学的革命及其哲学意义" class="headerlink" title="四．大数据统计学的革命及其哲学意义"></a>四．<strong>大数据统计学的革命及其哲学意义</strong></h2><p>统计：参数化-&gt;非参数化</p><p>大数据：层级式建模-&gt;水平式建模</p><p>大数据科学的理论负载性与因果结构</p><p>结论：大数据是信息时代的复杂性科学。</p><p>①　大数据科学是符合信息时代特征的新的知识发现方式。</p><p>②　大数据时代信息技术成为了知识发现的主体。</p><p>③　大数据直接面对全体数据，分析的样本为全体数据，科学建模并不具有传统科学所具有的分层模型特征，而是水平式的。</p><p>④　大数据可以实现面向个体或者部分个体的微观规律的知识，具有高度语境特异性的特点。</p><p>⑤　信息技术的发展使我们存储和处理数据的能力极大增长，并造成了数据的爆炸，因此是促成大数据的外在成因。而统计科学思维和方法上的革命是内因。</p><h2 id="五．信息媒介与人的关系"><a href="#五．信息媒介与人的关系" class="headerlink" title="五．信息媒介与人的关系"></a>五．<strong>信息媒介与人的关系</strong></h2><p>媒介技术与人的双向延申：</p><p>技术哲学家卡普：“器官投影说”。</p><p>一方面从地位，技术是连接人类和自然的纽带，工具和机械作为技术的物化状态，是人体器官向大自然的外化、投影和延申。另一方面从功能，技术扩展、强化和补充了人体器官的各种技能，增强了人类控制和改造自然的能力。</p><p>人类的技术工具和器物是人体器官的投影，要理解作为技术文化的技术工具，我们必须先要理解人体的外形和功能，人体器官本身是创造技术人工物的外形和功能的尺度。</p><p>这种用人的身体来类比技术工具的本质有其合理性。一方面，早期对于技术本质的认识尚不深刻；另一方面，技术就是人的一种存在方式。</p><p>媒介理论学家麦克卢汉：“媒介延申论”。</p><p>媒介是人的延申。</p><p>传统传播学意义上：某种工具，提供了人们交流和传播的渠道。麦克卢汉的媒介还涉及多种完全不同类型的技术性工具，一切能延申人体和感官的技术工具都可以称为媒介。一切人造的东西都可以当做是过去用身体或身体的一部分所行使的功能的延申。</p><p>第二种理解：媒介即环境。</p><p>每当一种新的媒介出现时，人们会感到新奇，并且主动地关注到新媒介的存在，而当这种媒介逐渐融入人们的日常生活时，人们就不会对它感到惊讶了，它变成人熟知的环境背景。</p><p>人类媒介发展史：</p><ul><li>口语传播时代</li><li>印刷传播时</li><li>电子传播时代</li></ul><p>麦克卢汉的“全球村“：时空压缩；即时互动；整体思维与共时思维；感官的电子膨胀；感觉的电子化；情感模式。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Foundations of Data Science Review</title>
      <link href="/2024/12/27/foundations-of-data-science-review/"/>
      <url>/2024/12/27/foundations-of-data-science-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是我的2024Fall数据科学基础复习笔记（Review Notes of Foudations of Data Science）这门课由尹一通（尹神）和刘明谋老师开设，课程主页:<a href="https://tcs.nju.edu.cn/wiki/index.php?title=%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80_(Fall_2024)">2024 Fall 数据科学基础 NJU TCS GROUP</a></p><p>笔记如下:<a href="/file/foundations-of-data-science-review.pdf" download="foundations-of-data-science-review.pdf">notes</a><br>如有疏漏和错误欢迎指正。最后的期末考试以基本概念为主（统计部分不考），平时作业难度很大，有些是MU,GS,BHK（教材和参考书）的课后习题。</p><p>课程感受:尹神讲了前几次课给大家开了头，后续都是刘老师讲授的，这门课英文课件英文作业，个人认为对于概念理解应该会更好，但是需要投入较长时间。课程包括了经典概率论的所有内容，并且充满了TCS的味道，随机图和随机游走随机可见，随机过程的部分难度较大，马尔科夫链和贝叶斯估计以及假设检验那里和机器学习相关性非常大。</p>]]></content>
      
      
      <categories>
          
          <category> TCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability </tag>
            
            <tag> Random Process </tag>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Compiler Review</title>
      <link href="/2024/12/26/compiler-review/"/>
      <url>/2024/12/26/compiler-review/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="https://cubicy.icu/compiler-construction-principles/">编译原理课程笔记（All-in-One速通版）</a></p><h2 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1.词法分析"></a>1.词法分析</h2><h3 id="1-1-正则表达式"><a href="#1-1-正则表达式" class="headerlink" title="1.1 正则表达式"></a>1.1 正则表达式</h3><h3 id="1-2-有穷自动机"><a href="#1-2-有穷自动机" class="headerlink" title="1.2 有穷自动机"></a>1.2 有穷自动机</h3><p>NFA</p><p>DFA</p><p>NFA到DFA的转化：子集构造法（闭包）</p><p>DFA最小化：可区分状态的计算</p><h2 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h2><h3 id="2-1-语法分析器"><a href="#2-1-语法分析器" class="headerlink" title="2.1 语法分析器"></a>2.1 语法分析器</h3><p>从词法分析器获得Token序列，确认该序列是否可以由语言的文法生成。</p><ul><li>对于语法错误的程序，报告错误信息</li><li>对于语法正确的程序，生成语法分析树</li></ul><h3 id="2-2-上下文无关文法CFG"><a href="#2-2-上下文无关文法CFG" class="headerlink" title="2.2 上下文无关文法CFG"></a>2.2 上下文无关文法CFG</h3><p>终结符，非终结符，开始符号，产生式</p><p>推导和归约：逆过程</p><p>最左推导，最右推导，最左归约，最右规约</p><p>在自顶向下的分析中，总是采用<strong>最左推导</strong>；在自底向上的分析中，总是采用<strong>最左归约</strong></p><p>句型：文法G下可能推导出的一个符号序列，包含终结符&#x2F;非终结符，可以为空。</p><p>句子：只包含终结符的句型。</p><p>语言：文法G可产生的所有句子的集合。</p><p>正则文法VS上下文无关文法</p><p>Chomsky范式：</p><ul><li>0型文法&#x3D;短语结构文法 递归可枚举</li><li>1型文法&#x3D;上下文有关文法</li><li>2型文法&#x3D;CFG</li><li>3型文法&#x3D;RE</li></ul><h3 id="2-3-CFG的分析树Parse-Tree"><a href="#2-3-CFG的分析树Parse-Tree" class="headerlink" title="2.3 CFG的分析树Parse Tree"></a>2.3 CFG的分析树Parse Tree</h3><p>根节点&#x3D;文法初始符号；叶节点&#x3D;终结符；内部节点&#x3D;非终结符；父节点-&gt;{叶节点}&#x3D;产生式</p><h3 id="2-4-编程语言的文法设计"><a href="#2-4-编程语言的文法设计" class="headerlink" title="2.4 编程语言的文法设计"></a>2.4 编程语言的文法设计</h3><p>核心：无二义性</p><p>二义性来源：存在两个不同的最左推导</p><p>解决方法：确保只有一种最左推导，规定符号优先级，规定符号结合性</p><h3 id="2-5-自顶向下"><a href="#2-5-自顶向下" class="headerlink" title="2.5 自顶向下"></a>2.5 自顶向下</h3><p>每一步需要考虑：</p><ul><li>替换哪个非终结符</li><li>应用哪个产生式替换</li></ul><h4 id="2-5-1-递归下降分析"><a href="#2-5-1-递归下降分析" class="headerlink" title="2.5.1 递归下降分析"></a>2.5.1 递归下降分析</h4><p>适用于LL(k)文法</p><p>从根节点开始，尝试应用一个产生式，产生一个句型；递归下降到下一层，对句型中非终结符也尝试一个产生式；发生错误则选择其他的产生式，如果所有产生式都错误，失败，回溯到上层选择其他产生式。太慢！</p><h4 id="2-5-2-LL（1）和预测分析法"><a href="#2-5-2-LL（1）和预测分析法" class="headerlink" title="2.5.2 LL（1）和预测分析法"></a>2.5.2 LL（1）和预测分析法</h4><p>预测分析法：接收LL（k）文法</p><ul><li>第一个L: “left to right” 从左到右扫描</li><li>第二个L: “left-most derivation” 最左推导</li><li>k: 向前看k个token确定推导选用的产生式（一般不明确说k就是k&#x3D;1）</li></ul><p>这里添加了约束使其无需回溯！</p><p>FISRT集和FOLLOW集：</p><p>LL(1)预测分析实现方式：计算First,Follow-&gt;构造预测分析表-&gt;预测分析</p><p>在预测分析表中，如果某一格存在多个产生式，就说明无法确定选取哪个产生式（也即：产生了冲突），也就说明不是LL(1)文法！</p><blockquote><p>LL（1）的优劣：</p><ul><li>运行高效</li><li>递归实现符合文法结构、适合手动构造&amp;自动生成</li><li>能分析的文法类型受限</li></ul></blockquote><h4 id="2-5-3-消除左递归、提左公因子"><a href="#2-5-3-消除左递归、提左公因子" class="headerlink" title="2.5.3 消除左递归、提左公因子"></a>2.5.3 消除左递归、提左公因子</h4><p>LL（1）文法是无二义性、无左递归、无左公因子的。</p><p>左递归文法：有非终结符A使得$A\Rightarrow* A\alpha$，形如$S\rightarrow Sa$的称为立即&#x2F;直接左递归。</p><p><img src="/2024/12/26/compiler-review/image-20241218103228714.png" alt="1"></p><p>左公因子的文法：$P\rightarrow \alpha\beta|\alpha\gamma$</p><p>同一非终结符的多个候选式存在共同前缀，可能导致回溯。</p><p>解决：$P\rightarrow \alpha Q,Q\rightarrow \beta|\gamma$</p><h4 id="2-5-4-错误恢复"><a href="#2-5-4-错误恢复" class="headerlink" title="2.5.4 错误恢复"></a>2.5.4 错误恢复</h4><h3 id="2-6-自底向上"><a href="#2-6-自底向上" class="headerlink" title="2.6 自底向上"></a>2.6 自底向上</h3><p>从串w归约为文法开始符号S的过程。</p><p>需要考虑：</p><ul><li>何时归约（归约哪些符号串？）</li><li>归约到哪个非终结符号？</li></ul><p><img src="https://cubicy.icu/compiler-construction-principles/grammars.png" alt="grammars"></p><p>LR（k）文法：</p><ul><li>每一个LL（k）语法也是LR（k）的</li><li>不要求无左公因式</li><li>可以处理左递归文法</li><li>“L”: left-to-right scanning 自左向右扫描</li><li>“R”: right-most derivation in reverse 最右推导的逆</li><li>“k”: 向前看的字符的个数(k省略时取1)</li><li>子集（详见<a href="https://cubicy.icu/compiler-construction-principles/#grammars-set">该图</a>）：LR(1), LALR(1), SLR, LR(0), …</li></ul><h4 id="2-6-1-移进——归约Shift-Reduce"><a href="#2-6-1-移进——归约Shift-Reduce" class="headerlink" title="2.6.1 移进——归约Shift-Reduce"></a>2.6.1 移进——归约Shift-Reduce</h4><p>核心：将字符串一分为二。右侧是未被parser检查的，左侧包含终结符与非终结符。</p><p><img src="https://cubicy.icu/compiler-construction-principles/sr.png" alt="shift reduce"></p><p>LR分析采用最右推导的逆过程——最左归约。</p><p>采用栈进行移进归约。</p><p>表驱动的LR分析。</p><h4 id="2-6-2-LR（0）"><a href="#2-6-2-LR（0）" class="headerlink" title="2.6.2 LR（0）"></a>2.6.2 LR（0）</h4><p>核心：维护栈顶内容对于所有产生式右侧的进度。</p><p>项：一个产生式加上其在某处的一个点</p><p>LR（0）自动机的构造：DFA与分析表</p><p>GOTO集合</p><p><img src="https://cubicy.icu/compiler-construction-principles/lr-dfa-eg.png" alt="lr-dfa example"></p><p>DFA到分析表：Action表项和Goto表项</p><p><img src="/2024/12/26/compiler-review/image-20241218114809116.png" alt="2"></p><p><img src="https://cubicy.icu/compiler-construction-principles/lr0-stack-table.png" alt="lr0-stack-table"></p><p>LR实际上只有状态栈，符号信息可从相应状态中获取。</p><p>对于LR（0）中的0：项中没有向前看符号等信息，不关心后面的token，是否规约&#x2F;使用何产生式规约完全取决于栈顶状态。</p><p>局限性：移进——规约冲突。</p><h4 id="2-6-3-SLR（1）"><a href="#2-6-3-SLR（1）" class="headerlink" title="2.6.3 SLR（1）"></a>2.6.3 SLR（1）</h4><p>SLR（1）&#x3D;Simple LR（1），称为SLR文法，其实就是对LR（0）稍微修改</p><p>SLR的DFA和LR（0）的一样，但LR（0）的分析表中有一些规约是非法的，需要删去。</p><p> 在生成分析表的具体步骤上：</p><ul><li>LR(0)的某些状态包含可规约的Item，那么这个状态I在对应的Action表中T[I,_]这一行的每一个格子（无论终结符t是什么）无论如何都会有对应的rnrn项</li><li>SLR会关心后面的终结符是什么，因此如果t不在Follow集中，这不能是一个合法的规约，Action表对应的t列就不会有这个$r_n$</li></ul><p>局限性：不能消除所有移进规约冲突，如果产生冲突对应的终结符t恰好在Follow集中，就无法消除。</p><h4 id="2-6-4-LR（1）"><a href="#2-6-4-LR（1）" class="headerlink" title="2.6.4 LR（1）"></a>2.6.4 LR（1）</h4><p>包含后继token来消除一些规约动作。相当于分裂一些LR（0）的状态，精确指明何时应该规约。</p><p>LR（1）项的形式：$A\rightarrow \alpha\cdot\beta,a$</p><p>逗号后的a是向前看符号，即表明向前看一个终结符，可以是$</p><p>计算Closure，Goto表，Action表</p><p><img src="https://cubicy.icu/compiler-construction-principles/lr1-items.png" alt="lr1 items"></p><p>局限性：这样的文法限制过少，过于灵活，导致状态数量过多，状态表过于庞大。</p><p>话虽如此，文法仍然可能因为RR冲突和SR冲突而导致其不属于LR（1）！</p><p>所以在SLR（1）和LR（1）之间折中得到了LALR（1）</p><h4 id="2-6-5-LALR（1）"><a href="#2-6-5-LALR（1）" class="headerlink" title="2.6.5 LALR（1）"></a>2.6.5 LALR（1）</h4><p>LALR &#x3D; Look-Ahead LR，把LR（1）中只有向前看符号不同的项合并。</p><p>定义：把LR（1）中项的集合里所有向前看符号去掉，剩下的称为核，把LR（1）中所有核相同的状态两两合并为一个状态。新状态的项是两个旧状态的项的并。</p><p>代价：可能有RR冲突。</p><h3 id="2-7-语法分析杂项"><a href="#2-7-语法分析杂项" class="headerlink" title="2.7 语法分析杂项"></a>2.7 语法分析杂项</h3><h4 id="2-7-1-YACC"><a href="#2-7-1-YACC" class="headerlink" title="2.7.1 YACC"></a>2.7.1 YACC</h4><p>yacc&#x3D;yet another compiler-compiler</p><ul><li>基于LALR（1）</li><li>BNF范式</li><li>GNU版本名为Bison</li><li>流程：</li></ul><ol><li>Yacc源程序(*.y) &gt;&gt; Yacc Compiler &gt;&gt; C语言实现的LALR分析器(y.tab.c)</li><li>y.tab.c &gt;&gt; C Compiler &gt;&gt; 分析器可执行文件(<em>.exe&#x2F;</em>.out)</li><li>输入 &gt;&gt; 分析器可执行文件 &gt;&gt; 输出</li></ol><p>消除二义性与解决冲突</p><ul><li>消除二义性：<ul><li>指定运算符优先级：先出现的优先</li><li>指定运算符结合律：<code>%left</code>（左结合，例如乘法加法） <code>%right</code>（右结合，例如一元运算符负号）</li></ul></li><li>冲突解决<ul><li>规约-规约冲突：先出现的产生式优先采用</li><li>移进-规约冲突：移进优先采用</li></ul></li><li>更通用的方法：通过改写文法，可以在消除冲突的同时减少二义性</li></ul><h4 id="2-7-2-错误恢复（续）"><a href="#2-7-2-错误恢复（续）" class="headerlink" title="2.7.2 错误恢复（续）"></a>2.7.2 错误恢复（续）</h4><ul><li>局部错误恢复：调整Parse过程的栈，使其恢复到正常从而继续进行Parsing</li><li>全局错误恢复：删除&#x2F;插入尽可能少的字符，使得源字符串成为合法的字符串</li></ul><h3 id="2-8-语法分析小结：文法对比"><a href="#2-8-语法分析小结：文法对比" class="headerlink" title="2.8 语法分析小结：文法对比"></a>2.8 语法分析小结：文法对比</h3><h4 id="2-8-1-SLR和LR（0）"><a href="#2-8-1-SLR和LR（0）" class="headerlink" title="2.8.1 SLR和LR（0）"></a>2.8.1 SLR和LR（0）</h4><p><img src="/2024/12/26/compiler-review/image-20241218205629813.png" alt="3"></p><h4 id="2-8-2-LL（1）和LR（1）"><a href="#2-8-2-LL（1）和LR（1）" class="headerlink" title="2.8.2 LL（1）和LR（1）"></a>2.8.2 LL（1）和LR（1）</h4><p><img src="/2024/12/26/compiler-review/image-20241218205740360.png" alt="4"></p><h4 id="2-8-3-LL（1）-LR（1）-SLR"><a href="#2-8-3-LL（1）-LR（1）-SLR" class="headerlink" title="2.8.3 LL（1） LR（1） SLR"></a>2.8.3 LL（1） LR（1） SLR</h4><p><img src="https://cubicy.icu/compiler-construction-principles/grammar-compare.png" alt="grammar-compare"></p><h3 id="2-9-抽象语法"><a href="#2-9-抽象语法" class="headerlink" title="2.9 抽象语法"></a>2.9 抽象语法</h3><h4 id="2-9-1-属性文法"><a href="#2-9-1-属性文法" class="headerlink" title="2.9.1 属性文法"></a>2.9.1 属性文法</h4><p>属性文法&#x3D;CFG+属性+属性计算规则</p><ul><li>属性:&#x3D; 描述文法符号的语义特征，比如表达式E的值可以记为E.val</li><li>属性计算规则(语义规则):&#x3D; 与产生式相关联、反映文法符号属性之间关系的规则，比如在乘法表达式中左侧的E.val要如何计算<ul><li>仅表明属性间“抽象”关系，不涉及计算次序等具体实现细节</li></ul></li><li>应用：<ul><li>“推导类”：例如很多语言的<strong>编译期求值</strong></li><li>“生成类”：生成AST， 中间代码等</li><li>…</li></ul></li><li>实现：例如在先前章节中Yacc等Parser生成器的<strong>语义动作</strong></li></ul><h4 id="2-9-2-语义动作"><a href="#2-9-2-语义动作" class="headerlink" title="2.9.2 语义动作"></a>2.9.2 语义动作</h4><p>我们可以给产生式绑定一个语义动作，使得按照这个产生式规约时&#x2F;推导时完成特定操作。</p><p>每个token都可能有独属于自己的 <strong>语义值(Semantic Value)</strong> 。每种token的语义值类型可以不同，我们把A的语义值的类型称为“A的关联类型”。</p><p>例如对于产生式 A→B C D</p><ul><li>语义动作返回值必须是<em>A的关联类型</em></li><li>这个值可以通过B C D各自的语义值进行运算得出</li></ul><h4 id="2-9-3-抽象解析树APT"><a href="#2-9-3-抽象解析树APT" class="headerlink" title="2.9.3 抽象解析树APT"></a>2.9.3 抽象解析树APT</h4><p>APT &#x3D; Abstract Parse Tree 是语义动作的一种应用。</p><p>能否<strong>通过描述语义动作直接实现整个编译器</strong>？可以，但是难以维护，且必须保证这些语义值的计算顺序和Parsing顺序完全一致。</p><ul><li>考虑分离语法解析（Parsing）和语义动作：一个可行方案是Parsing得到树，而后遍历以进行语义相关的操作。</li></ul><p>我们可以很容易得到一棵树：叶节点对应输入的token，内部节点对应一个语法规则。这被称为<strong>concrete parse tree</strong>.</p><p><img src="https://cubicy.icu/compiler-construction-principles/concrete-pt.png" alt="concrete-pt"></p><h4 id="2-9-4-抽象语法树AST"><a href="#2-9-4-抽象语法树AST" class="headerlink" title="2.9.4 抽象语法树AST"></a>2.9.4 抽象语法树AST</h4><p>可以提供一个<em>干净的</em>（不包含Parsing的那些繁文缛节）接口用于后续编译流程的实现或优化（编译器后端）。</p><p>生成方式：用<strong>具体语法</strong>（Parser生成器能懂的）为<strong>抽象语法</strong>（我们想要的、更可读的）生成抽象语法树：</p><p><img src="https://cubicy.icu/compiler-construction-principles/AST.png" alt="AST"></p><ul><li><p>为每一个非终结符定义一个类型声明，用于表示其关联类型。</p></li><li><p>产生式统一放进一个union里，每一个产生式就是union里的一个结构体，这个结构体用于储存其子节点：<br><img src="https://cubicy.icu/compiler-construction-principles/AST-def.png" alt="AST definition"></p></li><li><p>为每个产生式定义一个函数，除了计算需要的语义值返回以外，还将申请空间、分配新的树节点并设置好其子节点：</p><p><img src="https://cubicy.icu/compiler-construction-principles/AST-impl.png" alt="AST implementation"></p></li></ul><h2 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3.语义分析"></a>3.语义分析</h2><p>SDD是将文法符号和某些属性相关联，并通过语义规则来描述如何计算属性的值。</p><p>SDT在产生式体中加入语义动作，并在适当的时候执行这些语义动作。</p><h3 id="3-1-语法制导定义SDD"><a href="#3-1-语法制导定义SDD" class="headerlink" title="3.1 语法制导定义SDD"></a>3.1 语法制导定义SDD</h3><p>SDD是上下文无关文法和属性&#x2F;规则的结合。</p><ul><li>属性和文法符号相关联，按照需要来确定各个文法符号需要哪些属性</li><li>规则和产生式相关联</li></ul><p>对于文法符号X和属性a，用X.a表示分析树中的某个标号为X的节点的值。</p><p>一个分析树节点和它的分支对应于一个产生式规则，而对应的语义规则确定了这些节点上的属性的取值。</p><h4 id="3-1-1-分析树和属性值"><a href="#3-1-1-分析树和属性值" class="headerlink" title="3.1.1 分析树和属性值"></a>3.1.1 分析树和属性值</h4><p>假设我们需要知道一个表达式的类型，以及对应代码将它的值存放在何处，我们就需要两个属性：type,place</p><p><img src="/2024/12/26/compiler-review/image-20241228211612914.png" alt="5"></p><h4 id="3-1-2-继承属性和综合属性"><a href="#3-1-2-继承属性和综合属性" class="headerlink" title="3.1.2 继承属性和综合属性"></a>3.1.2 继承属性和综合属性</h4><p>综合属性：在分许树节点N上的非终结符号A的属性值由N对应的产生式所关联的语义规则来定义。通过N的子节点或N本身的属性值来定义。</p><p>继承属性：节点N的属性值由N的父节点所关联的语义规则来定义。依赖于N的父节点、N本身和N的兄弟节点上的属性值。</p><p>不允许N的继承属性通过N的子节点上的属性来定义。但是允许N的综合属性依赖于N本身的继承属性。</p><p>终结符号有综合属性，但是没有继承属性。</p><p><img src="/2024/12/26/compiler-review/image-20241228211957756.png" alt="6"></p><h4 id="3-1-3-S属性的SDD"><a href="#3-1-3-S属性的SDD" class="headerlink" title="3.1.3 S属性的SDD"></a>3.1.3 S属性的SDD</h4><p>只包含综合属性的SDD称为S属性的SDD。每个语义规则都根据产生式体中的属性值来计算头部非终结符号的属性值。</p><p>S属性的SDD可以和LR语法分析器一起实现。</p><p>语义规则不应该有复杂的副作用。</p><ul><li>要求副作用不影响其他属性的求值</li><li>没有副作用的SDD称为属性文法</li></ul><h4 id="3-1-4-L属性的SDD"><a href="#3-1-4-L属性的SDD" class="headerlink" title="3.1.4 L属性的SDD"></a>3.1.4 L属性的SDD</h4><p>每个属性：</p><ul><li>要么是综合属性</li><li>要么是继承属性，且产生式$A\rightarrow X_1X_2\cdots X_n$中计算$X_i.a$的规则只能使用：<ul><li>A的继承属性</li><li>$X_i$左边的文法符号$X_j$的继承属性或综合属性</li><li>$X_i$自身的继承或综合属性，且这些属性之间的依赖关系不形成环</li></ul></li></ul><h4 id="3-1-5-语法分析树上的SDD求值"><a href="#3-1-5-语法分析树上的SDD求值" class="headerlink" title="3.1.5 语法分析树上的SDD求值"></a>3.1.5 语法分析树上的SDD求值</h4><p>注释语法分析树：包含了各个节点的各属性值的语法分析树。</p><p>步骤：</p><ul><li>对于任意的输入串，首先构造出相应的分析树。</li><li>给各个结点（根据其文法符号）加上相应的属性值</li><li>按照语义规则计算这些属性值即可</li></ul><p><img src="/2024/12/26/compiler-review/image-20241228212714134.png" alt="7"></p><h4 id="3-1-6-依赖图"><a href="#3-1-6-依赖图" class="headerlink" title="3.1.6 依赖图"></a>3.1.6 依赖图</h4><p>描述了某棵特定的分析树上各个属性实例之间的信息流（计算顺序）。</p><p><img src="/2024/12/26/compiler-review/image-20241228213225620.png" alt="8"></p><h4 id="3-1-7-属性值的计算顺序"><a href="#3-1-7-属性值的计算顺序" class="headerlink" title="3.1 7 属性值的计算顺序"></a>3.1 7 属性值的计算顺序</h4><p>各个属性的值需要按照依赖图的拓扑顺序计算，如果有环则无法计算。</p><p>S属性的SDD：</p><ul><li>每个属性都是综合属性</li><li>都是根据子构造的属性计算出父构造的属性</li><li>在依赖图中，总是通过子节点的属性值来计算父节点的属性值。可以和自顶向下、自底向上的语法分析过程一起计算</li></ul><p>L属性的SDD：</p><ul><li>依赖图的边：继承属性从左到右，从上到下；综合属性从下到上</li><li>在扫描过程中，计算一个属性值时，和它相关的依赖属性都已经计算完毕</li></ul><p>受控的副作用：</p><ul><li>不会对属性求值产生约束，即可以按照任何拓扑顺序求值，不会影响最终结果</li><li>或者对求值过程添加简答的约束</li></ul><h3 id="3-2-SDT的应用例子"><a href="#3-2-SDT的应用例子" class="headerlink" title="3.2 SDT的应用例子"></a>3.2 SDT的应用例子</h3><h4 id="3-2-1-抽象语法树的构造"><a href="#3-2-1-抽象语法树的构造" class="headerlink" title="3.2.1 抽象语法树的构造"></a>3.2.1 抽象语法树的构造</h4><p><img src="/2024/12/26/compiler-review/image-20241228214334048.png" alt="9"></p><h4 id="3-2-2-自顶向下方式处理的L属性定义"><a href="#3-2-2-自顶向下方式处理的L属性定义" class="headerlink" title="3.2.2 自顶向下方式处理的L属性定义"></a>3.2.2 自顶向下方式处理的L属性定义</h4><p>类型结构：</p><p><img src="/2024/12/26/compiler-review/image-20241228214931075.png" alt="10"></p><p>类型的定义：类型包括两个部分：$T\rightarrow B C$</p><p>B是基本类型，C是分量。如：$int [3][4]$</p><h3 id="3-3-语法制导的翻译方案SDT"><a href="#3-3-语法制导的翻译方案SDT" class="headerlink" title="3.3 语法制导的翻译方案SDT"></a>3.3 语法制导的翻译方案SDT</h3><p>SDT是在产生式体中嵌入程序片段（语义动作）的上下文无关文法。</p><p>SDT的基本实现方法：</p><ul><li>建立语法分析树</li><li>将语义动作看成是虚拟的节点</li><li>从左到右、深度优先地遍历分析树，在访问虚拟节点时执行相应动作</li></ul><p>用SDT实现两类重要的SDD：</p><ul><li>基本文法是LR的，SDD是S属性的</li><li>基本文法是LL的，SDD是L属性的</li></ul><h4 id="3-3-1-后缀翻译方案"><a href="#3-3-1-后缀翻译方案" class="headerlink" title="3.3.1 后缀翻译方案"></a>3.3.1 后缀翻译方案</h4><p>后缀SDT：所有动作都在产生式最右端的SDT。</p><p>文法可以自底向上分析且SDD是S属性的，必然可以构造出后缀SDT。</p><p>构造方法：</p><ul><li>将每个语义规则看作是一个赋值语义动作</li><li>将所有的语义动作放在规则的最右端</li></ul><p><img src="/2024/12/26/compiler-review/image-20241228222737039.png" alt="11"></p><p>后缀SDT的栈实现：</p><p><img src="/2024/12/26/compiler-review/image-20241228222857499.png" alt="12"></p><p>产生式内部带有语义动作的SDT</p><p>消除左递归时SDT的转换</p><h4 id="3-3-2-L属性定义的SDT"><a href="#3-3-2-L属性定义的SDT" class="headerlink" title="3.3.2 L属性定义的SDT"></a>3.3.2 L属性定义的SDT</h4><p>将L属性的SDD转换为SDT：</p><ul><li>将每个语义规则看作是一个赋值语义动作</li><li>将赋值语义动作放到相应产生式的适当位置<ul><li>计算A的继承属性的动作插入到产生式体中对应的A的左边</li><li>计算产生式头的综合属性的动作在产生式的最右边</li></ul></li></ul><p><img src="/2024/12/26/compiler-review/image-20241228223441213.png" alt="13"></p><p><img src="/2024/12/26/compiler-review/image-20241228223511784.png" alt="14"></p><h4 id="3-3-3-递归下降法实现L属性的SDD"><a href="#3-3-3-递归下降法实现L属性的SDD" class="headerlink" title="3.3.3 递归下降法实现L属性的SDD"></a>3.3.3 递归下降法实现L属性的SDD</h4><p><img src="/2024/12/26/compiler-review/image-20241228223656073.png" alt="15"></p><p><img src="/2024/12/26/compiler-review/image-20241228223709170.png" alt="16"></p><p>边扫描边生成属性：当属性值的体积很大时，可以逐步生成属性的各个部分，并增量式添加到最终的属性值中。</p><p><img src="/2024/12/26/compiler-review/image-20241228223743158.png" alt="17"></p><h2 id="4-中间代码生成"><a href="#4-中间代码生成" class="headerlink" title="4.中间代码生成"></a>4.中间代码生成</h2><p>本章主要包括中间代码表示（抽象语法树和三地址代码）以及中间代码生成（表达式、类型检查、控制流）。</p><p>抽象语法树在语法分析已经讲过，静态类型检查和中间代码生成的过程都可以用语法制导的翻译来描述和实现。</p><h3 id="4-1-表达式的DAG"><a href="#4-1-表达式的DAG" class="headerlink" title="4.1 表达式的DAG"></a>4.1 表达式的DAG</h3><p>表达式的DAG能够指出表达式中的公共子表达式。</p><p>构造：可以用和构造AST一样的SDD来构造。</p><h3 id="4-2-三地址代码"><a href="#4-2-三地址代码" class="headerlink" title="4.2 三地址代码"></a>4.2 三地址代码</h3><p>一般写成：x &#x3D; y op z</p><p>运算分量：源程序中的名字作为三地址代码的地址；源程序中出现或生成的常量作为常量；还有编译器生成的临时变量。</p><p>指令集合：运算&#x2F;赋值指令；复制指令；无条件跳转指令；条件转移指令；过程调用&#x2F;返回；带下标的复制指令；地址&#x2F;指针赋值指令。</p><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226141240698.png" alt="18"></p><p>三地址指令的四元式表示方法： op  arg1  arg2  result</p><ul><li>op是运算符的内部编码</li><li>arg1,arg2,result是地址</li><li>如：x &#x3D; y + z $\Rightarrow$ + y z x</li><li>单目运算符不使用arg2</li><li>param运算不使用arg2和result</li><li>条件转移和非条件转移将目标符号放在result字段</li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226141818374.png" alt="19"></p><p>三地址的三元式表示方法： op  arg1  arg2</p><ul><li>x[i] &#x3D; y需要拆分成两个三元式：求x[i]的地址，然后再赋值</li><li>x &#x3D; y op z需要拆分为：<ul><li>（？（Line Number）） op y z</li><li>​                                             &#x3D;  x ?</li></ul></li></ul><h3 id="4-3-类型检查"><a href="#4-3-类型检查" class="headerlink" title="4.3 类型检查"></a>4.3 类型检查</h3><p>确定名字的类型和变量的存储空间布局（相对地址）。</p><p>类型表达式</p><p>结构等价和名等价</p><p>计算类型和宽度的SDT（type,width）</p><p>声明序列的SDT（还有符号表中的位置，offset）</p><p>表达式代码的SDD</p><ul><li>属性code表达代码</li><li>addr表示存放表达式结果的地址</li><li>new temp()可以生成一个临时变量</li><li>gen()生成一个指令</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226144046254.png" alt="20"></p><p>数组元素的寻址：</p><ul><li>数组元素存储在一块连续的存储空间中</li><li>n个数组元素是0,1,…,n-1编号的</li><li>假设每个数组元素宽度是w，那么数组A的第i个元素的开始地址为base+i*w，base是A[0]的相对地址</li><li>有时下标不一定从0开始</li><li>上述地址的计算是按行存放的</li></ul><p>数组引用的翻译</p><ul><li>L.addr指示一个临时变量，计算数组引用的偏移量</li><li>L.array是一个指向数组名字对应的符号表条目的指针，L.array.base为该数组的基地址</li><li>L.type是L生成的子数组的类型，对于任何数组类型t，其宽度由t.width给出,t.elem给出其数组元素的类型</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226145000354.png" alt="21"></p><p>类型系统：给每个组成部分赋予一个类型表达式；通过一组逻辑规则来表示这些类型表达式必须满足的条件</p><p>类型系统的分类：</p><ul><li>类型综合：根据子表示式的类型构造出表达式的类型</li><li>类型推导：根据语言结构的使用方式来确定该结构的类型</li></ul><p>类型转换的SDT</p><p>函数&#x2F;运算符的重载</p><h3 id="4-4-控制流语句"><a href="#4-4-控制流语句" class="headerlink" title="4.4 控制流语句"></a>4.4 控制流语句</h3><p>控制流语句的翻译：if-else语句和while语句</p><ul><li>需要将语句的翻译和布尔表达式的翻译结合在一起</li><li>布尔表达式是被用作语句中改变控制流的条件表达式，用来改变控制流或者计算逻辑值</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226152806234.png" alt="22"></p><p><img src="/2024/12/26/compiler-review/image-20241226152903476.png" alt="23"></p><p>避免冗余的goto语句：上面的goto L3是冗余的，可以替换成</p><ul><li>减少一条goto语句</li><li>引入一特殊符号fall（穿越，fall through），表示不要生成任何跳转指令</li><li>带穿越的语义规则</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226153254811.png" alt="24"></p><p>回填：为布尔表达式和控制流语句生成目标代码的关键问题：某些跳转指令应该跳转到哪里？</p><p>基本思想：例如： if(B) S</p><ul><li>记录B的代码中跳转指令goto  S.next, if … goto  S.next的位置，但是不生成跳转目标</li><li>这些位置被记录到B的综合属性B.falseList中</li><li>当S.next的值已知时（即S的代码生成完毕时），把S.nextList中的所有指令的目标都填上这个值</li></ul><p>生成跳转指令时暂时不指定跳转目标标号，而是使用列表记录这些不完整的指令；等知道正确的目标时再填写目标标号；每个列表中的指令都指向同一个目标。</p><p>布尔表达式的回填翻译：</p><ul><li>trueList：包含跳转指令的列表，这些指令在取值为真时执行</li><li>falseList：包含跳转指令的列表，这些指令在取值为假时执行</li><li>Makelist(i)：创建一个只包含i的列表</li><li>Merge(p1, p2)：将p1和p2指向的列表合并</li><li>Backpatch(p,i)：将i作为目标标号插入到p所指列表中的各指令中</li></ul><p>控制转移语句的回填：语句的综合属性：nextList</p><p>Break、Continue的处理</p><h2 id="5-运行时环境"><a href="#5-运行时环境" class="headerlink" title="5.运行时环境"></a>5.运行时环境</h2><h3 id="5-1-符号表"><a href="#5-1-符号表" class="headerlink" title="5.1 符号表"></a>5.1 符号表</h3><p>绑定：把类型、值等信息绑定到一个标识符上</p><p>环境：一些绑定的集合，体现了程序当前环境下已声明的一些变量&#x2F;函数等</p><p>符号表就是环境的一种实现方式。我们在遍历AST的过程中可以维护一个符号表用于语义分析。符号表中的重要组成部分就是各个局部变量及其作用域。</p><h3 id="5-2-存储分配的方式"><a href="#5-2-存储分配的方式" class="headerlink" title="5.2 存储分配的方式"></a>5.2 存储分配的方式</h3><p><img src="/2024/12/26/compiler-review/image-20241226094009289.png" alt="25"></p><p>目标程序的代码放置在代码区</p><p>静态区、堆区、栈区分别放置不同类型生命期的数据值</p><ul><li><p>静态分配：编译时刻。全局变量</p></li><li><p>动态分配：</p><ul><li><p>栈式存储：和过程的调用&#x2F;返回同步进行分配和回收，值的生命期和过程生命期相同</p></li><li><p>堆存储：数据对象比创建它的过程调用更长寿</p><p>手工进行回收</p><p>垃圾回收机制</p></li></ul></li></ul><h3 id="5-3-栈式分配"><a href="#5-3-栈式分配" class="headerlink" title="5.3 栈式分配"></a>5.3 栈式分配</h3><p>活动树：每个节点对应一个过程活动；根节点对应main的活动；过程p的某次活动对应的节点的所有子节点：此次活动调用的各个过程活动（从左到右，表示调用的先后顺序）</p><p>活动记录：过程调用和返回由控制栈进行管理，每个活跃的活动对应于栈中的一个活动记录；活动记录按照开始时间，从栈底到栈顶排列</p><p>调用代码序列：为活动记录分配空间，填写记录中的信息。返回代码序列恢复机器状态，使调用者继续运行</p><p>活动记录的布局规则</p><p><img src="/2024/12/26/compiler-review/image-20241226102330523.png" alt="26"></p><p>调用者&#x2F;被调用者的活动记录</p><p>栈中的变长数据：变长数组</p><p>非局部数据的访问：无嵌套和有嵌套</p><p>嵌套深度</p><p>访问链：当被调用过程需要其他地方的某个数据时需要使用访问链进行定位</p><p>访问链的维护：访问链的定义+作用域规则</p><p>显示表：提高访问效率。数组d为每个嵌套深度保留一个指针。指针d[i]指向栈中最高的、嵌套深度为i的活动记录</p><h3 id="5-4-堆管理"><a href="#5-4-堆管理" class="headerlink" title="5.4 堆管理"></a>5.4 堆管理</h3><p>堆空间用于存放生命周期不确定、或生存到被明确删除为止的数据对象</p><p>new、malloc</p><p>存储管理器：</p><ul><li>分配：为每个内存请求分配一段连续的、适当大小的堆空间</li><li>回收：把被回收的空间返回空闲空间缓冲池，以满足其他内存需求</li></ul><p>堆空间的碎片问题</p><p>堆空间分配方法：</p><ul><li>Best-fit:最小的满足的空间</li><li>First-fit:第一个满足的空间</li></ul><p>存在的问题：内存泄漏、悬空指针引用、空指针访问&#x2F;数组越界等</p><p>正确的编程模式：</p><ul><li>对象所有者</li><li>引用计数</li><li>基于区域的分配</li></ul><h3 id="5-5-垃圾回收"><a href="#5-5-垃圾回收" class="headerlink" title="5.5 垃圾回收"></a>5.5 垃圾回收</h3><p>垃圾的定义：</p><ul><li>狭义：不能被引用（不可达）的数据</li><li>广义：不需要再被引用的数据</li></ul><p>垃圾回收：自动回收不可达数据的机制</p><p>根集：不需要指针解引用就可以直接访问的数据，根集的成员都是可达的</p><p>改变可达对象集合的操作：</p><ul><li>对象分配</li><li>参数传递&#x2F;返回值</li><li>引用赋值</li><li>过程返回</li></ul><p>垃圾回收方法：捕获对象变得不可达的时刻，回收对象占用的空间；在需要时，标记出所有可达对象、回收其他对象</p><p>引用计数法</p><p>基于跟踪的垃圾回收（可达性分析）：</p><ul><li>标记-清扫式：直接、全面停顿。标记：从根集开始，跟踪并标记出所有可达对象；清扫：遍历整个堆区，释放不可达对象</li><li>标记-清扫式的优化：用一个列表记录所有已经分配的对象，不可达对象等于已分配对象减去可达对象（四种状态对应四个列表,scanned,unscanned,unreached,free）</li><li>压缩并标记：消除存储碎片：对可达对象进行重定位，把可达对象移动到堆区的一段，另一端空闲；空闲空间合并成单一块，分配内存时提高效率</li><li>拷贝回收器：堆空间被分为两个半空间，应用程序在某个半空间内分配存储，当充满这个半空间时，开始垃圾回收；回收时，可达对象被拷贝到另一个半空间；回收完成后，两个半空间角色对调</li></ul><h2 id="6-代码生成"><a href="#6-代码生成" class="headerlink" title="6.代码生成"></a>6.代码生成</h2><p>代码生成器的三个主要任务：指令选择、寄存器分配和指派、指令排序</p><h3 id="6-1-代码生成器设计中的问题"><a href="#6-1-代码生成器设计中的问题" class="headerlink" title="6.1 代码生成器设计中的问题"></a>6.1 代码生成器设计中的问题</h3><ul><li>输入IR的选择：三元式、四元式、字节代码、堆栈机代码、后缀表示、抽象语法树、DAG</li><li>目标程序：RISC、CISC、可重定向代码、汇编语言</li><li>指令选择：IR层次、指令集特性、目标代码质量</li><li>寄存器分配和指派</li><li>求值顺序</li></ul><h3 id="6-2-目标语言"><a href="#6-2-目标语言" class="headerlink" title="6.2 目标语言"></a>6.2 目标语言</h3><p>指令集：</p><ul><li><p>加载：LD dst, addr</p><p>把地址addr中的内容加载到dst所指寄存器</p></li><li><p>保存：ST x, r</p><p>把寄存器r中的内容保存到x中</p></li><li><p>计算：OP dst,  src1,  src2</p><p>把src1和src2中的值运算后结果存放到dst中</p></li><li><p>无条件跳转：BR L</p><p>控制流转向标号L的指令</p></li><li><p>条件跳转：Bcond r,  L</p><p>对r中的值进行测试，如果为真则转向L</p></li></ul><p>寻址模式：</p><ul><li>变量x:指向分配x的内存位置</li><li>a(r):地址是a的左值加上r中的值</li><li>constant(r):寄存器中内容加上前面的常数即其地址</li><li>*r：寄存器r的内容为其地址</li><li>*constant(r):r中内容加上常量所指地址中存放的值为其地址</li><li>常量#constant</li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226201656884.png" alt="27"></p><h3 id="6-3-目标代码中的地址"><a href="#6-3-目标代码中的地址" class="headerlink" title="6.3 目标代码中的地址"></a>6.3 目标代码中的地址</h3><p>如何将IR中的名字转换成为目标代码中的地址？</p><ul><li>不同的区域中的名字采用不同的寻址方式</li></ul><p>如何为过程调用和返回生成代码？</p><ul><li>静态分配和栈式分配</li></ul><p>活动记录的静态分配：每个过程静态地分配一个数据区域，过程调用时在活动纪记录中存放返回地址；过程调用结束后控制权返回。</p><p>活动记录的栈式分配：运行时刻才能知道一个过程的活动记录的位置。将活动记录的位置存放在寄存器中，用偏移量来访问。</p><p><img src="/2024/12/26/compiler-review/image-20241226203153869.png" alt="28"></p><h3 id="6-4-基本块和流图"><a href="#6-4-基本块和流图" class="headerlink" title="6.4 基本块和流图"></a>6.4 基本块和流图</h3><p>中间代码的流图表示法：</p><ul><li>将中间代码划分为基本块</li><li>控制流只能从第一个指令进入</li><li>除基本块的最后一个指令外，控制流不会跳转&#x2F;停机</li><li>节点：基本块</li><li>边：指明了基本块的执行顺序</li></ul><p>作用：流图可以作为优化的基础</p><ul><li>指明了基本块之间的控制流</li><li>可以根据流图了解到一个值是否会被使用等信息</li></ul><p>划分基本块的算法：</p><ul><li>输入：三地址指令序列</li><li>输出：基本块列表</li><li>步骤：<ul><li>确定基本块的首指令：第一个三地址指令；任意一个条件或无条件转移指令的目标指令；紧跟在一个条件&#x2F;无条件转移指令之后的指令</li><li>确定基本块：每个首指令对应一个基本块；从首指令到下一个首指令</li></ul></li></ul><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226203912543.png" alt="29"></p><p>变量值的使用：活跃变量</p><p>流图的构造：</p><p><img src="/2024/12/26/compiler-review/image-20241226204305097.png" alt="30"></p><p>循环：程序的大部分运行时间花费在循环上</p><h3 id="6-5-基本块的优化"><a href="#6-5-基本块的优化" class="headerlink" title="6.5 基本块的优化"></a>6.5 基本块的优化</h3><p>基本块可以用DAG表示：</p><ul><li>每个变量有对应的DAG的结点，代表初始值</li><li>每个语句s有一个相关的节点N，代表计算得到的值<ul><li>N的子节点对应于（其运算分量当前值的）其他语句</li><li>节点N的标号是s的运算符</li><li>N和一组变量关联，表示s是在此基本块内最晚对它们定值的语句</li></ul></li></ul><p>从DAG，可以知道各个变量最后的值和初始值的关系</p><p>DAG的构造：</p><p><img src="/2024/12/26/compiler-review/image-20241226204948204.png" alt="31"></p><p>消除局部公共子表达式：</p><ul><li>在建立某个节点M之前，检查是否存在一个节点N，它和M具有相同的运算符和子节点（顺序也相同）</li><li>如果存在，则不需要生成新的节点，用N代表M</li></ul><p>消除死代码：在DAG上消除没有附加活跃变量的根节点</p><p>应用代数恒等式的优化</p><p>数组引用的DAG表示：</p><p><img src="/2024/12/26/compiler-review/image-20241226205748401.png" alt="32"></p><p><img src="/2024/12/26/compiler-review/image-20241226205906764.png" alt="33"></p><p>指针赋值&#x2F;过程调用</p><p>重组基本块：</p><ul><li>每个节点构造一个三地址语句，计算对应的值</li><li>结果应该尽量赋给一个活跃的变量</li><li>如果节点有多个关联的变量，则需要用复制语句进行赋值</li></ul><p><img src="/2024/12/26/compiler-review/image-20241226210336656.png" alt="34"></p><p><img src="/2024/12/26/compiler-review/image-20241226210443928.png" alt="35"></p><p>重组时需要注意求值的顺序</p><ul><li>指令的顺序必须遵守DAG中结点的顺序</li><li>对数组的赋值必须跟在所有原来在它之前的赋值&#x2F;求值操作之后</li><li>对数组元素的求值必须跟在所有原来在它之前的赋值指令之后</li><li>对变量的使用必须跟在所有原来在它之前的过程调用和指针间接赋值之后</li><li>任何过程调用或者指针间接赋值必须跟在原来在它之前的变量求值之后</li></ul><h3 id="6-6-基本块的代码生成器"><a href="#6-6-基本块的代码生成器" class="headerlink" title="6.6 基本块的代码生成器"></a>6.6 基本块的代码生成器</h3><p>主要目标：尽量减少加载和保存指令，即最大限度利用寄存器</p><p>寄存器的使用方法：</p><ul><li>执行运算时，运算分量必须放在寄存器中</li><li>用于临时变量</li><li>存放全局的值</li><li>进行运行时刻管理（比如：栈顶指针）</li></ul><p>基本思路：依次考虑各三地址指令，尽可能把值保留在寄存器中，以减少寄存器&#x2F;内存之间的数据交换</p><p>基本数据结构：记录各个值对应的位置</p><ul><li>寄存器描述符：跟踪各个寄存器都存放了哪些变量的当前值</li><li>地址描述符：某个变量的当前值存放在哪个或哪些位置（包括内存位置和寄存器）上</li></ul><p>代码生成算法：</p><ul><li>遍历三地址指令</li><li>使用getReg（）函数选择寄存器</li><li>生成指令</li></ul><p>getReg（I）函数：</p><ul><li>根据寄存器描述符和地址描述符、数据流信息，为三地址指令I选择最佳的寄存器</li><li>得到的机器指令的质量依赖于getReg函数选取的寄存器的算法</li></ul><p>具体操作步骤：</p><p><img src="/2024/12/26/compiler-review/image-20241226211659625.png" alt="36"></p><p><img src="/2024/12/26/compiler-review/image-20241226211706659.png" alt="37"></p><p><img src="/2024/12/26/compiler-review/image-20241226211714351.png" alt="38"></p><p>实例：</p><p><img src="/2024/12/26/compiler-review/image-20241226211739967.png" alt="39"></p><p>getReg函数详解：</p><p><img src="/2024/12/26/compiler-review/image-20241227203429561.png" alt="40"></p><p><img src="/2024/12/26/compiler-review/image-20241227203438501.png" alt="41"></p><p><img src="/2024/12/26/compiler-review/image-20241227203446103.png" alt="42"></p><p><img src="/2024/12/26/compiler-review/image-20241227203503021.png" alt="43"></p><p>窥孔优化：使用一个滑动窗口来检查目标指令，在窥孔内实现优化</p><ul><li>冗余指令消除</li><li>控制流优化</li><li>代数简化</li><li>机器特有指令的使用</li></ul><p>寄存器分配和指派：</p><ul><li><p>简单的基本方法：把特定类型的值分配给特定的寄存器</p><p>缺点：寄存器的使用效率较低</p></li><li><p>全局寄存器分配：在循环中频繁使用的值存放在固定寄存器；分配固定多个寄存器来存放内部循环中最活跃的值。可以通过使用计数的方法来估算把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器</p></li></ul><p>使用计数</p><p>重写</p><h2 id="7-代码优化"><a href="#7-代码优化" class="headerlink" title="7.代码优化"></a>7.代码优化</h2><p>本章主要包括优化的来源、数据流分析和机器无关的优化</p><h3 id="7-1-优化的来源"><a href="#7-1-优化的来源" class="headerlink" title="7.1 优化的来源"></a>7.1 优化的来源</h3><p>代码优化是在目标代码中消除不必要的指令，把一个指令序列替换为一个完成相同功能的更快的指令序列。</p><p>编译器只能通过一些相对低层的语义等价转换来优化代码。</p><p>冗余运算的原因：源程序中的冗余；高级程序设计语言编程的副产品。</p><p>下面是语义不变的优化方法：</p><h3 id="7-2-全局公共子表达式"><a href="#7-2-全局公共子表达式" class="headerlink" title="7.2 全局公共子表达式"></a>7.2 全局公共子表达式</h3><p>如果E在某次出现之前必然已经被计算过，且E的分量在该次计算之后一直没有被改变，那么E的本次出现就是一个公共子表达式。</p><p>如果上一次E的值赋给了x，且x的值至今没有被修改过，那么我们就可以使用x，而不需要计算E。</p><p><img src="/2024/12/26/compiler-review/image-20241228092910723.png" alt="44"></p><h3 id="7-3-复制传播"><a href="#7-3-复制传播" class="headerlink" title="7.3 复制传播"></a>7.3 复制传播</h3><p>形如u&#x3D;v的复制语句使得语句后面的程序点上，u的值等于v的值。如果在某个位置上u一定等于v，那么可以把u替换为v。有时可以彻底消除对u的使用，从而消除对u的赋值语句。</p><p><img src="/2024/12/26/compiler-review/image-20241228093124550.png" alt="45"></p><h3 id="7-4-死代码消除"><a href="#7-4-死代码消除" class="headerlink" title="7.4 死代码消除"></a>7.4 死代码消除</h3><p>如果一个变量在某个程序点上的值可能会在之后被使用，那么这个变量在这个点上活跃；否则这个变量就是死的，此时对这个变量的赋值就是没有用的死代码。</p><p>死代码多半是因为前面的优化而形成的。</p><p><img src="/2024/12/26/compiler-review/image-20241228093333158.png" alt="46"></p><h3 id="7-5-代码移动"><a href="#7-5-代码移动" class="headerlink" title="7.5 代码移动"></a>7.5 代码移动</h3><p>循环不变表达式：循环的同一次运行的不同迭代中，表达式的值不变。</p><p>把循环不变表达式移动到循环入口之前计算可以提高效率。</p><p>循环入口：进入循环的跳转都以这个入口为目标。</p><p><img src="/2024/12/26/compiler-review/image-20241228093525542.png" alt="47"></p><h3 id="7-6-归纳变量和强度消减"><a href="#7-6-归纳变量和强度消减" class="headerlink" title="7.6 归纳变量和强度消减"></a>7.6 归纳变量和强度消减</h3><p>每次对x的赋值都使得x的值增加c，那么x就是归纳变量。把对x的赋值改成增量操作，可消减计算强度，提高效率。如果两个归纳变量步调一致，还可以删除其中的某一个。</p><p><img src="/2024/12/26/compiler-review/image-20241228093835971.png" alt="48"></p><h3 id="7-7-数据流分析"><a href="#7-7-数据流分析" class="headerlink" title="7.7 数据流分析"></a>7.7 数据流分析</h3><p>数据流分析是用于获取数据沿着程序执行路径流动的信息的相关技术，是优化的基础。</p><h4 id="7-7-1-数据流分析理论与框架"><a href="#7-7-1-数据流分析理论与框架" class="headerlink" title="7.7.1 数据流分析理论与框架"></a>7.7.1 数据流分析理论与框架</h4><p>在基本块中，数据的流动是线性的；全局的情况下，因存在循环、函数调用等情况，数据的流动变得复杂。</p><p>抽象解释框架：单调性、有界性</p><ul><li>程序状态是有限的</li><li>状态的变化是单调的</li></ul><p>理论：集合理论、偏序关系与半格</p><h4 id="7-7-2-数据流抽象"><a href="#7-7-2-数据流抽象" class="headerlink" title="7.7.2 数据流抽象"></a>7.7.2 数据流抽象</h4><p>程序点：三地址语句之前或之后的位置</p><ul><li>基本块内部：一个语句之后的程序点等于下一个语句之前的程序点</li><li>如果流图中有B1到B2的边，那么B2的第一个语句之前的点可能紧跟在B1的最后语句之后的点后面执行</li></ul><p>程序状态：在某个运行时刻，当指令指针指向这个程序点时，各个变量和动态内存中存放的值。</p><p>指令指针可能多次指向同一个程序点，因此一个程序点可能对应多个程序状态。</p><p>数据流分析把可能出现在某个程序点上的程序状态集合总结为一些特性。</p><h4 id="7-7-3-数据流分析模式"><a href="#7-7-3-数据流分析模式" class="headerlink" title="7.7.3 数据流分析模式"></a>7.7.3 数据流分析模式</h4><p>数据流值：某个程序点所有可能的状态集合的抽象表示。</p><p>域：所有可能的数据流值的集合。</p><p>数据流分析：对一组约束求解。</p><ul><li>IN[s]和OUT[s]</li></ul><p>基于语句语义的约束（传递函数）：</p><ul><li>IN[s] &#x3D; f_s(OUT[s])</li><li>OUT[s] &#x3D; f_s(IN[s])</li></ul><p>基于控制流的约束：</p><ul><li>IN[s_{i+1}] &#x3D; OUT[s_i]</li></ul><p>基本块上的数据流模式：</p><ul><li>基本块的控制流从头到尾不会中断，没有分支</li><li>基本块的效果就是各个语句的效果的复合</li><li>可以预先处理基本块内部的数据流关系，给出基本块对应的传递函数</li></ul><p>基本块之间的控制流约束：</p><ul><li>前向数据流问题：<ul><li>B的传递函数根据IN[B]计算得到OUT[B]</li><li>IN[B]和B的各前驱基本块的OUT值之间具有约束关系</li></ul></li><li>逆向数据流问题：<ul><li>B的传递函数根据OUT[B]计算得到IN[B]</li><li>OUT[B]和B的各后驱基本块的IN值之间具有约束关系</li></ul></li></ul><p><img src="/2024/12/26/compiler-review/image-20241228100214344.png" alt="49"></p><p>数据流方程通常没有唯一解。</p><h4 id="7-7-4-数据流分析框架"><a href="#7-7-4-数据流分析框架" class="headerlink" title="7.7.4 数据流分析框架"></a>7.7.4 数据流分析框架</h4><p>一个数据流分析框架（D，V，R，F）由下列元素组成：</p><ul><li>一个数据流方向D，包括前向和后向</li><li>一个半格（V，R）:V是程序状态的集合，R是集合的交运算或并运算，用于表示在基本块入口处对不同的前驱（或在出口处对不同的后驱）的程序状态的合并</li><li>一个从V到V的传递函数族F，用于刻画基本块内部每条语句对程序状态造成的变化</li></ul><p>May分析：用于分析在某一程序点上所有可能存在的程序状态。</p><p>Must分析：用于分析在某一程序点上一定存在的程序状态。</p><h4 id="7-7-5-到达定值分析"><a href="#7-7-5-到达定值分析" class="headerlink" title="7.7.5 到达定值分析"></a>7.7.5 到达定值分析</h4><p>如果存在一条从定值d后面的程序点到达某个点p的路径，且这条路径上d没有被杀死，那么定值d到达p。</p><p>杀死：路径上对x的其他定值杀死了之前对x的定值。</p><p>直观含义（define-use关系）：如果d到达p，那么在p点使用的值就可能是由d定值的。</p><p><img src="/2024/12/26/compiler-review/image-20241228101552867.png" alt="50"></p><p>应用：循环不变代码外提、常量传播等等。</p><p>语句&#x2F;基本块的传递方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228102238234.png" alt="51"></p><p><img src="/2024/12/26/compiler-review/image-20241228102245274.png" alt="52"></p><p>gen和kill的例子：</p><p><img src="/2024/12/26/compiler-review/image-20241228102315516.png" alt="53"></p><p>到达定值的控制流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228102924515.png" alt="54"></p><p><img src="/2024/12/26/compiler-review/image-20241228102941794.png" alt="55"></p><h4 id="7-7-6-活跃变量分析"><a href="#7-7-6-活跃变量分析" class="headerlink" title="7.7.6 活跃变量分析"></a>7.7.6 活跃变量分析</h4><p>分析x在p上的值是否会在某条从p出发的路径中使用。</p><p>一个变量x在p上活跃，当且仅当存在一条从p点开始的路径，该路径的末端使用了x，且路径上没有对x进行覆盖。</p><p>用途：寄存器分配、死代码删除等等。</p><p>数据流值：活跃变量的集合。</p><p>基本块内的数据流方程：基本块的传递函数仍然是生成——杀死形式，但是从OUT值计算出IN值。</p><ul><li>use_B：可能在B中先于定值被使用（gen）</li><li>def_B：在B中一定先于定值被使用（kill）</li></ul><p>示例：</p><p><img src="/2024/12/26/compiler-review/image-20241228104410581.png" alt="56"></p><p><img src="/2024/12/26/compiler-review/image-20241228104452689.png" alt="57"></p><p>活跃变量数据流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228104521883.png" alt="58"></p><h4 id="7-7-7-可用表达式分析"><a href="#7-7-7-可用表达式分析" class="headerlink" title="7.7.7 可用表达式分析"></a>7.7.7 可用表达式分析</h4><p>x+y在p点可用的条件：从流图入口节点到达p的每条路径都对x+y求值，且在最后一次求值之后再没有对x或者y赋值。</p><p>用途：寻找全局公共子表达式。</p><p>生成——杀死：</p><ul><li>杀死：基本块对x或y赋值，且没有重新计算x+y，那么它就杀死了x+y</li><li>生成：基本块求值x+y，且之后没有对x或y赋值，那么它就生成了x+y</li></ul><p>计算基本块生成的表达式：</p><p><img src="/2024/12/26/compiler-review/image-20241228105125226.png" alt="59"></p><p>示例：</p><p><img src="/2024/12/26/compiler-review/image-20241228105302443.png" alt="60"></p><p>可用表达式的数据流方程：</p><p><img src="/2024/12/26/compiler-review/image-20241228105329046.png" alt="61"></p><p>三种数据流方程的总结：</p><p><img src="/2024/12/26/compiler-review/image-20241228105347224.png" alt="62"></p><h3 id="7-8-机器无关的优化"><a href="#7-8-机器无关的优化" class="headerlink" title="7.8 机器无关的优化"></a>7.8 机器无关的优化</h3><h4 id="7-8-1-局部优化"><a href="#7-8-1-局部优化" class="headerlink" title="7.8.1 局部优化"></a>7.8.1 局部优化</h4><p>局部优化包括：DAG、公共子表达式消除、无用代码消除、常量折叠、代数恒等式替换等。</p><h4 id="7-8-2-全局优化"><a href="#7-8-2-全局优化" class="headerlink" title="7.8.2 全局优化"></a>7.8.2 全局优化</h4><p>全局优化管道：常量传播——公共子表达式消除——复制传播——常量折叠——控制流优化——无用代码消除——循环不变代码外提——归纳变量强度消减——控制流优化。</p><p>常量传播框架中的变量状态分为三种：</p><ul><li>所有符合该变量类型的常量值</li><li>NAC（Not A Constant）表示当前变量不是一个常量值，这代表该变量在到达程序点p的不同路径上的值不同，或是被赋予了一个输入变量的值</li><li>UNDEF，表示未定义的值。在到达程序点p的不同路径上存在至少一条路径未对变量的值进行定义</li></ul><h4 id="7-8-3-循环优化"><a href="#7-8-3-循环优化" class="headerlink" title="7.8.3 循环优化"></a>7.8.3 循环优化</h4><p>支配节点（必经节点）：</p><p><img src="/2024/12/26/compiler-review/image-20241228130435331.png" alt="63"></p><p>支配节点树：可以表示支配关系。根节点是入口节点，每个节点d支配且只支配树中的后代节点。</p><p>直接支配节点：从入口节点到达n的任何路径中，它是路径中最后一个支配n的节点。</p><p><img src="/2024/12/26/compiler-review/image-20241228130732424.png" alt="64"></p><p>深度优先排序</p><p>回边和可归约性</p><p>自然循环</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Software Testing Review</title>
      <link href="/2024/12/25/software-testing-review/"/>
      <url>/2024/12/25/software-testing-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是关于2024Fall聂长海老师的自动化测试的复习笔记，以聂老师的书《软件测试的概念和方法》为参考，主要记录了考试中可能出现的知识点，方便复习。<br>聂老师的组：<a href="https://gist.nju.edu.cn/">GIST</a></p><h2 id="1-简答题（20分，每题1分）"><a href="#1-简答题（20分，每题1分）" class="headerlink" title="1 简答题（20分，每题1分）"></a>1 简答题（20分，每题1分）</h2><h3 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1 什么是软件测试？"></a>1 什么是软件测试？</h3><p>软件测试就是在软件投入运行前，对软件需求分析、设计规格说明和编码实现的最终审查，它是软件质量保证的关键步骤。软件测试有八种定义。</p><h3 id="2-软件测试具有哪些特性？"><a href="#2-软件测试具有哪些特性？" class="headerlink" title="2 软件测试具有哪些特性？"></a>2 软件测试具有哪些特性？</h3><ul><li>存在性或永不过时性：任何软件都有缺陷，软件测试将因为软件的存在而存在</li><li>不完全性或抽样性：输入空间很庞大需要进行抽样</li><li>证错不证对性：只能证明软件的不正确性</li><li>检错保质性</li><li>综合性或多方求证性</li><li>测试效果评判准则</li></ul><h3 id="3-软件测试的对象包括哪些方面？"><a href="#3-软件测试的对象包括哪些方面？" class="headerlink" title="3 软件测试的对象包括哪些方面？"></a>3 软件测试的对象包括哪些方面？</h3><p>软件开发过程中的需求规格说明、概要设计规格说明、详细规格说明以及源程序都是。</p><h3 id="4-软件测试的目标是什么？"><a href="#4-软件测试的目标是什么？" class="headerlink" title="4 软件测试的目标是什么？"></a>4 软件测试的目标是什么？</h3><p>发现错误；检查系统是否满足需求。</p><h3 id="5写出你认为软件测试应该遵循的最重要的几条原则"><a href="#5写出你认为软件测试应该遵循的最重要的几条原则" class="headerlink" title="5写出你认为软件测试应该遵循的最重要的几条原则."></a>5写出你认为软件测试应该遵循的最重要的几条原则.</h3><p><img src="/2024/12/25/software-testing-review/image-20240922101504601.png" alt="软件测试原则"></p><h3 id="6-软件测试方法可以分为哪几类方法？"><a href="#6-软件测试方法可以分为哪几类方法？" class="headerlink" title="6 软件测试方法可以分为哪几类方法？"></a>6 软件测试方法可以分为哪几类方法？</h3><p>软件测试可以基于不同的角度和性质出发设计测试方法。如基于代码、基于用户、基于故障、基于输入、基于属性、基于性质、基于开发过程、基于规格、基于模型等等。具体的可以包括静态测试、动态测试；黑盒测试、白盒测试；针对不同开发方式和应用场景的软件测试；针对不同特性和方面的软件测试；针对不同开发阶段的以及一些特殊的测试方法。</p><h3 id="7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"><a href="#7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？" class="headerlink" title="7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"></a>7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？</h3><p><img src="/2024/12/25/software-testing-review/image-20241223094727805.png" alt="软件测试的信息流模型"><br>最关键的因素：与测试相关的软件配置、测试配置、测试工具。</p><h3 id="8-软件开发有哪些模型，软件测试分别处于什么位置？"><a href="#8-软件开发有哪些模型，软件测试分别处于什么位置？" class="headerlink" title="8 软件开发有哪些模型，软件测试分别处于什么位置？"></a>8 软件开发有哪些模型，软件测试分别处于什么位置？</h3><ul><li>大棒开发法：整个过程中</li><li>边写边改法：在测试环节中</li><li>瀑布模型：处于开发阶段的最后一步</li><li>快速原型开发模型：在原型开发、原型评价和系统实现当中</li><li>螺旋开发模型：处于每个开发阶段的测试阶段中</li><li>敏捷方法之XP：测试过程中</li></ul><h3 id="9-软件测试过程有哪些模型？这些模型各有什么特点？"><a href="#9-软件测试过程有哪些模型？这些模型各有什么特点？" class="headerlink" title="9 软件测试过程有哪些模型？这些模型各有什么特点？"></a>9 软件测试过程有哪些模型？这些模型各有什么特点？</h3><ul><li>V模型：左侧基于开发模型，右侧是对应的测试过程</li><li>W模型：开发和测试各是一个V</li><li>X模型：左半部分是针对单独程序片段进行的相互分离的编码和测试，经过多次交接，集成为可以执行的程序</li></ul><h3 id="10-作为一种职业，你认为软件测试员应该具备哪些专业基础？"><a href="#10-作为一种职业，你认为软件测试员应该具备哪些专业基础？" class="headerlink" title="10 作为一种职业，你认为软件测试员应该具备哪些专业基础？"></a>10 作为一种职业，你认为软件测试员应该具备哪些专业基础？</h3><p>探索精神、故障排除能手、不懈努力、创造性、追求完美、判断准确、老练稳重、说服力。</p><h3 id="11-在软件测试领域，最根本（关键）的问题在哪里？"><a href="#11-在软件测试领域，最根本（关键）的问题在哪里？" class="headerlink" title="11 在软件测试领域，最根本（关键）的问题在哪里？"></a>11 在软件测试领域，最根本（关键）的问题在哪里？</h3><p>软件测试的样例太多了，需要对样例进行涵盖和选择。</p><h3 id="11-软件测试工具大致可以分为几种？"><a href="#11-软件测试工具大致可以分为几种？" class="headerlink" title="11 软件测试工具大致可以分为几种？"></a>11 软件测试工具大致可以分为几种？</h3><p>测试管理工具、自动化功能测试工具、性能测试工具、单元测试工具、白盒测试工具、测试用例设计工具、根据是否收费还可以分为商业测试工具、开源和免费。</p><h3 id="12-软件测试管理具有什么作用？"><a href="#12-软件测试管理具有什么作用？" class="headerlink" title="12 软件测试管理具有什么作用？"></a>12 软件测试管理具有什么作用？</h3><p>对测试过程、测试人员及组织、测试文档、测试环境、测试质量都需要进行全面管理才能有效测试，确保软件质量。软件测试管理贯穿整个测试的全过程。</p><h3 id="13-简述软件测试发展的六个发展阶段。"><a href="#13-简述软件测试发展的六个发展阶段。" class="headerlink" title="13 简述软件测试发展的六个发展阶段。"></a>13 简述软件测试发展的六个发展阶段。</h3><ul><li>Debugging oriented (1950年左右)</li><li>Demonstration oriented (1960年左右)</li><li>Destruction oriented (1970年左右)</li><li>Evaluation oriented (1980年左右)</li><li>Prevention oriented (1990年以后)</li><li>Professional、education and research （2000年以后）</li></ul><h3 id="14-缺陷管理具体包括哪些功能？"><a href="#14-缺陷管理具体包括哪些功能？" class="headerlink" title="14 缺陷管理具体包括哪些功能？"></a>14 缺陷管理具体包括哪些功能？</h3><p>缺陷预防、缺陷发现、缺陷记录和报告、缺陷分类和跟踪、缺陷处理以及缺陷预测。</p><h3 id="15-什么是软件？"><a href="#15-什么是软件？" class="headerlink" title="15 什么是软件？"></a>15 什么是软件？</h3><p>软件是计算机程序、规程以及可能的相关文档和运行计算机系统需要的数据。软件&#x3D;程序+文档&#x3D;知识+使用&#x3D;服务+需求。</p><h3 id="16-什么是软件质量？"><a href="#16-什么是软件质量？" class="headerlink" title="16 什么是软件质量？"></a>16 什么是软件质量？</h3><p>软件产品满足规定和隐含需求能力有关的所有特征和所有特性的总和。包括产品质量、过程质量、静态质量与动态质量。</p><h3 id="17-什么是软件缺陷？"><a href="#17-什么是软件缺陷？" class="headerlink" title="17 什么是软件缺陷？"></a>17 什么是软件缺陷？</h3><p>将所有的软件问题统称为缺陷。包括：软件未达到产品说明书中已经标明的功能；软件出现了产品说明书中指明不会出现的错误等。</p><h3 id="18-软件测试发展的未来趋势是什么？"><a href="#18-软件测试发展的未来趋势是什么？" class="headerlink" title="18 软件测试发展的未来趋势是什么？"></a>18 软件测试发展的未来趋势是什么？</h3><p>物理运行——知识——软件优化。软件无处不在，软件定义一切，软件使能一切，智能化软件时代即将到来。</p><h3 id="19-软件测试有哪些停止准则？"><a href="#19-软件测试有哪些停止准则？" class="headerlink" title="19 软件测试有哪些停止准则？"></a>19 软件测试有哪些停止准则？</h3><ul><li>测试超过了预定时间</li><li>执行了所有的测试用例，但没有发现故障</li><li>使用特定的测试用例设计方案作为判断测试停止的准则</li><li>正面指出停止测试的具体要求</li><li>根据单位时间内查出故障的数量决定</li></ul><h3 id="20-解释软件的故障模型PIE。"><a href="#20-解释软件的故障模型PIE。" class="headerlink" title="20 解释软件的故障模型PIE。"></a>20 解释软件的故障模型PIE。</h3><ul><li>Execution执行：错误代码必须被执行到</li><li>Infection感染：触发了错误的中间状态</li><li>Propagation传播：错误的中间状态必须可以传播到最后的输出得以观测</li></ul><h2 id="2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"><a href="#2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）" class="headerlink" title="2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"></a>2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）</h2><table><thead><tr><th></th><th>1 黑盒测试</th><th>2 白盒测试</th></tr></thead><tbody><tr><td>3 静态测试</td><td>5</td><td>6，7，8，9</td></tr><tr><td>4 动态测试</td><td>19，20，21，22，23，24</td><td>10，11，12，13，14，15，16，17，18</td></tr></tbody></table><h3 id="1-黑盒测试"><a href="#1-黑盒测试" class="headerlink" title="1 黑盒测试"></a>1 黑盒测试</h3><p>把待测试程序或软件系统看成一个无法打开的黑匣子，完全不知道程序的内部结构和处理过程的前提下，在程序接口进行测试。</p><h3 id="2-白盒测试"><a href="#2-白盒测试" class="headerlink" title="2 白盒测试"></a>2 白盒测试</h3><p>把测试对象看成一个打开的盒子，允许软件程序员利用程序内部的逻辑结构及有关信息。</p><h3 id="3-静态测试"><a href="#3-静态测试" class="headerlink" title="3 静态测试"></a>3 静态测试</h3><p>在不执行代码的情况下进行的测试。</p><h3 id="4-动态测试"><a href="#4-动态测试" class="headerlink" title="4 动态测试"></a>4 动态测试</h3><p>在执行程序代码的情况下进行的测试。</p><h3 id="5-文档审查"><a href="#5-文档审查" class="headerlink" title="5 文档审查"></a>5 文档审查</h3><p>对测试的相关设计文档进行审查。</p><h3 id="6-同行评审"><a href="#6-同行评审" class="headerlink" title="6 同行评审"></a>6 同行评审</h3><p>软件设计人员和编码人员加上一两个其他程序员间互相审查代码。</p><h3 id="7桌面评审"><a href="#7桌面评审" class="headerlink" title="7桌面评审"></a>7桌面评审</h3><p>单人进行的代码检查或代码走查，由一个人阅读程序。</p><h3 id="8-代码走查"><a href="#8-代码走查" class="headerlink" title="8 代码走查"></a>8 代码走查</h3><p>程序员和测试人员组成的5人小组审查程序。</p><h3 id="9-代码审查"><a href="#9-代码审查" class="headerlink" title="9 代码审查"></a>9 代码审查</h3><p>编写受评审代码的程序员不能参与，每个评审人员从不同角度对代码进行评审。</p><h3 id="10语句覆盖"><a href="#10语句覆盖" class="headerlink" title="10语句覆盖"></a>10语句覆盖</h3><p>执行每条可执行语句，覆盖对象是每条可执行语句。</p><h3 id="11判定覆盖"><a href="#11判定覆盖" class="headerlink" title="11判定覆盖"></a>11判定覆盖</h3><p>从源代码中找出所有分支或决策点，执行所有分支或决策点的两种取值。</p><h3 id="12条件覆盖"><a href="#12条件覆盖" class="headerlink" title="12条件覆盖"></a>12条件覆盖</h3><p>让判定语句中的每个条件变量的真假值都能取到。</p><h3 id="13判定-条件覆盖"><a href="#13判定-条件覆盖" class="headerlink" title="13判定&#x2F;条件覆盖"></a>13判定&#x2F;条件覆盖</h3><p>不仅让判定语句中的每个条件变量的真假值都能取到，而且让判定语句取到真假值。</p><h3 id="14条件组合覆盖"><a href="#14条件组合覆盖" class="headerlink" title="14条件组合覆盖"></a>14条件组合覆盖</h3><p>设计测试用例让判定语句中的每个条件变量的真假值组合情况都执行。</p><h3 id="15-修改决策条件覆盖"><a href="#15-修改决策条件覆盖" class="headerlink" title="15 修改决策条件覆盖"></a>15 修改决策条件覆盖</h3><p>设计测试用例，让每个条件变量独立改变判定语句的真假值。保证每个变量真假值出现一次；整个判定式出现真假值；让每个变量独立影响判定式的真假值。</p><h3 id="16路径覆盖"><a href="#16路径覆盖" class="headerlink" title="16路径覆盖"></a>16路径覆盖</h3><p>设计足够的测试用例，覆盖程序中所有可能的路径。</p><h3 id="17-LCSAJ-覆盖"><a href="#17-LCSAJ-覆盖" class="headerlink" title="17 LCSAJ 覆盖"></a>17 LCSAJ 覆盖</h3><p>关注程序控制流的跳转情况。</p><h3 id="18数据流测试（定义-引用对覆盖）"><a href="#18数据流测试（定义-引用对覆盖）" class="headerlink" title="18数据流测试（定义&#x2F;引用对覆盖）"></a>18数据流测试（定义&#x2F;引用对覆盖）</h3><p>利用程序的数据流&#x2F;控制流图进行测试。每个测试用例包括输入、相关变量定义和使用对的位置、执行的控制流子路径、预期输出。</p><h3 id="19-等价类划分"><a href="#19-等价类划分" class="headerlink" title="19 等价类划分"></a>19 等价类划分</h3><p>把所有可能输入的数据划分成若干等价类。</p><h3 id="20-边界值分析"><a href="#20-边界值分析" class="headerlink" title="20 边界值分析"></a>20 边界值分析</h3><p>通常输入等价类与输出等价类的边界。应该选取正好等于、刚刚大于，或刚刚小于边界的值作为测试数据，而不是选取等价类的典型值或任意值作为测试数据。</p><h3 id="21-因果图与决策表"><a href="#21-因果图与决策表" class="headerlink" title="21 因果图与决策表"></a>21 因果图与决策表</h3><p>因果图生成的就是决策表。适用于检查程序输入条件的各种组合情况。</p><h3 id="22-错误猜测"><a href="#22-错误猜测" class="headerlink" title="22 错误猜测"></a>22 错误猜测</h3><p>靠直觉和经验。基本思想是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h3 id="23-状态转换测试"><a href="#23-状态转换测试" class="headerlink" title="23 状态转换测试"></a>23 状态转换测试</h3><p>将测试对象抽象为一个状态转换图。</p><h3 id="24-语法测试"><a href="#24-语法测试" class="headerlink" title="24 语法测试"></a>24 语法测试</h3><p>基于输入接口的语法变异生成测试用例。</p><p>综合测试策略：先对软件进行黑盒测试，按照静态测试、动态测试依次进行。接着使用白盒测试方法，进行单元测试，对每个模块内部逻辑进行验证，结合黑盒测试和白盒测试，验证模块之间的交互，通过黑盒验证整个系统的功能，白盒确定系统内部的实现。</p><h2 id="3-简述软件开发过程中以下测试方法的特点"><a href="#3-简述软件开发过程中以下测试方法的特点" class="headerlink" title="3 简述软件开发过程中以下测试方法的特点"></a>3 简述软件开发过程中以下测试方法的特点</h2><h3 id="3-1单元测试（unit-testing）"><a href="#3-1单元测试（unit-testing）" class="headerlink" title="3.1单元测试（unit testing）"></a>3.1单元测试（unit testing）</h3><p>单元测试是在软件开发过程中进行的最低级别的测试活动，是针对软件设计的最小单位程序模块进行的正确性工作。</p><p>单元是软件里最小的、可以单独执行编码的单位。单元必须可测；单元的行为或输出是可观测的；有明确的可定义的边界或接口。</p><h3 id="3-2集成测试（integration-testing）"><a href="#3-2集成测试（integration-testing）" class="headerlink" title="3.2集成测试（integration testing）"></a>3.2集成测试（integration testing）</h3><p>集成测试是在单元测试的基础上，将所有已通过单元测试的模块，采用适当的集成策略，按照概要设计的要求组装为子系统或系统，目的是确保各单元模块组合在一起后能够按照概要设计要求运行，检测增量的行为是否正确。</p><p>主要检测模块之间的接口和各个模块集成后实现的功能。重点测试模块的接口、兼容性和全局数据结构。</p><p>桩程序和模拟程序。</p><h3 id="3-3系统测试（system-testing）"><a href="#3-3系统测试（system-testing）" class="headerlink" title="3.3系统测试（system testing）"></a>3.3系统测试（system testing）</h3><p>将整个软件系统视为一个整体来进行测试</p><p>重点测试软件产品的各项功能是否满足用户的要求</p><p>还包括性能、安全性、兼容性、可用性等软件特性及方面的测试 </p><h3 id="3-4验收测试（acceptance-testing）"><a href="#3-4验收测试（acceptance-testing）" class="headerlink" title="3.4验收测试（acceptance testing）"></a>3.4验收测试（acceptance testing）</h3><p>向未来的用户表明系统能够像预定要求那样工作。</p><ul><li>某些已经测试过的纯粹技术性的特点可能不需要再次测试</li><li>对用户特别感兴趣的功能或性能，可能需要再增加一些测试</li><li>通常主要使用生产中的实际数据进行测试</li><li>可能需要设计并执行一些与用户使用步骤有关的测试</li></ul><p>软件配置复查：保证软件配置的所有成分都齐全，各方面的质量都符合要求，文档与程序一致，具有维护阶段所必须的细节，而且已经编排好目录。</p><h3 id="3-5冒烟测试（smoke-testing）"><a href="#3-5冒烟测试（smoke-testing）" class="headerlink" title="3.5冒烟测试（smoke testing）"></a>3.5冒烟测试（smoke testing）</h3><p>“daily build and smoke test” – 即每天自动编译及smoke test，这里的smoke test仅仅是一个简单的测试，看看我们编译好的产品是否“冒烟”以检查每天编译的结果是否成功。</p><ul><li>测试周期短，响应速度快</li><li>能最小化集成风险</li><li>能减小产品低质量的风险</li><li>能简单化错误诊断</li></ul><h3 id="3-6回归测试（regression-testing）"><a href="#3-6回归测试（regression-testing）" class="headerlink" title="3.6回归测试（regression testing）"></a>3.6回归测试（regression testing）</h3><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p><p>要尽可能减少回归测试的执行时间和开销：测试资源受限时，测试用例约简、测试用例选择、测试用例排序。</p><h3 id="3-7-α测试（α-testing）"><a href="#3-7-α测试（α-testing）" class="headerlink" title="3.7 α测试（α testing）"></a>3.7 α测试（α testing）</h3><p>$\alpha$测试是由一个用户在开发环境下进行的测试，也可以是开发机构内部的用户在模拟实际操作环境下进行的测试。目的是评价软件产品的FLURPS（即功能、局域化、可使用性、性能和支持）。</p><h3 id="3-8-β测试（β-testing）"><a href="#3-8-β测试（β-testing）" class="headerlink" title="3.8 β测试（β testing）"></a>3.8 β测试（β testing）</h3><p>$\beta$测试是由软件的多个用户在实际使用环境下进行的测试。开发者通常不在测试现场。</p><h2 id="4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）"><a href="#4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）" class="headerlink" title="4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）"></a>4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）</h2><h3 id="4-1负载测试（Load-Testing）"><a href="#4-1负载测试（Load-Testing）" class="headerlink" title="4.1负载测试（Load Testing）"></a>4.1负载测试（Load Testing）</h3><p>给系统一个特定的条件，观察系统的反应情况，在不同的负载级别上逐步加大或减小。</p><h3 id="4-2压力测试（Stress-Testing）"><a href="#4-2压力测试（Stress-Testing）" class="headerlink" title="4.2压力测试（Stress Testing）"></a>4.2压力测试（Stress Testing）</h3><p>持续不断地对被测试系统增加压力，直到被压垮，从而确定系统能承受的最大压力。</p><p>压力测试主要考虑下面三个方面：长时间测试对软件造成的影响；大数据量对软件的影响；高频率数据对软件的影响。</p><h3 id="4-3性能测试（Performance-Testing）"><a href="#4-3性能测试（Performance-Testing）" class="headerlink" title="4.3性能测试（Performance Testing）"></a>4.3性能测试（Performance Testing）</h3><p>一般通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p><h3 id="4-4可靠性测试（Reliability-Testing）"><a href="#4-4可靠性测试（Reliability-Testing）" class="headerlink" title="4.4可靠性测试（Reliability Testing）"></a>4.4可靠性测试（Reliability Testing）</h3><p>可靠性测试是在给被测试系统加载一定业务压力的情况下，使系统运行一段时间，以此来测试系统是否稳定。</p><h3 id="4-5-容量测试（Volume-Testing）"><a href="#4-5-容量测试（Volume-Testing）" class="headerlink" title="4.5 容量测试（Volume Testing）"></a>4.5 容量测试（Volume Testing）</h3><p>一种是针对某些系统存储、传输、统计和查询等业务进行大数据量的独立数据容量测试；另外一种是与压力测试、负载测试、可靠性测试等相结合的极限状态下的综合数据容量测试。</p><h3 id="4-6安全性测试（Security-Testing）"><a href="#4-6安全性测试（Security-Testing）" class="headerlink" title="4.6安全性测试（Security Testing）"></a>4.6安全性测试（Security Testing）</h3><p>安全性测试是设计测试用例来突破程序安全检查的过程。</p><h3 id="4-7安装测试（Installation-Testing）"><a href="#4-7安装测试（Installation-Testing）" class="headerlink" title="4.7安装测试（Installation Testing）"></a>4.7安装测试（Installation Testing）</h3><p>安装测试是确保软件在正常情况和异常情况下能成功安装。</p><h3 id="4-8可用性测试（Usability-Testing）"><a href="#4-8可用性测试（Usability-Testing）" class="headerlink" title="4.8可用性测试（Usability Testing）"></a>4.8可用性测试（Usability Testing）</h3><p>可用性测试检查待测试软件的人机界面，通常要检查的部件包括界面布局和色彩、输入和输出格式、程序流程和拼写等，以发现其中的人为因素和易用性等问题。</p><h3 id="4-9稳定性测试（Stability-Testing）"><a href="#4-9稳定性测试（Stability-Testing）" class="headerlink" title="4.9稳定性测试（Stability Testing）"></a>4.9稳定性测试（Stability Testing）</h3><p>稳定性测试方法主要尝试检测软件在其使用过程中性能是否稳定，以及是否会崩溃。</p><h3 id="4-10-本地化和国际化测试-Localization-and-Internationalization-Testing"><a href="#4-10-本地化和国际化测试-Localization-and-Internationalization-Testing" class="headerlink" title="4.10 本地化和国际化测试(Localization and Internationalization Testing)"></a>4.10 本地化和国际化测试(Localization and Internationalization Testing)</h3><p>在软件设计中除了语言本身，还要考虑用户所在的国家、地理位置和文化等因素，这个过程称为软件的本地化，有时也称软件的国际化。</p><h3 id="4-11-可访问性测试（Accessibility-Testing）"><a href="#4-11-可访问性测试（Accessibility-Testing）" class="headerlink" title="4.11 可访问性测试（Accessibility Testing）"></a>4.11 可访问性测试（Accessibility Testing）</h3><p>主要检测软件系统对于残疾人是否具有可访问性。</p><h3 id="4-12授权测试（Authorization-Testing）"><a href="#4-12授权测试（Authorization-Testing）" class="headerlink" title="4.12授权测试（Authorization Testing）"></a>4.12授权测试（Authorization Testing）</h3><p>授权测试是一种测试授权过程健壮性的方法，该方法通过理解授权工作原理和过程，利用这些信息来试图规避授权机制。</p><h3 id="4-13容错性测试（Fault-Tolerance-Testing）"><a href="#4-13容错性测试（Fault-Tolerance-Testing）" class="headerlink" title="4.13容错性测试（Fault Tolerance Testing）"></a>4.13容错性测试（Fault Tolerance Testing）</h3><p>容错性测试是指检查软件在异常条件下自身是否具有防护性的措施或某种灾难性恢复的手段。</p><h3 id="4-14一致性测试（Conformance-Testing）"><a href="#4-14一致性测试（Conformance-Testing）" class="headerlink" title="4.14一致性测试（Conformance Testing）"></a>4.14一致性测试（Conformance Testing）</h3><p>一致性测试或类型测试是测试一个产品在效率或互通性方面是否符合某个指定的标准。</p><h3 id="4-15配置测试（Configuration-Testing）"><a href="#4-15配置测试（Configuration-Testing）" class="headerlink" title="4.15配置测试（Configuration Testing）"></a>4.15配置测试（Configuration Testing）</h3><p>软件与硬件之间的交互测试称为配置测试，主要检测各种硬件环境是否能够支持软件的正常运行。</p><h3 id="4-16文档测试-Document-Testing"><a href="#4-16文档测试-Document-Testing" class="headerlink" title="4.16文档测试(Document Testing)"></a>4.16文档测试(Document Testing)</h3><p>主要是对相关的设计报告和用户使用说明进行测试。</p><h3 id="4-17兼容性测试-Compatibility-Testing"><a href="#4-17兼容性测试-Compatibility-Testing" class="headerlink" title="4.17兼容性测试(Compatibility Testing)"></a>4.17兼容性测试(Compatibility Testing)</h3><p>兼容性测试是指待测试项目在特定的硬件平台上，不同的应用软件之间，不同的操作系统平台上，在不同的网络等环境中能正常的运行的测试。</p><h3 id="4-18-试玩-（Playtest）"><a href="#4-18-试玩-（Playtest）" class="headerlink" title="4.18 试玩 （Playtest）"></a>4.18 试玩 （Playtest）</h3><p>试玩测试是在一种游戏设计开发过程中，在游戏投放市场之前，为了检查发现游戏中潜在的错误，进一步改进游戏而采取的一种测试方法。请游戏玩家来玩这个游戏，可以是开放式的、封闭的或者β式的。</p><h3 id="4-19-可恢复性测试（Recovery-Testing）"><a href="#4-19-可恢复性测试（Recovery-Testing）" class="headerlink" title="4.19 可恢复性测试（Recovery Testing）"></a>4.19 可恢复性测试（Recovery Testing）</h3><p>测试软件系统在故障发生后，重新建立其性能水平并恢复受影响数据的能力。</p><h3 id="4-20-卸载测试（Uninstall-Testing）"><a href="#4-20-卸载测试（Uninstall-Testing）" class="headerlink" title="4.20 卸载测试（Uninstall Testing）"></a>4.20 卸载测试（Uninstall Testing）</h3><p>卸载测试是对软件的全部、部分或升级卸载处理过程的测试。</p><h3 id="4-21-能力测试-Facility-Testing"><a href="#4-21-能力测试-Facility-Testing" class="headerlink" title="4.21 能力测试(Facility Testing)"></a>4.21 能力测试(Facility Testing)</h3><p>判断目标文档中的每一项能力是否确实已经实现。</p><h3 id="4-22-健壮性测试（Robustness-Testing）"><a href="#4-22-健壮性测试（Robustness-Testing）" class="headerlink" title="4.22 健壮性测试（Robustness Testing）"></a>4.22 健壮性测试（Robustness Testing）</h3><p>健壮性是指在异常情况下，软件还能正常运行的能力。健壮性有两层含义：一是容错能力；二是恢复能力。</p><h3 id="4-23-穿越测试（By-pass-Testing）"><a href="#4-23-穿越测试（By-pass-Testing）" class="headerlink" title="4.23 穿越测试（By-pass Testing）"></a>4.23 穿越测试（By-pass Testing）</h3><p>穿越测试通过构造测试用例来故意违反各种安全约束，其目的是验证输入检查，检查系统的鲁棒性和评估系统的安全性。</p><h3 id="4-24-在线帮助测试（Online-Help-Testing）"><a href="#4-24-在线帮助测试（Online-Help-Testing）" class="headerlink" title="4.24 在线帮助测试（Online Help Testing）"></a>4.24 在线帮助测试（Online Help Testing）</h3><p>验证系统的实时在线帮助的可用性和正确性。</p><h3 id="4-25-数据转换测试（Data-Conversion-Testing）"><a href="#4-25-数据转换测试（Data-Conversion-Testing）" class="headerlink" title="4.25 数据转换测试（Data Conversion Testing）"></a>4.25 数据转换测试（Data Conversion Testing）</h3><p>验证已存在的数据转换是否有效。 </p><p>考虑的因素：审计能力，数据库验证，数据整理，恢复计划。</p><h3 id="4-26-备份测试（Backup-Testing）"><a href="#4-26-备份测试（Backup-Testing）" class="headerlink" title="4.26 备份测试（Backup Testing）"></a>4.26 备份测试（Backup Testing）</h3><p>备份测试的目的是验证系统在软件或硬件失效的事件中备份其数据的能力。</p><h3 id="4-27接口测试（Interface-Testing）"><a href="#4-27接口测试（Interface-Testing）" class="headerlink" title="4.27接口测试（Interface Testing）"></a>4.27接口测试（Interface Testing）</h3><p>接口测试是对软件需求规格说明中的接口需求逐项进行的测试。</p><h3 id="4-28-人机交互界面测试（User-Interface-Testing）"><a href="#4-28-人机交互界面测试（User-Interface-Testing）" class="headerlink" title="4.28 人机交互界面测试（User Interface Testing）"></a>4.28 人机交互界面测试（User Interface Testing）</h3><p>人机交互界面测试对所有人机交互界面提供的操作和显示界面进行测试，以检验是否满足用户要求。</p><h3 id="4-29-余量测试（Remainder-Testing）"><a href="#4-29-余量测试（Remainder-Testing）" class="headerlink" title="4.29 余量测试（Remainder Testing）"></a>4.29 余量测试（Remainder Testing）</h3><p>保证程序执行过程中遇到资源以外的情况时，仍能维持正常运行状态。</p><h3 id="4-30-协议测试（Protocol-Testing）"><a href="#4-30-协议测试（Protocol-Testing）" class="headerlink" title="4.30 协议测试（Protocol Testing）"></a>4.30 协议测试（Protocol Testing）</h3><p>对实现的协议的正确性和有效性进行判别。</p><h3 id="4-31-内存泄漏测试（Memory-Leak-Testing）"><a href="#4-31-内存泄漏测试（Memory-Leak-Testing）" class="headerlink" title="4.31 内存泄漏测试（Memory Leak Testing）"></a>4.31 内存泄漏测试（Memory Leak Testing）</h3><p>对软件运行可能存在的各种内存泄露进行检查。</p><h3 id="4-32-存储测试-Storage-Testing"><a href="#4-32-存储测试-Storage-Testing" class="headerlink" title="4.32 存储测试 (Storage Testing)"></a>4.32 存储测试 (Storage Testing)</h3><p>对系统的存储功能进行测试，包括存储文件和存储介质。</p><h3 id="4-33-软件老化（software-aging）"><a href="#4-33-软件老化（software-aging）" class="headerlink" title="4.33 软件老化（software aging）"></a>4.33 软件老化（software aging）</h3><p>软件老化是在长期运行的软件系统上，由于错误条件的积累和资源的逐步消耗导致软件系统的性能逐渐下降、错误率不断上升并最终出现故障的一类问题。</p><h3 id="4-34-不稳定性测试（flaky-testing）"><a href="#4-34-不稳定性测试（flaky-testing）" class="headerlink" title="4.34 不稳定性测试（flaky testing）"></a>4.34 不稳定性测试（flaky testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h2 id="5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"><a href="#5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）" class="headerlink" title="5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"></a>5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）</h2><h3 id="5-1组合测试（Combinatorial-Testing）"><a href="#5-1组合测试（Combinatorial-Testing）" class="headerlink" title="5.1组合测试（Combinatorial Testing）"></a>5.1组合测试（Combinatorial Testing）</h3><p>组合测试是一种充分考虑各种因素及其相互作用的科学实用的软件测试方法，通过设计一组数量较少的测试用例，直接检测各种影响因素及其组合对软件产生的影响。</p><h3 id="5-2蜕变测试（Metamorphic-Testing）"><a href="#5-2蜕变测试（Metamorphic-Testing）" class="headerlink" title="5.2蜕变测试（Metamorphic Testing）"></a>5.2蜕变测试（Metamorphic Testing）</h3><p>蜕变测试一般指在预期输出无法给出的情况下，通过设计各种输入关系，观察输出是否满足预期的性质，用以判断软件的正确性。是一种基于性质的软件测试。</p><h3 id="5-3基于规格说明的软件测试-Specification-Based-Software-Testing"><a href="#5-3基于规格说明的软件测试-Specification-Based-Software-Testing" class="headerlink" title="5.3基于规格说明的软件测试(Specification Based Software Testing)"></a>5.3基于规格说明的软件测试(Specification Based Software Testing)</h3><p>基于规格说明的测试是验证软件的实现与规格说明的一致性。是一种黑盒测试技术。</p><h3 id="5-4基于模型的软件测试（model-based-testing）"><a href="#5-4基于模型的软件测试（model-based-testing）" class="headerlink" title="5.4基于模型的软件测试（model based testing）"></a>5.4基于模型的软件测试（model based testing）</h3><p>基于模型的软件测试可以根据软件行为模型和结构模型生成测试用例。它利用模型来描述系统的行为、特性和需求，以便自动生成测试用例、执行测试和验证系统的正确性。</p><p>软件测试模型包括有限状态机、UML、文法等。需要测试人员具备一定的理论基础和工具使用能力。</p><h3 id="5-5基于错误的软件测试-fault-based-testing"><a href="#5-5基于错误的软件测试-fault-based-testing" class="headerlink" title="5.5基于错误的软件测试(fault based testing)"></a>5.5基于错误的软件测试(fault based testing)</h3><p>基于错误的软件测试针对待测试软件中可能存在的某种软件错误，设计相应的测试用例，当运行这组测试用例时，如果没有发现错误，则认为该软件中不存在这类错误。</p><h3 id="5-6基于搜索的软件测试-Search-Based-Testing"><a href="#5-6基于搜索的软件测试-Search-Based-Testing" class="headerlink" title="5.6基于搜索的软件测试(Search Based Testing)"></a>5.6基于搜索的软件测试(Search Based Testing)</h3><p>基于搜素的软件测试是一种利用元启发式搜索技术自动生成测试数据的测试方法，可以进行结构测试、功能测试、灰盒测试、非功能性测试。</p><h3 id="5-7统计测试-Statistics-Testing"><a href="#5-7统计测试-Statistics-Testing" class="headerlink" title="5.7统计测试(Statistics Testing)"></a>5.7统计测试(Statistics Testing)</h3><p>统计测试是一种根据定义好的概率分布来随机选择测试用例的软件测试方法。</p><h3 id="5-8基于操作剖面的测试-Operational-Profile-Based-Testing"><a href="#5-8基于操作剖面的测试-Operational-Profile-Based-Testing" class="headerlink" title="5.8基于操作剖面的测试(Operational Profile Based Testing)"></a>5.8基于操作剖面的测试(Operational Profile Based Testing)</h3><p>基于操作剖面的测试是一种统计测试方法，它按照人们对软件各项功能的使用概率选择测试用例。</p><h3 id="5-9变异测试（Mutation-Testing）"><a href="#5-9变异测试（Mutation-Testing）" class="headerlink" title="5.9变异测试（Mutation Testing）"></a>5.9变异测试（Mutation Testing）</h3><p>变异测试通过在程序中植入一些程序员容易犯的错误，或利用相关的启发式方法植入一些错误，这些错误都是通过对原来的程序做一些句法上的修改，从而形成一组新的程序，称之为变异体，通过运行针对原程序的测试用例集，如果这些原来的测试用例能够发现变异体中错误，称之为杀死变异体，否则称为变异体存活。最后通过分析被杀死的变异体数量和存活的变异体数量，来推测软件程序中可能仍潜在的错误数量，评估针对原有程序的测试用例集的测试充分性程度。</p><p>结果：如果一个测试用例集能杀死所有植入错误的变异体，则这个测试用例集就有可能有能力检测出所有可能潜在的错误。</p><h3 id="5-10脆弱性测试（flaky-Testing）"><a href="#5-10脆弱性测试（flaky-Testing）" class="headerlink" title="5.10脆弱性测试（flaky Testing）"></a>5.10脆弱性测试（flaky Testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h3 id="5-11基于性质的软件测试方法-Property-Based-Testing"><a href="#5-11基于性质的软件测试方法-Property-Based-Testing" class="headerlink" title="5.11基于性质的软件测试方法(Property-Based Testing)"></a>5.11基于性质的软件测试方法(Property-Based Testing)</h3><p>基于性质的测试通常假设待测试程序满足给定性质，围绕给定性质进行测试，验证软件是否满足其定义的性质。</p><h3 id="5-12极限测试-Extreme-Testing"><a href="#5-12极限测试-Extreme-Testing" class="headerlink" title="5.12极限测试(Extreme Testing)"></a>5.12极限测试(Extreme Testing)</h3><p>先创建单元测试和验收测试，然后再创建代码库，这种形式的测试叫极限测试，也叫测试驱动开发。</p><p>验收测试是极限测试类型，其目的是判断应用程序是否满足如功能性和易用性等需求。在设计或计划阶段，由开发人员和客户来设计验收测试。</p><h3 id="5-13模糊测试（Fuzzing-Testing）"><a href="#5-13模糊测试（Fuzzing-Testing）" class="headerlink" title="5.13模糊测试（Fuzzing Testing）"></a>5.13模糊测试（Fuzzing Testing）</h3><p>模糊测试主要用于发现程序内部的安全漏洞和其他缺陷。通过向程序输入随机、无效或意外的数据，测试人员可以观察系统的反应，从而识别潜在的错误、崩溃和安全漏洞。</p><p>模糊测试是一种通过提供非预期的输入并监视异常结果来发现软件故障的方法。</p><h3 id="5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）"><a href="#5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）" class="headerlink" title="5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）"></a>5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）</h3><p>自适应测试也称为软件测试的控制论方法：是软件控制论的重要组成部分，它把软件测试的问题归结为控制问题，被测试软件当做被控制对象，软件测试策略当作相应的控制器，这样被测试软件和测试策略就构成一个闭环反馈控制系统。通过控制理论指导软件测试过程，从而希望达到科学有效地测试软件的目的。</p><p>自适应控制系统是通过在线实时了解被控对象，不断调节控制器，使系统的性能达到技术要求或最优。</p><p>缺点：反馈机制不够成熟。</p><h3 id="5-15导向性随机测试（Concolic-Testing）"><a href="#5-15导向性随机测试（Concolic-Testing）" class="headerlink" title="5.15导向性随机测试（Concolic Testing）"></a>5.15导向性随机测试（Concolic Testing）</h3><p>导向性随机测试是一种将具体执行与符号执行相结合的自动化测试方法，其目标是通过生成测试输入来执行程序中的所有可行路径，以发现程序缺陷。</p><h3 id="5-16图形用户界面测试（GUI-Testing）"><a href="#5-16图形用户界面测试（GUI-Testing）" class="headerlink" title="5.16图形用户界面测试（GUI Testing）"></a>5.16图形用户界面测试（GUI Testing）</h3><p>GUI测试是一种软件测试过程，测试的对象是软件产品的图形用户界面，目的是确保图形用户界面符合用户要求或规格说明书要求。</p><h3 id="5-17随机测试-Random-Testing"><a href="#5-17随机测试-Random-Testing" class="headerlink" title="5.17随机测试(Random Testing)"></a>5.17随机测试(Random Testing)</h3><p>在待测试软件所有可能的输入中，随机选择和产生测试输入并对待测试软件进行测试，这种测试方法叫做随机测试。</p><h3 id="5-18自适应随机测试-Adaptive-Random-Testing"><a href="#5-18自适应随机测试-Adaptive-Random-Testing" class="headerlink" title="5.18自适应随机测试(Adaptive Random Testing)"></a>5.18自适应随机测试(Adaptive Random Testing)</h3><p>一个测试用例如果没有发现软件故障，那么另一个相近或相似的测试用例可能也不会发现软件故障，因此在选择下一个测试用例时，要尽可能选择距离该测试用例远一点的测试。即使得测试用例尽可能均匀分散开。</p><p>自适应随机测试方法强调在随机选择测试用例的过程中，要使得测试用例尽可能均匀地分散开，这样随机产生的测试用例才有可能有更多机会发现软件故障。</p><h3 id="5-19反随机测试（Antirandom-Testing）"><a href="#5-19反随机测试（Antirandom-Testing）" class="headerlink" title="5.19反随机测试（Antirandom Testing）"></a>5.19反随机测试（Antirandom Testing）</h3><p>首先为待测试软件随机生成一个测试用例，随后每一个测试用例的生成都要求与已生成的测试用例保持最大的距离。</p><p>第一个测试用例是随机的，后面的测试用例可以看作是确定的。</p><h3 id="5-20结对测试-Pair-Testing"><a href="#5-20结对测试-Pair-Testing" class="headerlink" title="5.20结对测试(Pair Testing)"></a>5.20结对测试(Pair Testing)</h3><p>结对测试是由两个测试人员结对在一起对待测试软件进行测试的方法，一个测试人员控制鼠标和键盘，另一个测试人员做记录，一起讨论测试场景，提问题。结对的两个测试人员一般一个是专业测试人员，一个是开发人员或业务分析员。</p><h3 id="5-21在线测试（Online-Testing）"><a href="#5-21在线测试（Online-Testing）" class="headerlink" title="5.21在线测试（Online Testing）"></a>5.21在线测试（Online Testing）</h3><p>在线测试，也称为动态测试，该方法在待测试软件运行过程中动态产生测试用例，而不是事先产生测试用例。在线测试还存在很多问题，如覆盖性度量、测试场景的控制、故障的分析、重现及避免相同故障的重复出现等。</p><h3 id="5-22探索性测试（Exploratory-Testing）"><a href="#5-22探索性测试（Exploratory-Testing）" class="headerlink" title="5.22探索性测试（Exploratory Testing）"></a>5.22探索性测试（Exploratory Testing）</h3><p>这种测试方法强调测试人员个人的自由和责任，可以充分发挥他们的创造性和积极性，它把测试过程看成是一种与测试相关的学习，测试设计、测试执行和测试结果的解释同时进行且相互促进。</p><p>探索性测试的特点：强调测试设计与测试执行的同时性，这种同时性是相对传统软件测试过程中的先设计后测试来说的。测试工程师通过测试来不断学习被测试系统，通过学习来改进测试过程。探索性测试强调自由性和创造性。</p><h3 id="5-23反模型测试（Anti-model-Testing）"><a href="#5-23反模型测试（Anti-model-Testing）" class="headerlink" title="5.23反模型测试（Anti-model Testing）"></a>5.23反模型测试（Anti-model Testing）</h3><p>反模型测试和基于模型的测试方法相反，它一开始没有模型可用，通过执行一些抽样出来的测试用例，观察系统行为，并将这些信息综合起来，通过分析推理形成关于系统的一个抽象的模型。</p><h3 id="5-24成分测试（Compositional-Testing）"><a href="#5-24成分测试（Compositional-Testing）" class="headerlink" title="5.24成分测试（Compositional Testing）"></a>5.24成分测试（Compositional Testing）</h3><p>用分治法把复杂的大规模软件测试分解为测试该软件的各个组成成分。</p><p>成分测试是一种在软件工程中用于验证软件组件的技术。它关注于系统的组成部分——例如软件模块、组件或服务——如何组合在一起，以及这些组合如何影响系统的整体性能和行为。</p><h3 id="5-25-有限状态机测试（FSM-Testing）"><a href="#5-25-有限状态机测试（FSM-Testing）" class="headerlink" title="5.25 有限状态机测试（FSM Testing）"></a>5.25 有限状态机测试（FSM Testing）</h3><p>有限状态机测试是一种基于有限状态机理论的测试方法，广泛应用于软件系统和硬件设计的测试中。有限状态机（FSM）是一种数学模型，用于描述系统在不同状态之间的转移和行为。FSM Testing 的主要目标是验证系统在不同输入下的状态转移是否符合预期，确保软件或硬件的功能正确性。</p><h3 id="5-26-基于Petri网的测试（Petri-Net-based-Testing）"><a href="#5-26-基于Petri网的测试（Petri-Net-based-Testing）" class="headerlink" title="5.26 基于Petri网的测试（Petri Net based Testing）"></a>5.26 基于Petri网的测试（Petri Net based Testing）</h3><p>Petri网是一种图形化的形式化语言表示法, 该方法采用具有形式语义的图形语言, 既有严格的数学定义，又有直观的图形表示。</p><p>FSM一般是顺序性的，它定义的状态一般都是全局的状态；而Petri网一般是并行的，它定义的状态一般都是分布式的。</p><h3 id="5-27-基于模型检查的测试（Model-Checking-based-Testing）"><a href="#5-27-基于模型检查的测试（Model-Checking-based-Testing）" class="headerlink" title="5.27 基于模型检查的测试（Model Checking based Testing）"></a>5.27 基于模型检查的测试（Model Checking based Testing）</h3><p>模型检测的基本思想：用状态迁移系统（S）表示系统的行为，用模态&#x2F; 时序逻辑公式（F）描述系统的性质.。这样“系统是否具有所期望的性质”就转化为数学问题“状态迁移系统S是否是公式F 的一个模型？”</p><p>将一个过程或系统抽象成一个有穷状态模型，加以分析验证。</p><p>与测试不同，模型检测不是针对某组输入，而是面向某类性质来检查系统是否合乎规约!</p><h3 id="5-28-TTCN测试（TTCN-Testing）"><a href="#5-28-TTCN测试（TTCN-Testing）" class="headerlink" title="5.28 TTCN测试（TTCN Testing）"></a>5.28 TTCN测试（TTCN Testing）</h3><p>TTCN（Testing and Test Control Notation）是一种专门为测试系统和协议设计的标准化测试语言，广泛应用于电信、网络和其他领域的系统验证与测试中。TTCN允许测试人员定义测试用例、测试脚本和测试执行过程，以确保被测试对象（被测系统）符合其设计规范。</p><h3 id="5-29-布尔规格测试（Boolean-Specification-Testing）"><a href="#5-29-布尔规格测试（Boolean-Specification-Testing）" class="headerlink" title="5.29 布尔规格测试（Boolean Specification Testing）"></a>5.29 布尔规格测试（Boolean Specification Testing）</h3><p>如何根据这些布尔表达式设计测试用例来测试根据这些布尔规格说明建立起来的软件，并发现其中隐藏的错误是布尔规格测试的关键问题。 </p><h3 id="5-30-基于统一建模语言测试（UML-Based-Testing）"><a href="#5-30-基于统一建模语言测试（UML-Based-Testing）" class="headerlink" title="5.30 基于统一建模语言测试（UML Based Testing）"></a>5.30 基于统一建模语言测试（UML Based Testing）</h3><p>UML是一种可视化的面向对象系统建模描述工具。所谓基于UML的测试，就是应用待测试软件系统的UML模型来获得软件测试的需求和覆盖准则。</p><h3 id="5-31-差分测试（differential-testing）"><a href="#5-31-差分测试（differential-testing）" class="headerlink" title="5.31 差分测试（differential testing）"></a>5.31 差分测试（differential testing）</h3><p>主要用于比较两个或多个实现（例如，不同版本的程序或不同的实现算法）在相同输入下的输出结果，以发现潜在的缺陷或不一致之处。差分测试常用于确保新版本的软件相对于旧版本或不同实现之间的兼容性和一致性。</p><h3 id="5-32故障注入测试（Fault-Injection-Testing）"><a href="#5-32故障注入测试（Fault-Injection-Testing）" class="headerlink" title="5.32故障注入测试（Fault Injection Testing）"></a>5.32故障注入测试（Fault Injection Testing）</h3><p>故障注入测试是一种强大的软件测试技术，其主要目的是通过故意向系统中注入故障，验证系统在面对错误或异常情况下的反应和处理能力。这种测试可以帮助开发者发现潜在问题，评估系统的健壮性、可靠性和容错能力。</p><h2 id="6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"><a href="#6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）" class="headerlink" title="6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"></a>6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）</h2><h3 id="6-1面向对象软件的测试-Object-Oriented-Software-Testing"><a href="#6-1面向对象软件的测试-Object-Oriented-Software-Testing" class="headerlink" title="6.1面向对象软件的测试(Object Oriented Software Testing)"></a>6.1面向对象软件的测试(Object Oriented Software Testing)</h3><p>面向对象软件测试是一种专门针对面向对象编程（Object-Oriented Programming, OOP）设计的软件测试方法。由于面向对象的程序具有独特的特性，如<strong>封装、继承、多态</strong>，传统的软件测试方法并不总是适用于这种编程范式。因此，面向对象软件测试的重点在于处理这些独特的特性，并在测试中有效地验证程序的正确性、性能和可靠性。</p><p>测试对象间的交互、继承关系和多态性，确保类之间的继承结构和方法重载、重写等特性不会引发错误。面向对象的软件测试需要关注更细致的粒度，如类的内部状态、对象间的消息传递和状态变更。</p><h3 id="6-2面向方面的软件测试-Aspect-Oriented-Software-Testing"><a href="#6-2面向方面的软件测试-Aspect-Oriented-Software-Testing" class="headerlink" title="6.2面向方面的软件测试(Aspect Oriented Software Testing)"></a>6.2面向方面的软件测试(Aspect Oriented Software Testing)</h3><p>该编程范型主要强调将软件系统特别是面向对象系统中的分布在各种类和对象中的关注点（即所谓横切关注点）分离出来，实现比原来系统更好的模块化。</p><p>面向方面编程的核心就是将分散在多个模块中的一些核心关注点、中心功能，如登录功能和认证功能等，从这些模块中分离出来，横切出来的关注点独立地实现为系统的一个方面，这个方面的具体实现可以利用传统方法，例如面向对象的方法。</p><h3 id="6-3面向服务的软件测试-Service-Oriented-Software-Testing"><a href="#6-3面向服务的软件测试-Service-Oriented-Software-Testing" class="headerlink" title="6.3面向服务的软件测试(Service Oriented Software Testing)"></a>6.3面向服务的软件测试(Service Oriented Software Testing)</h3><p>面向服务的软件测试原理主要依赖于服务导向架构（SOA）和微服务架构的核心概念。该测试方法关注于确保各个服务之间的正常交互和完整性，以提供高质量的系统。</p><p>主要测试服务的功能、服务间的通信（如消息队列、API接口）、服务的独立性及其异常处理。重点是验证服务的接口、协议兼容性和依赖关系。</p><h3 id="6-4构件软件测试-Component-Based-Software-Testing"><a href="#6-4构件软件测试-Component-Based-Software-Testing" class="headerlink" title="6.4构件软件测试(Component Based Software Testing)"></a>6.4构件软件测试(Component Based Software Testing)</h3><p>基于构件的软件测试，是指在构件（Component）基础上进行的测试过程，构件可以是软件系统中的独立模块、服务或功能单元。这种测试方法强调构件的可重用性和互操作性，以提高软件开发的效率和质量。</p><p>专注于验证和评估软件系统中各个独立组件的功能和交互。此方法适用于组件化的软件开发模型，其中软件系统由多个松耦合、可重用的组件构成。</p><h3 id="6-5-Web应用软件测试-WEB-Testing"><a href="#6-5-Web应用软件测试-WEB-Testing" class="headerlink" title="6.5 Web应用软件测试(WEB Testing)"></a>6.5 Web应用软件测试(WEB Testing)</h3><p>对于WEB应用软件来说，WEB应用软件的测试具有更大的挑战。测试也是为了发现软件的错误并最终修正错误而运行软件的过程，但由于基于WEB的系统和应用存在于网络上，并且和很多不同的操作系统、浏览器（或其他界面设备如PDA、手机等）、硬件平台、通信协议、后台应用进行交互。</p><p>WEB应用软件测试就是为了发现WEB应用中的内容、功能、易用性、导航、性能、容量、安全性等方面的错误，Web测试需要关注跨浏览器兼容性、页面加载速度、响应式设计、安全性（如XSS、SQL注入）、以及多用户并发操作等因素</p><h3 id="6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing"><a href="#6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing" class="headerlink" title="6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)"></a>6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)</h3><p>普适计算（又称无处不在计算）指的是计算设备无处不在地嵌入到环境中，测试需要关注多种设备的互联和环境感知。</p><p>测试需要考虑设备间的协同、网络带宽和延迟、环境变化对系统的影响等，还要考虑设备的电池寿命、隐私保护和数据传输安全等因素。</p><p>普适计算环境下的软件测试是指在一个无处不在且高度集成的计算环境中，对软件系统进行的测试。在这样的环境中，计算设备和服务可以无缝地集成到日常生活中，用户可能会通过多种设备和场景与软件互动。</p><p>普适计算软件测试面临的挑战：</p><ul><li>上下文背景是挥发性的和瞬发的</li><li>普适计算环境中的物理背景本质上是不稳定的，有干扰和不精确的</li><li>普适计算软件中的各个计算实体是独立的和自我为中心的</li></ul><h3 id="6-7云测试-Cloud-Testing"><a href="#6-7云测试-Cloud-Testing" class="headerlink" title="6.7云测试(Cloud Testing)"></a>6.7云测试(Cloud Testing)</h3><p> 云测试本质上是一种软件测试形式，其中网络应用程序使用云计算环境来模拟现实世界的用户流量作为负载和压力测试的一种方式，测试是利用云端的资源（如主机或服务等），此外，整个测试环境可以按需的从云端获得。</p><h3 id="6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things"><a href="#6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things" class="headerlink" title="6.8物联网环境下的软件测试(Software Testing for Internet of Things)"></a>6.8物联网环境下的软件测试(Software Testing for Internet of Things)</h3><p>物联网的定义是：通过射频识别（RFID）、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物体与互联网相连接，进行信息交换和通信，以实现对物体的智能化识别、定位、跟踪、监控和管理的一种网络。</p><p>物联网（IoT）测试是对物联网设备及其系统性能、功能和安全性的评估过程。</p><h3 id="6-9并行软件测试-Concurrent-Software-Testing"><a href="#6-9并行软件测试-Concurrent-Software-Testing" class="headerlink" title="6.9并行软件测试(Concurrent Software Testing)"></a>6.9并行软件测试(Concurrent Software Testing)</h3><p>并行软件是指设计为支持同时执行多个计算或操作的应用程序。这类软件可以通过多线程、分布式计算或多核心处理器来实现并行处理，从而提高性能和响应能力。</p><p>并行软件的测试通常指的是在开发并行处理或多线程应用程序时，针对这些并行特性进行的测试。</p><h3 id="6-10嵌入式软件测试-Embedded-Software-Testing"><a href="#6-10嵌入式软件测试-Embedded-Software-Testing" class="headerlink" title="6.10嵌入式软件测试(Embedded Software Testing"></a>6.10嵌入式软件测试(Embedded Software Testing</h3><p>嵌入式软件测试&#x2F;嵌入式测试或叫交叉测试（cross-test）的目的与非嵌入式软件是相同的。</p><p>嵌入式测试强调对硬件资源的高效利用和系统的实时性，需要考虑嵌入式系统的稳定性、响应时间、资源消耗等因素，且测试环境往往比较特殊。</p><h3 id="6-11高可信软件测试-High-Confidence-Software-Testing"><a href="#6-11高可信软件测试-High-Confidence-Software-Testing" class="headerlink" title="6.11高可信软件测试(High Confidence Software Testing)"></a>6.11高可信软件测试(High Confidence Software Testing)</h3><p>可信性是软件的行为及结果符合人们的预期，在操作失误、环境影响、外部攻击等干扰时，仍然可以提供连续的服务。 </p><p>软件可信性包含的特征属性有可用性（availability）、可靠性（reliablity）、安全性（security）、可维护（maintainability）、完整性（integrity）等。</p><p>测试过程中不仅需要进行功能验证，还要进行严格的容错、冗余性、安全性和恢复能力的测试，确保软件能够在关键情况下保持高可靠性。</p><h3 id="6-12网构软件测试（Internetware-testing）"><a href="#6-12网构软件测试（Internetware-testing）" class="headerlink" title="6.12网构软件测试（Internetware testing）"></a>6.12网构软件测试（Internetware testing）</h3><p>网构软件是指与网络紧密结合的软件，强调在分布式网络环境中运行。测试需要验证其在多变的网络环境中的表现。 </p><p>测试需关注网络变化（如延迟、带宽限制）对软件性能和稳定性的影响，特别是网络通信的可靠性和数据一致性。</p><h3 id="6-13移动应用软件测试（app-testing）"><a href="#6-13移动应用软件测试（app-testing）" class="headerlink" title="6.13移动应用软件测试（app testing）"></a>6.13移动应用软件测试（app testing）</h3><p>手机软件测试是确保移动应用质量和用户体验的重要过程。它涉及对手机应用程序进行功能、性能、安全性和用户体验等多方面的验证。</p><h3 id="6-14-人工智能软件测试（Artificial-intelligence-testing）"><a href="#6-14-人工智能软件测试（Artificial-intelligence-testing）" class="headerlink" title="6.14 人工智能软件测试（Artificial intelligence testing）"></a>6.14 人工智能软件测试（Artificial intelligence testing）</h3><p>人工智能软件的测试是一个复杂但至关重要的过程，涉及确保AI系统在不同场景下的有效性、可靠性和安全性。</p><p>特点：不确定性和不透明性；数据依赖性；动态变化；非确定性输出；伦理和法律合规性。</p><h3 id="6-15-区块链软件系统测试-blockchain-software-testing"><a href="#6-15-区块链软件系统测试-blockchain-software-testing" class="headerlink" title="6.15 区块链软件系统测试(blockchain software testing)"></a>6.15 区块链软件系统测试(blockchain software testing)</h3><p>区块链软件是指用于创建、管理和维护区块链网络的各种应用程序和平台。这些软件提供了一个去中心化的环境，用于交易、数据存储和智能合约等功能。</p><p>测试重点是验证区块链协议的实现，如交易验证、数据一致性、网络中节点的协作以及安全性。区块链软件测试是确保开发出安全、可靠和高效的区块链应用的关键步骤。</p><h3 id="6-16-云宇宙测试-metaverse-testing）"><a href="#6-16-云宇宙测试-metaverse-testing）" class="headerlink" title="6.16 云宇宙测试(metaverse testing）"></a>6.16 云宇宙测试(metaverse testing）</h3><p>元宇宙（metaverse）是一种虚拟空间，结合了增强现实（AR）、虚拟现实（VR）、区块链和社交网络等技术，允许用户在一个共享的数字世界中进行互动和体验。这个概念不仅限于单一的平台或应用，而是一个广泛的生态系统，用户可以在其中进行社交、游戏、工作、教育和创造。</p><p>元宇宙测试是在虚拟环境中评估、验证和优化不同功能和内容的过程。这可以涉及诸多方面，包括用户体验、性能、安全性和交互性等。</p>]]></content>
      
      
      <categories>
          
          <category> Software Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
            <tag> Automated Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
