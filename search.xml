<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>韵外之致，意在笔先————从宋元时期窥探书法的笔法与意蕴</title>
      <link href="/2024/12/27/calligraphy-in-song-yuan-dynasties/"/>
      <url>/2024/12/27/calligraphy-in-song-yuan-dynasties/</url>
      
        <content type="html"><![CDATA[<p>书法艺术是中国古代优秀的艺术文化，从商周的甲骨文到如今的硬笔书法，绵延千年，展现出其悠久的历史底蕴和文化感染力。从美术的角度来看，书法是中国古代人民对线条和结构布局的深刻理解与体悟，书法本身也经历了一系列变革，在魏晋时达到一个顶峰，以二王、锺繇为代表，在唐朝达到另一个顶峰，涌现出一大批书法名家，如颜真卿、柳公权、欧阳询、褚遂良、虞世南、怀素等等，他们都各自形成了自己的书体，开创了书法史上的一个璀璨时代。而本文取唐后的宋元时期，这一时期的书家对线条和笔法的研究颇深，以行书和草书为著，是书法史上极为重要的一环。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy1.jpg" alt="瘦金"></p><p>李建中《贵宅帖》中：宋人尚意，表现在书法上，重行草、崇流美的尚意书风，韵外之致，意在笔先，不仅在当时成为一种时尚，而且对后世有深远影响。书法所形成的意韵小到线条笔法，大到气势、章法、结构，所谓韵外之致，意在笔先，就是以笔法为重点讨论书法的韵味。宋元时期，书法虽无唐朝盛世的辉煌，但也涌现出一批富有个性的书家，他们以表现自我意识为主，崇尚个人意趣，展现出一股别样的风气。</p><p>自我意识，乃是一个书家所必须具备的素质。反映在创作上，就是创新的思想和不拘泥于古人，基本上人们都是从临摹学起，以古人的贴或碑为蓝本，学习笔画、字形、笔法、结构、章法，学的少了就固守于其中难以从其他的书家中学习，学的多了则难免不精，易泛泛流俗，没有自己的标准和定性。宋朝前期受宋太宗“帖学”的影响颇深，阻碍了书法的创新发展，欧阳修则提出学书法不能摹仿古人，要自成一体，由此诞生了宋四家。</p><p>宋四家均受褚遂良、颜真卿的深刻影响，笔法的势迥异。我本人推米芾为尊，《苕溪诗帖》浑厚中结合了灵动，厚重之余平添几分婉转，《蜀素贴》整体要平和、中正舒缓许多。米芾的字多为斜势，如同山巅的奇石，跌宕欹侧，同时他充分利用了毛笔的笔锋，八面为锋，可谓奇绝险峻，他对笔法的研究和运用炉火纯青，当为宋四家之首。苏轼，字如其人，《寒食帖》道尽了其平生豁达，他的字看似平平无奇，朴素乏味，实则内含一种汪洋浩荡之势，变化莫测。苏轼仕途不顺，被贬黄州，但他并非一蹶不振之人，而是乐观豁达，自在洒脱。他长于楷书、行书，笔法肉丰骨劲，自然天成。黄庭坚与苏轼一样，为尚意之派，然有人评其笔法如死蛇挂树，毫无美感，乍看黄的用笔，会觉得他用笔软弱随意，没有力度和形体，但实则他的行书凝练有力，结构奇特，每一笔极尽伸展，线条如长枪大戟，结字蕴含深意，并且他的字连贯度极好，章法堪称一绝，代表作为《诸上座贴》。宋四家中最年长者即为蔡襄，蔡襄为人忠厚、正值，讲求信义，他的书法也端庄浑厚、淳淡婉美，相比苏黄，他的书法或许缺少些许意趣，但相比唐朝，又不完全遵循古法，起到了承上启下的重要作用，同时也有所创新，婉约优美，谦谦君子。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy2.jpeg" alt="东坡"></p><p>宋四家体现了宋朝书法的顶尖水平，其用笔、写意均可称道，我觉得他们摆脱了传统楷书、行书的绝对规整和绮丽浮夸，各自有各自的特点，且将书法的笔法进行了延拓，如米芾对于外拓的运用、对于倚斜和平衡的把握，黄庭坚对长画和字形的研究，更可贵的是意的参杂，如苏轼《寒食帖》中自我的纾解和旷达洒脱的人生态度。俗话说：“字如其人。”此言不假，宋四家为代表，古代的众多书家亦如此，他们临池妙翰，不仅仅只是为了追求书法境界的至臻至善，更是其人生意趣和人生追求的真切反映。</p><p>谈到元朝，首推书法大家赵孟頫，在我看来，他是书法史上的一位集大成者。子昂琴棋书画具绝，书法上承袭二王、师法李北海，自创行楷，行书更是冠绝当世，小楷也是上佳。李北海的字我觉得与《唐集王圣教序》神似，用笔典雅端庄又不失行书的秀丽连贯，而赵孟頫根本上还是取法二王，颇得几分精华。行楷是介于楷书和行书之间的一种书体，赵孟頫首次为行楷定性，我学行楷是从他的《胆巴碑》入手，《胆巴碑》是他晚年的行楷作品，充分体现了他行楷的味道，作品整体笔法秀媚，苍劲浑厚。而最能体现他行楷特点的应该是他50岁所写的《三门记》，尤其是其中的各种“钩”画和“捺”画，是赵体笔法中区别于其他书体的最大特色。“钩”画果断凌厉，“捺”画则完美诠释了何为一波三折，优美秀丽。行书方面，子昂的字体飘逸秀美、遒劲圆熟，代表作有《洛神赋》、《秋兴赋》、《闲居赋》。我觉得赵体在结字方面也有诸多功夫，形神不散、严谨又活泼，比如“也”字，既可扁平，又可修长，卧钩既可收敛，又可舒展。</p><p>在我看来，宋元时期的书法最重要的在于书法的意，此时的书法家注重在笔墨之间表现“气、骨、神、韵”，其中“气”指书法的气势和力度，“骨”指笔画的骨骼结构，“神”是指书法作品所表现出的精神内核，“韵”则是指语言表达的韵律感受。在书法的低级阶段，人们以象为先，注重形体的相似，简单来说，写得越像越好，把握住一种字体的形，但这并不意味着把握了书写这种字体的方法，死板模仿人人都会，难在理解字体的用笔和章法结构。每一种字体都有其特殊的用笔方法，或是中锋、侧锋，或是外拓、内擫，比如米芾将外拓笔法运用熟练至极，字体斜中取势，不偏不倚。而且真正好的临帖应该是临其神，摹其韵，我们可以看到，世间流传的《兰亭序》均为摹本，最著名的是冯承素本，其次还有褚遂良本、虞世南本等等，除冯承素摹本外其他的摹本均参杂了一些书法家本人的一些气韵，不墨守成规，也正是体现了书法家本身的一些思考。在书法的创作阶段，书法家是绝不能把别人的一种字体完全搬过来的，这里需要所谓的自我意识，书法家在平时已经形成了一套自己的用笔方法和习惯，对笔法、结构、章法也具有自己的理解和体悟，那么此时就会转化成作品。一幅好的书法作品，或者说是合格的书法作品，首先要有自己的思考，其次是对“气、骨、神、韵”的运用。</p><p><img src="/2024/12/27/calligraphy-in-song-yuan-dynasties/calligraphy3.jpg" alt="定风波"></p><p>韵外之致，意在笔先，宋元时期为我们呈现出了意在书法上的绝妙运用，这是作者自己意趣和品性的体现，姑且称之为书法中的意识流，近代书法尚古，回溯古法，而现代许多书家又尚意，但很多书家备受争议，如兰亭奖得主崔寒柏。书法中对意的理解和追求从未停止，无论何种书体，都是作者自身对书法艺术、对意蕴的思考和感悟，而宋元时期则为我们提供了丰富的意的含义。笔下生辉，我们需要的，是生于古法、成于今朝的笔法，是能体现别样思考和精神境界的意蕴。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> calligraphy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据时代的认知革命</title>
      <link href="/2024/12/27/huge-data-era-cognitive-revolution/"/>
      <url>/2024/12/27/huge-data-era-cognitive-revolution/</url>
      
        <content type="html"><![CDATA[<p>信息文明的发展是以大数据为基础的。</p><p>传统数据：可结构化</p><p>大数据：非结构化、半结构化</p><p>个人认知-&gt;集体认知-&gt;人工智能</p><h2 id="一．大数据：信息时代的根基"><a href="#一．大数据：信息时代的根基" class="headerlink" title="一．大数据：信息时代的根基"></a>一．<strong>大数据：信息时代的根基</strong></h2><p>什么是大数据？</p><p>大数据是指无法在可容忍的时间内用传统信息技术和软硬件工具对其进行感知、获取、管理、处理和服务的数据集合。</p><p>大数据&#x3D;传统的小数据+现代的大记录。</p><p>①　全数据：各个角度，不一定大。</p><p>②　小数据：以单个人为研究对象，重点在于研究的深度。用大数据得到规律，用小数据去匹配个人。</p><p>③　形态多：非结构化数据的大量涌现。如：网页、在线评论等。形态多不只意味着种类众多，还包含了混杂性。</p><p>④　结构化数据与非结构化数据的混杂。</p><p>⑤　速度快：数据的时效性，如人口普查。实时性：如体育赛事直播，交通路况。数据生产速度快；数据处理速度快；数据的价值随时间流逝而折扣。</p><p>⑥　价值大但密度低：大数据蕴涵着巨大的潜能和未知的属性。</p><p>一个观点：任何数据都可以是结构化数据。非结构化是暂时的，是人类的认知尚未达到某种水平。换言之，非结构化是非建模。</p><p>认知的角度论：不同人对于同一事物的认知不同，同一人对于不同事物的认知亦然，同一个人从不同角度对事物的认知也不同，角度决定认知的方向，认知的方向决定认知的思维策略。</p><p>认知的本质论：认知本质就是一个复杂的过程，所谓认知的概念是人脑提出来的，千年前或尚无认知一说，千年后认知也必然不同，不同的认知都是为了揭示事物的本质。</p><p>数据的精确与模糊：传统时代人们追求统计的方便和准确。大数据时代，舍恩伯格提出：“执迷于精确性是信息缺乏时代和模拟时代的产物”。</p><h2 id="二．大数据的哲学思考"><a href="#二．大数据的哲学思考" class="headerlink" title="二．大数据的哲学思考"></a>二．<strong>大数据的哲学思考</strong></h2><p>本体论：世界可分为三类体：第一体即物理实体，是由自然界物质以及人类所创造的各种实体设备、人造材料所构成的物质与材料世界。第二体即意识人体，指作为地球生命体代表的人体，构成社会的基本要素，人体具有自身的智能反应和智慧的意识活动。第三体即数字虚体，指存在于计算机和网络设备之中的所有数字代码集合体，基于计算机实现，由于网络通信而增强。</p><p>生存论：人类在这样的“镜像世界”的虚拟空间中获得了一种“镜像化生存”。“镜像的自我”，如照片，视频，vlog等。虚拟世界的个人记录，当人死后依据保留下来的数据性格仍可将其复活。如Twitter的Liveson功能，“生命虽逝，推文不止”。</p><p>方法论：抛弃对因果关系的追求而仅仅满足于获得相关关系。“知道是什么就够了，没必要知道为什么。在大数据时代，我们不必非得知道现象背后的原因，而是要让数据自己发声。“</p><p>对相对关系的分析构成了大数据预测的核心。任何的预测本身就是一种对被预测现象的干预过程，因此当所有人都知道这种预测之后，这种预测也就失效了。</p><p>克里斯·安德森：数据的洪流或将带来理论的终结。原先两个不同体系间需要搭建严格的逻辑范式来转换，而在大数据的支持下，只需数据足够多，通过匹配检索即可完成。</p><p>反对：一方面，大数据只能从过去的经验中学习，从而预测未来的趋势，但如果某件事在过去从未发生过，那么就无法预测。另一方面，我们需警惕大数据可能带来的无法预测的后果，如果一旦短时间内在大量数据中出现某种协同性偏差，就很容易导致滚雪球效应。</p><h2 id="三．从科学哲学视角研究大数据"><a href="#三．从科学哲学视角研究大数据" class="headerlink" title="三．从科学哲学视角研究大数据"></a>三．<strong>从科学哲学视角研究大数据</strong></h2><p>Jim Gray：科学研究范式四个阶段：</p><p>①　实验科学</p><p>②　理论科学</p><p>③　计算科学</p><p>④　数据密集型科学</p><p>数据驱动型方法论：</p><p>①　存在某种直觉的合理性，从存在的数据中所作出的归纳被证明是科学推理的一种关键形式，并且可以指导并渗透于实验的研究之中。</p><p>②　从数据中获得有意义的模式的过程中机器的核心作用，并且因此引出自动化推理的核心作用。</p><p>数据自然界：数据成为了和自然与社会相平行的一个新的领域。大数据科学流程间实现高度的自动化过程。”数据挖掘“，”机器学习“。</p><p>大数据的科学建模与科学说明：</p><p>只要数据的广度和精度足够充足，大数据就足以表征复杂对象。Pietsch将其称为”水平式建模”。科学对世界的理解通常总是预设统一论的解释。某个现象是通过和其他现象相互关联起来并且减少独立假设的数量而得以理解的。人们认知新事物是通过已知事物进行类比模拟。</p><p>复杂科学中的现象，比如社会科学，可能完全无法获得统一论的说明，因为缺乏普遍性的规律。</p><h2 id="四．大数据统计学的革命及其哲学意义"><a href="#四．大数据统计学的革命及其哲学意义" class="headerlink" title="四．大数据统计学的革命及其哲学意义"></a>四．<strong>大数据统计学的革命及其哲学意义</strong></h2><p>统计：参数化-&gt;非参数化</p><p>大数据：层级式建模-&gt;水平式建模</p><p>大数据科学的理论负载性与因果结构</p><p>结论：大数据是信息时代的复杂性科学。</p><p>①　大数据科学是符合信息时代特征的新的知识发现方式。</p><p>②　大数据时代信息技术成为了知识发现的主体。</p><p>③　大数据直接面对全体数据，分析的样本为全体数据，科学建模并不具有传统科学所具有的分层模型特征，而是水平式的。</p><p>④　大数据可以实现面向个体或者部分个体的微观规律的知识，具有高度语境特异性的特点。</p><p>⑤　信息技术的发展使我们存储和处理数据的能力极大增长，并造成了数据的爆炸，因此是促成大数据的外在成因。而统计科学思维和方法上的革命是内因。</p><h2 id="五．信息媒介与人的关系"><a href="#五．信息媒介与人的关系" class="headerlink" title="五．信息媒介与人的关系"></a>五．<strong>信息媒介与人的关系</strong></h2><p>媒介技术与人的双向延申：</p><p>技术哲学家卡普：“器官投影说”。</p><p>一方面从地位，技术是连接人类和自然的纽带，工具和机械作为技术的物化状态，是人体器官向大自然的外化、投影和延申。另一方面从功能，技术扩展、强化和补充了人体器官的各种技能，增强了人类控制和改造自然的能力。</p><p>人类的技术工具和器物是人体器官的投影，要理解作为技术文化的技术工具，我们必须先要理解人体的外形和功能，人体器官本身是创造技术人工物的外形和功能的尺度。</p><p>这种用人的身体来类比技术工具的本质有其合理性。一方面，早期对于技术本质的认识尚不深刻；另一方面，技术就是人的一种存在方式。</p><p>媒介理论学家麦克卢汉：“媒介延申论”。</p><p>媒介是人的延申。</p><p>传统传播学意义上：某种工具，提供了人们交流和传播的渠道。麦克卢汉的媒介还涉及多种完全不同类型的技术性工具，一切能延申人体和感官的技术工具都可以称为媒介。一切人造的东西都可以当做是过去用身体或身体的一部分所行使的功能的延申。</p><p>第二种理解：媒介即环境。</p><p>每当一种新的媒介出现时，人们会感到新奇，并且主动地关注到新媒介的存在，而当这种媒介逐渐融入人们的日常生活时，人们就不会对它感到惊讶了，它变成人熟知的环境背景。</p><p>人类媒介发展史：</p><ul><li>口语传播时代</li><li>印刷传播时</li><li>电子传播时代</li></ul><p>麦克卢汉的“全球村“：时空压缩；即时互动；整体思维与共时思维；感官的电子膨胀；感觉的电子化；情感模式。</p>]]></content>
      
      
      <categories>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Science </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Foundations of Data Science Review</title>
      <link href="/2024/12/27/foundations-of-data-science-review/"/>
      <url>/2024/12/27/foundations-of-data-science-review/</url>
      
        <content type="html"><![CDATA[<p>本篇是我的2024Fall数据科学基础复习笔记（Review Notes of Foudations of Data Science）这门课由尹一通（尹神）和刘明谋老师开设，课程主页:<a href="https://tcs.nju.edu.cn/wiki/index.php?title=%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80_(Fall_2024)">2024 Fall 数据科学基础 NJU TCS GROUP</a></p><p>笔记如下:<a href="/file/foundations-of-data-science-review.pdf" download="foundations-of-data-science-review.pdf">notes</a><br>如有疏漏和错误欢迎指正。最后的期末考试以基本概念为主（统计部分不考），平时作业难度很大，有些是MU,GS,BHK（教材和参考书）的课后习题。</p><p>课程感受:尹神讲了前几次课给大家开了头，后续都是刘老师讲授的，这门课英文课件英文作业，个人认为对于概念理解应该会更好，但是需要投入较长时间。课程包括了经典概率论的所有内容，并且充满了TCS的味道，随机图和随机游走随机可见，随机过程的部分难度较大，马尔科夫链和贝叶斯估计以及假设检验那里和机器学习相关性非常大。</p>]]></content>
      
      
      <categories>
          
          <category> TCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability </tag>
            
            <tag> Random Process </tag>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 Fall Compiler Review</title>
      <link href="/2024/12/26/compiler-review/"/>
      <url>/2024/12/26/compiler-review/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> TCS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024Fall Software Testing Review</title>
      <link href="/2024/12/25/software-testing-review/"/>
      <url>/2024/12/25/software-testing-review/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简答题（20分，每题1分）"><a href="#1-简答题（20分，每题1分）" class="headerlink" title="1 简答题（20分，每题1分）"></a>1 简答题（20分，每题1分）</h2><h3 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1 什么是软件测试？"></a>1 什么是软件测试？</h3><p>软件测试就是在软件投入运行前，对软件需求分析、设计规格说明和编码实现的最终审查，它是软件质量保证的关键步骤。软件测试有八种定义。</p><h3 id="2-软件测试具有哪些特性？"><a href="#2-软件测试具有哪些特性？" class="headerlink" title="2 软件测试具有哪些特性？"></a>2 软件测试具有哪些特性？</h3><ul><li>存在性或永不过时性：任何软件都有缺陷，软件测试将因为软件的存在而存在</li><li>不完全性或抽样性：输入空间很庞大需要进行抽样</li><li>证错不证对性：只能证明软件的不正确性</li><li>检错保质性</li><li>综合性或多方求证性</li><li>测试效果评判准则</li></ul><h3 id="3-软件测试的对象包括哪些方面？"><a href="#3-软件测试的对象包括哪些方面？" class="headerlink" title="3 软件测试的对象包括哪些方面？"></a>3 软件测试的对象包括哪些方面？</h3><p>软件开发过程中的需求规格说明、概要设计规格说明、详细规格说明以及源程序都是。</p><h3 id="4-软件测试的目标是什么？"><a href="#4-软件测试的目标是什么？" class="headerlink" title="4 软件测试的目标是什么？"></a>4 软件测试的目标是什么？</h3><p>发现错误；检查系统是否满足需求。</p><h3 id="5写出你认为软件测试应该遵循的最重要的几条原则"><a href="#5写出你认为软件测试应该遵循的最重要的几条原则" class="headerlink" title="5写出你认为软件测试应该遵循的最重要的几条原则."></a>5写出你认为软件测试应该遵循的最重要的几条原则.</h3><h3 id="6-软件测试方法可以分为哪几类方法？"><a href="#6-软件测试方法可以分为哪几类方法？" class="headerlink" title="6 软件测试方法可以分为哪几类方法？"></a>6 软件测试方法可以分为哪几类方法？</h3><p>软件测试可以基于不同的角度和性质出发设计测试方法。如基于代码、基于用户、基于故障、基于输入、基于属性、基于性质、基于开发过程、基于规格、基于模型等等。具体的可以包括静态测试、动态测试；黑盒测试、白盒测试；针对不同开发方式和应用场景的软件测试；针对不同特性和方面的软件测试；针对不同开发阶段的以及一些特殊的测试方法。</p><h3 id="7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"><a href="#7-简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？" class="headerlink" title="7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？"></a>7 简单描述软件测试的信息流模型，指出在该模型中最关键的因素是什么？</h3><p>最关键的因素：与测试相关的软件配置、测试配置、测试工具。</p><h3 id="8-软件开发有哪些模型，软件测试分别处于什么位置？"><a href="#8-软件开发有哪些模型，软件测试分别处于什么位置？" class="headerlink" title="8 软件开发有哪些模型，软件测试分别处于什么位置？"></a>8 软件开发有哪些模型，软件测试分别处于什么位置？</h3><ul><li>大棒开发法：整个过程中</li><li>边写边改法：在测试环节中</li><li>瀑布模型：处于开发阶段的最后一步</li><li>快速原型开发模型：在原型开发、原型评价和系统实现当中</li><li>螺旋开发模型：处于每个开发阶段的测试阶段中</li><li>敏捷方法之XP：测试过程中</li></ul><h3 id="9-软件测试过程有哪些模型？这些模型各有什么特点？"><a href="#9-软件测试过程有哪些模型？这些模型各有什么特点？" class="headerlink" title="9 软件测试过程有哪些模型？这些模型各有什么特点？"></a>9 软件测试过程有哪些模型？这些模型各有什么特点？</h3><ul><li>V模型：左侧基于开发模型，右侧是对应的测试过程</li><li>W模型：开发和测试各是一个V</li><li>X模型：左半部分是针对单独程序片段进行的相互分离的编码和测，经过多次交接，集成为可以执行的程序</li></ul><h3 id="10-作为一种职业，你认为软件测试员应该具备哪些专业基础？"><a href="#10-作为一种职业，你认为软件测试员应该具备哪些专业基础？" class="headerlink" title="10 作为一种职业，你认为软件测试员应该具备哪些专业基础？"></a>10 作为一种职业，你认为软件测试员应该具备哪些专业基础？</h3><p>探索精神、故障排除能手、不懈努力、创造性、追求完美、判断准确、老练稳重、说服力。</p><h3 id="11-在软件测试领域，最根本（关键）的问题在哪里？"><a href="#11-在软件测试领域，最根本（关键）的问题在哪里？" class="headerlink" title="11 在软件测试领域，最根本（关键）的问题在哪里？"></a>11 在软件测试领域，最根本（关键）的问题在哪里？</h3><p>软件测试的样例太多了，需要对样例进行涵盖和选择。</p><h3 id="11-软件测试工具大致可以分为几种？"><a href="#11-软件测试工具大致可以分为几种？" class="headerlink" title="11 软件测试工具大致可以分为几种？"></a>11 软件测试工具大致可以分为几种？</h3><p>测试管理工具、自动化功能测试工具、性能测试工具、单元测试工具、白盒测试工具、测试用例设计工具、根据是否收费还可以分为商业测试工具、开源和免费。</p><h3 id="12-软件测试管理具有什么作用？"><a href="#12-软件测试管理具有什么作用？" class="headerlink" title="12 软件测试管理具有什么作用？"></a>12 软件测试管理具有什么作用？</h3><p>对测试过程、测试人员及组织、测试文档、测试环境、测试质量都需要进行全面管理才能有效测试，确保软件质量。软件测试管理贯穿整个测试的全过程。</p><h3 id="13-简述软件测试发展的六个发展阶段。"><a href="#13-简述软件测试发展的六个发展阶段。" class="headerlink" title="13 简述软件测试发展的六个发展阶段。"></a>13 简述软件测试发展的六个发展阶段。</h3><ul><li>Debugging oriented (1950年左右)</li><li>Demonstration oriented (1960年左右)</li><li>Destruction oriented (1970年左右)</li><li>Evaluation oriented (1980年左右)</li><li>Prevention oriented (1990年以后)</li><li>Professional、education and research （2000年以后）</li></ul><h3 id="14-缺陷管理具体包括哪些功能？"><a href="#14-缺陷管理具体包括哪些功能？" class="headerlink" title="14 缺陷管理具体包括哪些功能？"></a>14 缺陷管理具体包括哪些功能？</h3><p>缺陷预防、缺陷发现、缺陷记录和报告、缺陷分类和跟踪、缺陷处理以及缺陷预测。</p><h3 id="15-什么是软件？"><a href="#15-什么是软件？" class="headerlink" title="15 什么是软件？"></a>15 什么是软件？</h3><p>软件是计算机程序、规程以及可能的相关文档和运行计算机系统需要的数据。软件&#x3D;程序+文档&#x3D;知识+使用&#x3D;服务+需求。</p><h3 id="16-什么是软件质量？"><a href="#16-什么是软件质量？" class="headerlink" title="16 什么是软件质量？"></a>16 什么是软件质量？</h3><p>软件产品满足规定和隐含需求能力有关的所有特征和所有特性的总和。包括产品质量、过程质量、静态质量与动态质量。</p><h3 id="17-什么是软件缺陷？"><a href="#17-什么是软件缺陷？" class="headerlink" title="17 什么是软件缺陷？"></a>17 什么是软件缺陷？</h3><p>将所有的软件问题统称为缺陷。包括：软件未达到产品说明书中已经标明的功能；软件出现了产品说明书中指明不会出现的错误等。</p><h3 id="18-软件测试发展的未来趋势是什么？"><a href="#18-软件测试发展的未来趋势是什么？" class="headerlink" title="18 软件测试发展的未来趋势是什么？"></a>18 软件测试发展的未来趋势是什么？</h3><p>物理运行——知识——软件优化。软件无处不在，软件定义一切，软件使能一切，智能化软件时代即将到来。</p><h3 id="19-软件测试有哪些停止准则？"><a href="#19-软件测试有哪些停止准则？" class="headerlink" title="19 软件测试有哪些停止准则？"></a>19 软件测试有哪些停止准则？</h3><ul><li>测试超过了预定时间</li><li>执行了所有的测试用例，但没有发现故障</li><li>使用特定的测试用例设计方案作为判断测试停止的准则</li><li>正面指出停止测试的具体要求</li><li>根据单位时间内查出故障的数量决定</li></ul><h3 id="20-解释软件的故障模型PIE。"><a href="#20-解释软件的故障模型PIE。" class="headerlink" title="20 解释软件的故障模型PIE。"></a>20 解释软件的故障模型PIE。</h3><ul><li>Execution执行：错误代码必须被执行到</li><li>Infection感染：触发了错误的中间状态</li><li>Propagation传播：错误的中间状态必须可以传播到最后的输出得以观测</li></ul><h2 id="2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"><a href="#2-名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）" class="headerlink" title="2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）"></a>2 名词解释，并将以下名词术语相应编号填入表中进行分类，给出白盒动态测试技术之间的强弱关系，给出黑盒测试和白盒测试综合的测试策略。（10分）</h2><table><thead><tr><th></th><th>1 黑盒测试</th><th>2 白盒测试</th></tr></thead><tbody><tr><td>3 静态测试</td><td>5</td><td>6，7，8，9</td></tr><tr><td>4 动态测试</td><td>19，20，21，22，23，24</td><td>10，11，12，13，14，15，16，17，18</td></tr></tbody></table><h3 id="1-黑盒测试"><a href="#1-黑盒测试" class="headerlink" title="1 黑盒测试"></a>1 黑盒测试</h3><p>把待测试程序或软件系统看成一个无法打开的黑匣子，完全不知道程序的内部结构和处理过程的前提下，在程序接口进行测试。</p><h3 id="2-白盒测试"><a href="#2-白盒测试" class="headerlink" title="2 白盒测试"></a>2 白盒测试</h3><p>把测试对象看成一个打开的盒子，允许软件程序员利用程序内部的逻辑结构及有关信息。</p><h3 id="3-静态测试"><a href="#3-静态测试" class="headerlink" title="3 静态测试"></a>3 静态测试</h3><p>在不执行代码的情况下进行的测试。</p><h3 id="4-动态测试"><a href="#4-动态测试" class="headerlink" title="4 动态测试"></a>4 动态测试</h3><p>在执行程序代码的情况下进行的测试。</p><h3 id="5-文档审查"><a href="#5-文档审查" class="headerlink" title="5 文档审查"></a>5 文档审查</h3><p>对测试的相关设计文档进行审查。</p><h3 id="6-同行评审"><a href="#6-同行评审" class="headerlink" title="6 同行评审"></a>6 同行评审</h3><p>软件设计人员和编码人员加上一两个其他程序员间互相审查代码。</p><h3 id="7桌面评审"><a href="#7桌面评审" class="headerlink" title="7桌面评审"></a>7桌面评审</h3><p>单人进行的代码检查或代码走查，由一个人阅读程序。</p><h3 id="8-代码走查"><a href="#8-代码走查" class="headerlink" title="8 代码走查"></a>8 代码走查</h3><p>程序员和测试人员组成的5人小组审查程序。</p><h3 id="9-代码审查"><a href="#9-代码审查" class="headerlink" title="9 代码审查"></a>9 代码审查</h3><p>编写受评审代码的程序员不能参与，每个评审人员从不同角度对代码进行评审。</p><h3 id="10语句覆盖"><a href="#10语句覆盖" class="headerlink" title="10语句覆盖"></a>10语句覆盖</h3><p>执行每条可执行语句，覆盖对象是每条可执行语句。</p><h3 id="11判定覆盖"><a href="#11判定覆盖" class="headerlink" title="11判定覆盖"></a>11判定覆盖</h3><p>从源代码中找出所有分支或决策点，执行所有分支或决策点的两种取值。</p><h3 id="12条件覆盖"><a href="#12条件覆盖" class="headerlink" title="12条件覆盖"></a>12条件覆盖</h3><p>让判定语句中的每个条件变量的真假值都能取到。</p><h3 id="13判定-条件覆盖"><a href="#13判定-条件覆盖" class="headerlink" title="13判定&#x2F;条件覆盖"></a>13判定&#x2F;条件覆盖</h3><p>不仅让判定语句中的每个条件变量的真假值都能取到，而且让判定语句取到真假值。</p><h3 id="14条件组合覆盖"><a href="#14条件组合覆盖" class="headerlink" title="14条件组合覆盖"></a>14条件组合覆盖</h3><p>设计测试用例让判定语句中的每个条件变量的真假值组合情况都执行。</p><h3 id="15-修改决策条件覆盖"><a href="#15-修改决策条件覆盖" class="headerlink" title="15 修改决策条件覆盖"></a>15 修改决策条件覆盖</h3><p>设计测试用例，让每个条件变量独立改变判定语句的真假值。保证每个变量真假值出现一次；整个判定式出现真假值；让每个变量独立影响判定式的真假值。</p><h3 id="16路径覆盖"><a href="#16路径覆盖" class="headerlink" title="16路径覆盖"></a>16路径覆盖</h3><p>设计足够的测试用例，覆盖程序中所有可能的路径。</p><h3 id="17-LCSAJ-覆盖"><a href="#17-LCSAJ-覆盖" class="headerlink" title="17 LCSAJ 覆盖"></a>17 LCSAJ 覆盖</h3><p>关注程序控制流的跳转情况。</p><h3 id="18数据流测试（定义-引用对覆盖）"><a href="#18数据流测试（定义-引用对覆盖）" class="headerlink" title="18数据流测试（定义&#x2F;引用对覆盖）"></a>18数据流测试（定义&#x2F;引用对覆盖）</h3><p>利用程序的数据流&#x2F;控制流图进行测试。每个测试用例包括输入、相关变量定义和使用对的位置、执行的控制流子路径、预期输出。</p><h3 id="19-等价类划分"><a href="#19-等价类划分" class="headerlink" title="19 等价类划分"></a>19 等价类划分</h3><p>把所有可能输入的数据划分成若干等价类。</p><h3 id="20-边界值分析"><a href="#20-边界值分析" class="headerlink" title="20 边界值分析"></a>20 边界值分析</h3><p>通常输入等价类与输出等价类的边界。应该选取正好等于、刚刚大于，或刚刚小于边界的值作为测试数据，而不是选取等价类的典型值或任意值作为测试数据。</p><h3 id="21-因果图与决策表"><a href="#21-因果图与决策表" class="headerlink" title="21 因果图与决策表"></a>21 因果图与决策表</h3><p>因果图生成的就是决策表。适用于检查程序输入条件的各种组合情况。</p><h3 id="22-错误猜测"><a href="#22-错误猜测" class="headerlink" title="22 错误猜测"></a>22 错误猜测</h3><p>靠直觉和经验。基本思想是列举出程序中可能有的错误和容易发生错误的特殊情况，并且根据它们选择测试方案。</p><h3 id="23-状态转换测试"><a href="#23-状态转换测试" class="headerlink" title="23 状态转换测试"></a>23 状态转换测试</h3><p>将测试对象抽象为一个状态转换图。</p><h3 id="24-语法测试"><a href="#24-语法测试" class="headerlink" title="24 语法测试"></a>24 语法测试</h3><p>基于输入接口的语法变异生成测试用例。</p><p>综合测试策略：先对软件进行黑盒测试，按照静态测试、动态测试依次进行。接着使用白盒测试方法，进行单元测试，对每个模块内部逻辑进行验证，结合黑盒测试和白盒测试，验证模块之间的交互，通过黑盒验证整个系统的功能，白盒确定系统内部的实现。</p><h2 id="3-简述软件开发过程中以下测试方法的特点"><a href="#3-简述软件开发过程中以下测试方法的特点" class="headerlink" title="3 简述软件开发过程中以下测试方法的特点"></a>3 简述软件开发过程中以下测试方法的特点</h2><h3 id="3-1单元测试（unit-testing）"><a href="#3-1单元测试（unit-testing）" class="headerlink" title="3.1单元测试（unit testing）"></a>3.1单元测试（unit testing）</h3><p>单元测试是在软件开发过程种进行的最低级别的测试活动，是针对软件设计的最小单位程序模块进行的正确性工作。</p><p>单元是软件里最小的、可以单独执行编码的单位。单元必须可测；单元的行为或输出是可观测的；有明确的可定义的边界或接口。</p><h3 id="3-2集成测试（integration-testing）"><a href="#3-2集成测试（integration-testing）" class="headerlink" title="3.2集成测试（integration testing）"></a>3.2集成测试（integration testing）</h3><p>集成测试是在单元测试的基础上，将所有已通过单元测试的模块，采用适当的集成策略，按照概要设计的要求组装为子系统或系统，目的是确保各单元模块组合在一起后能够按照概要设计要求运行，检测增量的行为是否正确。</p><p>主要检测模块之间的接口和各个模块集成后实现的功能。重点测试模块的接口、兼容性和全局数据结构。</p><p>桩程序和模拟程序。</p><h3 id="3-3系统测试（system-testing）"><a href="#3-3系统测试（system-testing）" class="headerlink" title="3.3系统测试（system testing）"></a>3.3系统测试（system testing）</h3><p>将整个软件系统视为一个整体来进行测试</p><p>重点测试软件产品的各项功能是否满足用户的要求</p><p>还包括性能、安全性、兼容性、可用性等软件特性及方面的测试 </p><h3 id="3-4验收测试（acceptance-testing）"><a href="#3-4验收测试（acceptance-testing）" class="headerlink" title="3.4验收测试（acceptance testing）"></a>3.4验收测试（acceptance testing）</h3><p>向未来的用户表明系统能够像预定要求那样工作。</p><ul><li>某些已经测试过的纯粹技术性的特点可能不需要再次测试</li><li>对用户特别感兴趣的功能或性能，可能需要再增加一些测试</li><li>通常主要使用生产中的实际数据进行测试</li><li>可能需要设计并执行一些与用户使用步骤有关的测试</li></ul><p>软件配置复查：保证软件配置的所有成分都齐全，各方面的质量都符合要求，文档与程序一致，具有维护阶段所必须的细节，而且已经编排好目录。</p><h3 id="3-5冒烟测试（smoke-testing）"><a href="#3-5冒烟测试（smoke-testing）" class="headerlink" title="3.5冒烟测试（smoke testing）"></a>3.5冒烟测试（smoke testing）</h3><p>“daily build and smoke test” – 即每天自动编译及smoke test，这里的smoke test仅仅是一个简单的测试，看看我们编译好的产品是否“冒烟”以检查每天编译的结果是否成功。 </p><h3 id="3-6回归测试（regression-testing）"><a href="#3-6回归测试（regression-testing）" class="headerlink" title="3.6回归测试（regression testing）"></a>3.6回归测试（regression testing）</h3><p>回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p><p>要尽可能减少回归测试的执行时间和开销：测试资源受限时，测试用例约简、测试用例选择、测试用例排序。</p><h3 id="3-7-α测试（α-testing）"><a href="#3-7-α测试（α-testing）" class="headerlink" title="3.7 α测试（α testing）"></a>3.7 α测试（α testing）</h3><p>$\alpha$测试是由一个用户在开发环境下进行的测试，也可以是开发机构内部的用户在模拟实际操作环境下进行的测试。目的是评价软件产品的FLURPS（即功能、局域化、可使用性、性能和支持）。</p><h3 id="3-8-β测试（β-testing）"><a href="#3-8-β测试（β-testing）" class="headerlink" title="3.8 β测试（β testing）"></a>3.8 β测试（β testing）</h3><p>$\beta$测试是由软件的多个用户在实际使用环境下进行的测试。开发者通常不在测试现场。</p><h2 id="4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）"><a href="#4-简述以下软件特性或方面的测试特点（what-why-how-…）（30分，每题1分）" class="headerlink" title="4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）"></a>4 简述以下软件特性或方面的测试特点（what,why, how,…）（30分，每题1分）</h2><h3 id="4-1负载测试（Load-Testing）"><a href="#4-1负载测试（Load-Testing）" class="headerlink" title="4.1负载测试（Load Testing）"></a>4.1负载测试（Load Testing）</h3><p>给系统一个特定的条件，观察系统的反应情况，在不同的负载级别上逐步加大或减小。</p><h3 id="4-2压力测试（Stress-Testing）"><a href="#4-2压力测试（Stress-Testing）" class="headerlink" title="4.2压力测试（Stress Testing）"></a>4.2压力测试（Stress Testing）</h3><p>持续不断地对被测试系统增加压力，直到被压垮，从而确定系统能承受的最大压力。</p><p>压力测试主要考虑下面三个方面：长时间测试对软件造成的影响；大数据量对软件的影响；高频率数据对软件的影响。</p><h3 id="4-3性能测试（Performance-Testing）"><a href="#4-3性能测试（Performance-Testing）" class="headerlink" title="4.3性能测试（Performance Testing）"></a>4.3性能测试（Performance Testing）</h3><p>一般通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p><h3 id="4-4可靠性测试（Reliability-Testing）"><a href="#4-4可靠性测试（Reliability-Testing）" class="headerlink" title="4.4可靠性测试（Reliability Testing）"></a>4.4可靠性测试（Reliability Testing）</h3><p>可靠性测试是在给被测试系统加载一定业务压力的情况下，使系统运行一段时间，以此来测试系统是否稳定。</p><h3 id="4-5-容量测试（Volume-Testing）"><a href="#4-5-容量测试（Volume-Testing）" class="headerlink" title="4.5 容量测试（Volume Testing）"></a>4.5 容量测试（Volume Testing）</h3><p>一种是针对某些系统存储、传输、统计和查询等业务进行大数据量的独立数据容量测试；另外一种是与压力测试、负载测试、可靠性测试等相结合的极限状态下的综合数据容量测试。</p><h3 id="4-6安全性测试（Security-Testing）"><a href="#4-6安全性测试（Security-Testing）" class="headerlink" title="4.6安全性测试（Security Testing）"></a>4.6安全性测试（Security Testing）</h3><p>安全性测试是设计测试用例来突破程序安全检查的过程。</p><h3 id="4-7安装测试（Installation-Testing）"><a href="#4-7安装测试（Installation-Testing）" class="headerlink" title="4.7安装测试（Installation Testing）"></a>4.7安装测试（Installation Testing）</h3><p>安装测试是确保软件在正常情况和异常情况下能成功安装。</p><h3 id="4-8可用性测试（Usability-Testing）"><a href="#4-8可用性测试（Usability-Testing）" class="headerlink" title="4.8可用性测试（Usability Testing）"></a>4.8可用性测试（Usability Testing）</h3><p>可用性测试检查待测试软件的人机界面，通常要检查的部件包括界面布局和色彩、输入和输出格式、程序流程和拼写等，以发现其中的认人为因素和易用性等问题。</p><h3 id="4-9稳定性测试（Stability-Testing）"><a href="#4-9稳定性测试（Stability-Testing）" class="headerlink" title="4.9稳定性测试（Stability Testing）"></a>4.9稳定性测试（Stability Testing）</h3><p>稳定性测试方法主要尝试检测软件在其使用过程中性能是否稳定，以及是否会崩溃。</p><h3 id="4-10-本地化和国际化测试-Localization-and-Internationalization-Testing"><a href="#4-10-本地化和国际化测试-Localization-and-Internationalization-Testing" class="headerlink" title="4.10 本地化和国际化测试(Localization and Internationalization Testing)"></a>4.10 本地化和国际化测试(Localization and Internationalization Testing)</h3><p>在软件设计中除了语言本身，还要考虑用户所在的国家、地理位置和文化等因素，这个过程称为软件的本地化，有时也称软件的国际化。</p><h3 id="4-11-可访问性测试（Accessibility-Testing）"><a href="#4-11-可访问性测试（Accessibility-Testing）" class="headerlink" title="4.11 可访问性测试（Accessibility Testing）"></a>4.11 可访问性测试（Accessibility Testing）</h3><p>主要检测软件系统对于残疾人是否具有可访问性。</p><h3 id="4-12授权测试（Authorization-Testing）"><a href="#4-12授权测试（Authorization-Testing）" class="headerlink" title="4.12授权测试（Authorization Testing）"></a>4.12授权测试（Authorization Testing）</h3><p>授权测试是一种测试授权过程健壮性的方法，该方法通过理解授权工作原理和过程，利用这些信息来试图规避授权机制。</p><h3 id="4-13容错性测试（Fault-Tolerance-Testing）"><a href="#4-13容错性测试（Fault-Tolerance-Testing）" class="headerlink" title="4.13容错性测试（Fault Tolerance Testing）"></a>4.13容错性测试（Fault Tolerance Testing）</h3><p>容错性测试是指检查软件在异常条件下自身是否具有防护性的措施或某种灾难性恢复的手段。</p><h3 id="4-14一致性测试（Conformance-Testing）"><a href="#4-14一致性测试（Conformance-Testing）" class="headerlink" title="4.14一致性测试（Conformance Testing）"></a>4.14一致性测试（Conformance Testing）</h3><p>一致性测试或类型测试是测试一个产品在效率或互通性方面是否符合某个指定的标准。</p><h3 id="4-15配置测试（Configuration-Testing）"><a href="#4-15配置测试（Configuration-Testing）" class="headerlink" title="4.15配置测试（Configuration Testing）"></a>4.15配置测试（Configuration Testing）</h3><p>软件与硬件之间的交互测试称为配置测试，主要检测各种硬件环境是否能够支持软件的正常运行。</p><h3 id="4-16文档测试-Document-Testing"><a href="#4-16文档测试-Document-Testing" class="headerlink" title="4.16文档测试(Document Testing)"></a>4.16文档测试(Document Testing)</h3><p>主要是对相关的设计报告和用户使用说明进行测试。</p><h3 id="4-17兼容性测试-Compatibility-Testing"><a href="#4-17兼容性测试-Compatibility-Testing" class="headerlink" title="4.17兼容性测试(Compatibility Testing)"></a>4.17兼容性测试(Compatibility Testing)</h3><p>兼容性测试是指待测试项目在特定的硬件平台上，不同的应用软件之间，不同的操作系统平台上，在不同的网络等环境中能正常的运行的测试。</p><h3 id="4-18-试玩-（Playtest）"><a href="#4-18-试玩-（Playtest）" class="headerlink" title="4.18 试玩 （Playtest）"></a>4.18 试玩 （Playtest）</h3><p>试玩测试是在一种游戏设计开发过程中，在游戏投放市场之前，为了检查发现游戏中潜在的错误，进一步改进游戏而采取的一种测试方法。请游戏玩家来玩这个游戏，可以是开放式的、封闭的或者β式的。</p><h3 id="4-19-可恢复性测试（Recovery-Testing）"><a href="#4-19-可恢复性测试（Recovery-Testing）" class="headerlink" title="4.19 可恢复性测试（Recovery Testing）"></a>4.19 可恢复性测试（Recovery Testing）</h3><p>测试软件系统在故障发生后，重新建立其性能水平并恢复受影响数据的能力。</p><h3 id="4-20-卸载测试（Uninstall-Testing）"><a href="#4-20-卸载测试（Uninstall-Testing）" class="headerlink" title="4.20 卸载测试（Uninstall Testing）"></a>4.20 卸载测试（Uninstall Testing）</h3><p>卸载测试是对软件的全部、部分或升级卸载处理过程的测试。</p><h3 id="4-21-能力测试-Facility-Testing"><a href="#4-21-能力测试-Facility-Testing" class="headerlink" title="4.21 能力测试(Facility Testing)"></a>4.21 能力测试(Facility Testing)</h3><p>判断目标文档中的每一项能力是否确实已经实现。</p><h3 id="4-22-健壮性测试（Robustness-Testing）"><a href="#4-22-健壮性测试（Robustness-Testing）" class="headerlink" title="4.22 健壮性测试（Robustness Testing）"></a>4.22 健壮性测试（Robustness Testing）</h3><p>健壮性是指在异常情况下，软件还能正常运行的能力。健壮性有两层含义：一是容错能力；二是恢复能力。</p><h3 id="4-23-穿越测试（By-pass-Testing）"><a href="#4-23-穿越测试（By-pass-Testing）" class="headerlink" title="4.23 穿越测试（By-pass Testing）"></a>4.23 穿越测试（By-pass Testing）</h3><p>穿越测试通过构造测试用例来故意违反各种安全约束，其目的是验证输入检查，检查系统的鲁棒性和评估系统的安全性。</p><h3 id="4-24-在线帮助测试（Online-Help-Testing）"><a href="#4-24-在线帮助测试（Online-Help-Testing）" class="headerlink" title="4.24 在线帮助测试（Online Help Testing）"></a>4.24 在线帮助测试（Online Help Testing）</h3><p>验证系统的实时在线帮助的可用性和正确性。</p><h3 id="4-25-数据转换测试（Data-Conversion-Testing）"><a href="#4-25-数据转换测试（Data-Conversion-Testing）" class="headerlink" title="4.25 数据转换测试（Data Conversion Testing）"></a>4.25 数据转换测试（Data Conversion Testing）</h3><p>验证已存在的数据转换是否有效。 </p><p>考虑的因素：审计能力，数据库验证，数据整理，恢复计划。</p><h3 id="4-26-备份测试（Backup-Testing）"><a href="#4-26-备份测试（Backup-Testing）" class="headerlink" title="4.26 备份测试（Backup Testing）"></a>4.26 备份测试（Backup Testing）</h3><p>备份测试的目的是验证系统在软件或硬件失效的事件中备份其数据的能力。</p><h3 id="4-27接口测试（Interface-Testing）"><a href="#4-27接口测试（Interface-Testing）" class="headerlink" title="4.27接口测试（Interface Testing）"></a>4.27接口测试（Interface Testing）</h3><p>接口测试是对软件需求规格说明中的接口需求逐项进行的测试。</p><h3 id="4-28-人机交互界面测试（User-Interface-Testing）"><a href="#4-28-人机交互界面测试（User-Interface-Testing）" class="headerlink" title="4.28 人机交互界面测试（User Interface Testing）"></a>4.28 人机交互界面测试（User Interface Testing）</h3><p>人机交互界面测试对所有人机交互界面提供的操作和显示界面进行测试，以检验是否满足用户要求。</p><h3 id="4-29-余量测试（Remainder-Testing）"><a href="#4-29-余量测试（Remainder-Testing）" class="headerlink" title="4.29 余量测试（Remainder Testing）"></a>4.29 余量测试（Remainder Testing）</h3><p>保证程序执行过程中遇到资源以外的情况时，仍能维持正常运行状态。</p><h3 id="4-30-协议测试（Protocol-Testing）"><a href="#4-30-协议测试（Protocol-Testing）" class="headerlink" title="4.30 协议测试（Protocol Testing）"></a>4.30 协议测试（Protocol Testing）</h3><p>对实现的协议的正确性和有效性进行判别。</p><h3 id="4-31-内存泄漏测试（Memory-Leak-Testing）"><a href="#4-31-内存泄漏测试（Memory-Leak-Testing）" class="headerlink" title="4.31 内存泄漏测试（Memory Leak Testing）"></a>4.31 内存泄漏测试（Memory Leak Testing）</h3><p>对软件运行可能存在的各种内存泄露进行检查。</p><h3 id="4-32-存储测试-Storage-Testing"><a href="#4-32-存储测试-Storage-Testing" class="headerlink" title="4.32 存储测试 (Storage Testing)"></a>4.32 存储测试 (Storage Testing)</h3><p>对系统的存储功能进行测试，包括存储文件和存储介质。</p><h3 id="4-33-软件老化（software-aging）"><a href="#4-33-软件老化（software-aging）" class="headerlink" title="4.33 软件老化（software aging）"></a>4.33 软件老化（software aging）</h3><p>软件老化是在长期运行的软件系统上中，由于错误条件的积累和资源的逐步消耗导致软件系统的性能逐渐下降、错误率不断上升并最终出现故障的一类问题。</p><h3 id="4-34-不稳定性测试（flaky-testing）"><a href="#4-34-不稳定性测试（flaky-testing）" class="headerlink" title="4.34 不稳定性测试（flaky testing）"></a>4.34 不稳定性测试（flaky testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h2 id="5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"><a href="#5-简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）" class="headerlink" title="5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）"></a>5 简答题（核心检测能力是什么？或者说特点是什么？）（30分，每题1分）</h2><h3 id="5-1组合测试（Combinatorial-Testing）"><a href="#5-1组合测试（Combinatorial-Testing）" class="headerlink" title="5.1组合测试（Combinatorial Testing）"></a>5.1组合测试（Combinatorial Testing）</h3><p>组合测试是一种充分考虑各种因素及其相互作用的科学实用的软件测试方法，通过设计一组数量较少的测试用例，直接检测各种影响因素及其组合对软件产生的影响。</p><h3 id="5-2蜕变测试（Metamorphic-Testing）"><a href="#5-2蜕变测试（Metamorphic-Testing）" class="headerlink" title="5.2蜕变测试（Metamorphic Testing）"></a>5.2蜕变测试（Metamorphic Testing）</h3><p>蜕变测试一般指在预期输出无法给出的情况下，通过设计各种输入关系，观察输出是否满足预期的性质，用以判断软件的正确性。是一种基于性质的软件测试。</p><h3 id="5-3基于规格说明的软件测试-Specification-Based-Software-Testing"><a href="#5-3基于规格说明的软件测试-Specification-Based-Software-Testing" class="headerlink" title="5.3基于规格说明的软件测试(Specification Based Software Testing)"></a>5.3基于规格说明的软件测试(Specification Based Software Testing)</h3><p>基于规格说明的测试是验证软件的实现与规格说明的一致性。是一种黑盒测试技术。</p><h3 id="5-4基于模型的软件测试（model-based-testing）"><a href="#5-4基于模型的软件测试（model-based-testing）" class="headerlink" title="5.4基于模型的软件测试（model based testing）"></a>5.4基于模型的软件测试（model based testing）</h3><p>基于模型的软件测试可以根据软件行为模型和结构模型生成测试用例。</p><p>软件测试模型包括有限状态机、UML、文法等。</p><h3 id="5-5基于错误的软件测试-fault-based-testing"><a href="#5-5基于错误的软件测试-fault-based-testing" class="headerlink" title="5.5基于错误的软件测试(fault based testing)"></a>5.5基于错误的软件测试(fault based testing)</h3><p>基于错误的软件测试针对待测试软件中可能存在的某种软件错误，设计相应的测试用例，当运行这组测试用例时，如果没有发现错误，则认为该软件中不存在这类错误。</p><h3 id="5-6基于搜索的软件测试-Search-Based-Testing"><a href="#5-6基于搜索的软件测试-Search-Based-Testing" class="headerlink" title="5.6基于搜索的软件测试(Search Based Testing)"></a>5.6基于搜索的软件测试(Search Based Testing)</h3><p>基于搜素的软件测试是一种利用元启发式搜索技术自动生成测试数据的测试方法，可以进行结构测试、功能测试、灰盒测试、非功能性测试。</p><h3 id="5-7统计测试-Statistics-Testing"><a href="#5-7统计测试-Statistics-Testing" class="headerlink" title="5.7统计测试(Statistics Testing)"></a>5.7统计测试(Statistics Testing)</h3><p>统计测试是一种根据定义好的概率分布来随机选择测试用例的软件测试方法。</p><h3 id="5-8基于操作剖面的测试-Operational-Profile-Based-Testing"><a href="#5-8基于操作剖面的测试-Operational-Profile-Based-Testing" class="headerlink" title="5.8基于操作剖面的测试(Operational Profile Based Testing)"></a>5.8基于操作剖面的测试(Operational Profile Based Testing)</h3><p>基于操作剖面的测试是一种统计测试方法，它按照人们对软件各项功能的使用概率选择测试用例。</p><h3 id="5-9变异测试（Mutation-Testing）"><a href="#5-9变异测试（Mutation-Testing）" class="headerlink" title="5.9变异测试（Mutation Testing）"></a>5.9变异测试（Mutation Testing）</h3><p>变异测试通过在程序中植入一些程序员容易犯的错误，或利用相关的启发式方法植入一些错误，这些错误都是通过对原来的程序做一些句法上的修改，从而形成一组新的程序，称之为变异体，通过运行针对原程序的测试用例集，如果这些原来的测试用例能够发现变异体中错误，称之为杀死变异体，否则称为变异体存活。</p><h3 id="5-10脆弱性测试（flaky-Testing）"><a href="#5-10脆弱性测试（flaky-Testing）" class="headerlink" title="5.10脆弱性测试（flaky Testing）"></a>5.10脆弱性测试（flaky Testing）</h3><p>在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果。</p><h3 id="5-11基于性质的软件测试方法-Property-Based-Testing"><a href="#5-11基于性质的软件测试方法-Property-Based-Testing" class="headerlink" title="5.11基于性质的软件测试方法(Property-Based Testing)"></a>5.11基于性质的软件测试方法(Property-Based Testing)</h3><p>基于性质的测试通常假设待测试程序满足给定性质，围绕给定性质进行测试，验证软件是否满足其定义的性质。</p><h3 id="5-12极限测试-Extreme-Testing"><a href="#5-12极限测试-Extreme-Testing" class="headerlink" title="5.12极限测试(Extreme Testing)"></a>5.12极限测试(Extreme Testing)</h3><p>先创建单元测试和验收测试，然后再创建代码库，这种形式的测试叫极限测试，也叫测试驱动开发。</p><h3 id="5-13模糊测试（Fuzzing-Testing）"><a href="#5-13模糊测试（Fuzzing-Testing）" class="headerlink" title="5.13模糊测试（Fuzzing Testing）"></a>5.13模糊测试（Fuzzing Testing）</h3><p>模糊测试主要用于发现程序内部的安全漏洞和其他缺陷。通过向程序输入随机、无效或意外的数据，测试人员可以观察系统的反应，从而识别潜在的错误、崩溃和安全漏洞。</p><p>模糊测试是一种通过提供非预期的输入并监视异常结果来发现软件故障的方法。</p><h3 id="5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）"><a href="#5-14软件测试的控制论方法-Cybernetics-Based-Testing-自适应测试（Adaptive-Testing）" class="headerlink" title="5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）"></a>5.14软件测试的控制论方法(Cybernetics Based Testing)-自适应测试（Adaptive Testing）</h3><p>自适应测试也称为软件测试的控制论方法：是软件控制论的重要组成部分，它把软件测试的问题归结为控制问题，被测试软件当做被控制对象，软件测试策略当作相应的控制器，这样被测试软件和测试策略就构成一个闭环反馈控制系统。通过控制理论指导软件测试过程，从而希望达到科学有效地测试软件的目的。</p><p>自适应控制系统是通过在线实时了解被控对象，不断调节控制器，使系统的性能达到技术要求或最优。</p><h3 id="5-15导向性随机测试（Concolic-Testing）"><a href="#5-15导向性随机测试（Concolic-Testing）" class="headerlink" title="5.15导向性随机测试（Concolic Testing）"></a>5.15导向性随机测试（Concolic Testing）</h3><p>导向性随机测试是一种将具体执行与符号执行相结合的自动化测试方法，其目标是通过生成测试输入来执行程序中的所有可行路径，以发现程序缺陷。</p><h3 id="5-16图形用户界面测试（GUI-Testing）"><a href="#5-16图形用户界面测试（GUI-Testing）" class="headerlink" title="5.16图形用户界面测试（GUI Testing）"></a>5.16图形用户界面测试（GUI Testing）</h3><p>GUI测试是一种软件测试过程，测试的对象是软件产品的图形用户界面，目的是确保图形用户界面符合用户要求或规格说明书要求。</p><h3 id="5-17随机测试-Random-Testing"><a href="#5-17随机测试-Random-Testing" class="headerlink" title="5.17随机测试(Random Testing)"></a>5.17随机测试(Random Testing)</h3><p>在待测试软件所有可能的输入中，随机选择和产生测试输入并对待测试软件进行测试，这种测试方法叫做随机测试。</p><h3 id="5-18自适应随机测试-Adaptive-Random-Testing"><a href="#5-18自适应随机测试-Adaptive-Random-Testing" class="headerlink" title="5.18自适应随机测试(Adaptive Random Testing)"></a>5.18自适应随机测试(Adaptive Random Testing)</h3><p>一个测试用例如果没有发现软件故障，那么另一个相近或相似的测试用例可能也不会发现软件故障，因此在选择下一个测试用例时，要尽可能选择距离该测试用例远一点的测试。即使得测试用例尽可能均匀分散开。</p><p>自适应随机测试方法强调在随机选择测试用例的过程中，要使得测试用例尽可能均与地分散开，这样随机产生的测试用例才有可能有更多机会发现软件故障。</p><h3 id="5-19反随机测试（Antirandom-Testing）"><a href="#5-19反随机测试（Antirandom-Testing）" class="headerlink" title="5.19反随机测试（Antirandom Testing）"></a>5.19反随机测试（Antirandom Testing）</h3><p>首先为待测试软件随机生成一个测试用例，随后每一个测试用例的生成都要求与已生成的测试用例保持最大的距离。</p><p>第一个测试用例是随机的，后面的测试用例可以看作是确定的。</p><h3 id="5-20结对测试-Pair-Testing"><a href="#5-20结对测试-Pair-Testing" class="headerlink" title="5.20结对测试(Pair Testing)"></a>5.20结对测试(Pair Testing)</h3><p>结对测试是由两个测试人员结对在一起对待测试软件进行测试的方法，一个测试人员控制鼠标和键盘，另一个测试人员做记录，一起讨论测试场景，提问题。结对的两个测试人员一般一个是专业测试人员，一个是开发人员或业务分析员。</p><h3 id="5-21在线测试（Online-Testing）"><a href="#5-21在线测试（Online-Testing）" class="headerlink" title="5.21在线测试（Online Testing）"></a>5.21在线测试（Online Testing）</h3><p>在线测试，也称为动态测试，该方法在待测试软件运行过程中动态产生测试用例，而不是事先产生测试用例。</p><h3 id="5-22探索性测试（Exploratory-Testing）"><a href="#5-22探索性测试（Exploratory-Testing）" class="headerlink" title="5.22探索性测试（Exploratory Testing）"></a>5.22探索性测试（Exploratory Testing）</h3><p>这种测试方法强调测试人员个人的自由和责任，可以充分发挥他们的创造性和积极性，它把测试过程看成是一种与测试相关的学习，测试设计、测试执行和测试结果的解释同时进行且相互促进。</p><p>探索性测试的特点：强调测试设计与测试执行的同时性，这种同时性是相对传统软件测试过程中的先设计后测试来说的。测试工程师通过测试来不断学习被测试系统，通过学习来改进测试过程。探索性测试强调自由性和创造性。</p><h3 id="5-23反模型测试（Anti-model-Testing）"><a href="#5-23反模型测试（Anti-model-Testing）" class="headerlink" title="5.23反模型测试（Anti-model Testing）"></a>5.23反模型测试（Anti-model Testing）</h3><p>反模型测试和基于模型的测试方法相反，它一开始没有模型可用，通过执行一些抽样出来的测试用例，观察系统行为，并将这些信息综合起来，通过分析推理形成关于系统的一个抽象的模型。</p><h3 id="5-24成分测试（Compositional-Testing）"><a href="#5-24成分测试（Compositional-Testing）" class="headerlink" title="5.24成分测试（Compositional Testing）"></a>5.24成分测试（Compositional Testing）</h3><p>用分治法把复杂的大规模软件测试分解为测试该软件的各个组成成分。</p><p>成分测试是一种在软件工程中用于验证和验证软件组件的技术。它关注于系统的组成部分——例如软件模块、组件或服务——如何组合在一起，以及这些组合如何影响系统的整体性能和行为。</p><h3 id="5-25-有限状态机测试（FSM-Testing）"><a href="#5-25-有限状态机测试（FSM-Testing）" class="headerlink" title="5.25 有限状态机测试（FSM Testing）"></a>5.25 有限状态机测试（FSM Testing）</h3><p>有限状态机测试是一种基于有限状态机理论的测试方法，广泛应用于软件系统和硬件设计的测试中。有限状态机（FSM）是一种数学模型，用于描述系统在不同状态之间的转移和行为。FSM Testing 的主要目标是验证系统在不同输入下的状态转移是否符合预期，确保软件或硬件的功能正确性。</p><h3 id="5-26-基于Petri网的测试（Petri-Net-based-Testing）"><a href="#5-26-基于Petri网的测试（Petri-Net-based-Testing）" class="headerlink" title="5.26 基于Petri网的测试（Petri Net based Testing）"></a>5.26 基于Petri网的测试（Petri Net based Testing）</h3><p>Petri网是一种图形化的形式化语言表示法, 该方法采用具有形式语义的图形语言, 既有严格的数学定义，又有直观的图形表示。</p><p>FSM一般是顺序性的，它定义的状态一般都是全局的状态；而Petri网一般是并行的，它定义的状态一般都是分布式的。</p><h3 id="5-27-基于模型检查的测试（Model-Checking-based-Testing）"><a href="#5-27-基于模型检查的测试（Model-Checking-based-Testing）" class="headerlink" title="5.27 基于模型检查的测试（Model Checking based Testing）"></a>5.27 基于模型检查的测试（Model Checking based Testing）</h3><p>模型检测的基本思想：用状态迁移系统（S）表示系统的行为，用模态&#x2F; 时序逻辑公式（F）描述系统的性质.。这样“系统是否具有所期望的性质”就转化为数学问题“状态迁移系统S是否是公式F 的一个模型？”</p><p>将一个过程或系统抽象成一个有穷状态模型，加以分析验证。</p><p>与测试不同，模型检测不是针对某组输入，而是面向某类性质来检查系统是否合乎规约!</p><h3 id="5-28-TTCN测试（TTCN-Testing）"><a href="#5-28-TTCN测试（TTCN-Testing）" class="headerlink" title="5.28 TTCN测试（TTCN Testing）"></a>5.28 TTCN测试（TTCN Testing）</h3><p>TTCN（Testing and Test Control Notation）是一种专门为测试系统和协议设计的标准化测试语言，广泛应用于电信、网络和其他领域的系统验证与测试中。TTCN允许测试人员定义测试用例、测试脚本和测试执行过程，以确保被测试对象（被测系统）符合其设计规范。</p><h3 id="5-29-布尔规格测试（Boolean-Specification-Testing）"><a href="#5-29-布尔规格测试（Boolean-Specification-Testing）" class="headerlink" title="5.29 布尔规格测试（Boolean Specification Testing）"></a>5.29 布尔规格测试（Boolean Specification Testing）</h3><p>如何根据这些布尔表达式设计测试用例来测试根据这些布尔规格说明建立起来的软件，并发现其中隐藏的错误是布尔规格测试的关键问题。 </p><h3 id="5-30-基于统一建模语言测试（UML-Based-Testing）"><a href="#5-30-基于统一建模语言测试（UML-Based-Testing）" class="headerlink" title="5.30 基于统一建模语言测试（UML Based Testing）"></a>5.30 基于统一建模语言测试（UML Based Testing）</h3><p>UML是一种可视化的面向对象系统建模描述工具。所谓基于UML的测试，就是应用待测试软件系统的UML模型来获得软件测试的需求和覆盖准则。</p><h3 id="5-31-差分测试（differential-testing）"><a href="#5-31-差分测试（differential-testing）" class="headerlink" title="5.31 差分测试（differential testing）"></a>5.31 差分测试（differential testing）</h3><p>主要用于比较两个或多个实现（例如，不同版本的程序或不同的实现算法）在相同输入下的输出结果，以发现潜在的缺陷或不一致之处。差分测试常用于确保新版本的软件相对于旧版本或不同实现之间的兼容性和一致性。</p><h3 id="5-32故障注入测试（Fault-Injection-Testing）"><a href="#5-32故障注入测试（Fault-Injection-Testing）" class="headerlink" title="5.32故障注入测试（Fault Injection Testing）"></a>5.32故障注入测试（Fault Injection Testing）</h3><p>故障注入测试是一种强大的软件测试技术，其主要目的是通过故意向系统中注入故障，验证系统在面对错误或异常情况下的反应和处理能力。这种测试可以帮助开发者发现潜在问题，评估系统的健壮性、可靠性和容错能力。</p><h2 id="6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"><a href="#6-简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）" class="headerlink" title="6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）"></a>6 简单分析评论题（软件的特点是什么？测试方法有哪些特殊性？）（10分，每题1分）</h2><h3 id="6-1面向对象软件的测试-Object-Oriented-Software-Testing"><a href="#6-1面向对象软件的测试-Object-Oriented-Software-Testing" class="headerlink" title="6.1面向对象软件的测试(Object Oriented Software Testing)"></a>6.1面向对象软件的测试(Object Oriented Software Testing)</h3><p>面向对象软件测试是一种专门针对面向对象编程（Object-Oriented Programming, OOP）设计的软件测试方法。由于面向对象的程序具有独特的特性，如<strong>封装、继承、多态</strong>，传统的软件测试方法并不总是适用于这种编程范式。因此，面向对象软件测试的重点在于处理这些独特的特性，并在测试中有效地验证程序的正确性、性能和可靠性。</p><p>测试对象间的交互、继承关系和多态性，确保类之间的继承结构和方法重载、重写等特性不会引发错误。面向对象的软件测试需要关注更细致的粒度，如类的内部状态、对象间的消息传递和状态变更。</p><h3 id="6-2面向方面的软件测试-Aspect-Oriented-Software-Testing"><a href="#6-2面向方面的软件测试-Aspect-Oriented-Software-Testing" class="headerlink" title="6.2面向方面的软件测试(Aspect Oriented Software Testing)"></a>6.2面向方面的软件测试(Aspect Oriented Software Testing)</h3><p>该编程范型主要强调将软件系统特别是面向对象系统中的分布在各种类和对象中的关注点（即所谓横切关注点）分离出来，实现比原来系统更好的模块化。</p><p>面向方面编程的核心就是将分散在多个模块中的一些核心关注点、中心功能，如登录功能和认证功能等，从这些模块中分离出来，横切出来的关注点独立地实现为系统的一个方面，这个方面的具体实现可以利用传统方法，例如面向对象的方法。</p><h3 id="6-3面向服务的软件测试-Service-Oriented-Software-Testing"><a href="#6-3面向服务的软件测试-Service-Oriented-Software-Testing" class="headerlink" title="6.3面向服务的软件测试(Service Oriented Software Testing)"></a>6.3面向服务的软件测试(Service Oriented Software Testing)</h3><p>面向服务的软件测试原理主要依赖于服务导向架构（SOA）和微服务架构的核心概念。该测试方法关注于确保各个服务之间的正常交互和完整性，以提供高质量的系统。</p><p>主要测试服务的功能、服务间的通信（如消息队列、API接口）、服务的独立性及其异常处理。重点是验证服务的接口、协议兼容性和依赖关系。</p><h3 id="6-4构件软件测试-Component-Based-Software-Testing"><a href="#6-4构件软件测试-Component-Based-Software-Testing" class="headerlink" title="6.4构件软件测试(Component Based Software Testing)"></a>6.4构件软件测试(Component Based Software Testing)</h3><p>基于构件的软件测试，是指在构件（Component）基础上进行的测试过程，构件可以是软件系统中的独立模块、服务或功能单元。这种测试方法强调构件的可重用性和互操作性，以提高软件开发的效率和质量。</p><p>专注于验证和评估软件系统中各个独立组件的功能和交互。此方法适用于组件化的软件开发模型，其中软件系统由多个松耦合、可重用的组件构成。</p><h3 id="6-5-Web应用软件测试-WEB-Testing"><a href="#6-5-Web应用软件测试-WEB-Testing" class="headerlink" title="6.5 Web应用软件测试(WEB Testing)"></a>6.5 Web应用软件测试(WEB Testing)</h3><p>对于WEB应用软件来说，WEB应用软件的测试具有更大的挑战。测试也是为了发现软件的错误并最终修正错误而运行软件的过程，但由于基于WEB的系统和应用存在于网络上，并且和很多不同的操作系统、浏览器（或其他界面设备如PDA、手机等）、硬件平台、通信协议、后台应用进行交互。</p><p>Web测试需要关注跨浏览器兼容性、页面加载速度、响应式设计、安全性（如XSS、SQL注入）、以及多用户并发操作等因素</p><h3 id="6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing"><a href="#6-6普适计算环境下的软件测试-Pervasive-Computing-Software-Testing" class="headerlink" title="6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)"></a>6.6普适计算环境下的软件测试(Pervasive Computing Software Testing)</h3><p>普适计算（又称无处不在计算）指的是计算设备无处不在地嵌入到环境中，测试需要关注多种设备的互联和环境感知。</p><p>测试需要考虑设备间的协同、网络带宽和延迟、环境变化对系统的影响等，还要考虑设备的电池寿命、隐私保护和数据传输安全等因素。</p><p>普适计算环境下的软件测试是指在一个无处不在且高度集成的计算环境中，对软件系统进行的测试。在这样的环境中，计算设备和服务可以无缝地集成到日常生活中，用户可能会通过多种设备和场景与软件互动。</p><p>普适计算软件测试面临的挑战：</p><ul><li>上下文背景是挥发性的和瞬发的</li><li>普适计算环境中的物理背景本质上是不稳定的，有干扰和不精确的</li><li>普适计算软件中的各个计算实体是独立的和自我为中心的</li></ul><h3 id="6-7云测试-Cloud-Testing"><a href="#6-7云测试-Cloud-Testing" class="headerlink" title="6.7云测试(Cloud Testing)"></a>6.7云测试(Cloud Testing)</h3><p> 云测试本质上是一种软件测试形式，其中网络应用程序使用云计算环境来模拟现实世界的用户流量作为负载和压力测试的一种方式，测试是利用云端的资源（如主机或服务等），此外，整个测试环境可以按需的从云端获得。</p><h3 id="6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things"><a href="#6-8物联网环境下的软件测试-Software-Testing-for-Internet-of-Things" class="headerlink" title="6.8物联网环境下的软件测试(Software Testing for Internet of Things)"></a>6.8物联网环境下的软件测试(Software Testing for Internet of Things)</h3><p>物联网的定义是：通过射频识别（RFID）、红外感应器、全球定位系统、激光扫描器等信息传感设备，按约定的协议，把任何物体与互联网相连接，进行信息交换和通信，以实现对物体的智能化识别、定位、跟踪、监控和管理的一种网络。</p><p>物联网（IoT）测试是对物联网设备及其系统性能、功能和安全性的评估过程。</p><h3 id="6-9并行软件测试-Concurrent-Software-Testing"><a href="#6-9并行软件测试-Concurrent-Software-Testing" class="headerlink" title="6.9并行软件测试(Concurrent Software Testing)"></a>6.9并行软件测试(Concurrent Software Testing)</h3><p>并行软件是指设计为支持同时执行多个计算或操作的应用程序。这类软件可以通过多线程、分布式计算或多核心处理器来实现并行处理，从而提高性能和响应能力。</p><p>并行软件的测试通常指的是在开发并行处理或多线程应用程序时，针对这些并行特性进行的测试。</p><h3 id="6-10嵌入式软件测试-Embedded-Software-Testing"><a href="#6-10嵌入式软件测试-Embedded-Software-Testing" class="headerlink" title="6.10嵌入式软件测试(Embedded Software Testing"></a>6.10嵌入式软件测试(Embedded Software Testing</h3><p>嵌入式软件测试&#x2F;嵌入式测试或叫交叉测试（cross-test）的目的与非嵌入式软件是相同的。</p><p>嵌入式测试强调对硬件资源的高效利用和系统的实时性，需要考虑嵌入式系统的稳定性、响应时间、资源消耗等因素，且测试环境往往比较特殊。</p><h3 id="6-11高可信软件测试-High-Confidence-Software-Testing"><a href="#6-11高可信软件测试-High-Confidence-Software-Testing" class="headerlink" title="6.11高可信软件测试(High Confidence Software Testing)"></a>6.11高可信软件测试(High Confidence Software Testing)</h3><p>可信性是软件的行为及结果符合人们的预期，在操作失误、环境影响、外部攻击等干扰时，仍然可以提供连续的服务。 </p><p>测试过程中不仅需要进行功能验证，还要进行严格的容错、冗余性、安全性和恢复能力的测试，确保软件能够在关键情况下保持高可靠性。</p><h3 id="6-12网构软件测试（Internetware-testing）"><a href="#6-12网构软件测试（Internetware-testing）" class="headerlink" title="6.12网构软件测试（Internetware testing）"></a>6.12网构软件测试（Internetware testing）</h3><p>网构软件是指与网络紧密结合的软件，强调在分布式网络环境中运行。测试需要验证其在多变的网络环境中的表现。 </p><p>测试需关注网络变化（如延迟、带宽限制）对软件性能和稳定性的影响，特别是网络通信的可靠性和数据一致性。</p><h3 id="6-13移动应用软件测试（app-testing）"><a href="#6-13移动应用软件测试（app-testing）" class="headerlink" title="6.13移动应用软件测试（app testing）"></a>6.13移动应用软件测试（app testing）</h3><p>手机软件测试是确保移动应用质量和用户体验的重要过程。它涉及对手机应用程序进行功能、性能、安全性和用户体验等多方面的验证。</p><h3 id="6-14-人工智能软件测试（Artificial-intelligence-testing）"><a href="#6-14-人工智能软件测试（Artificial-intelligence-testing）" class="headerlink" title="6.14 人工智能软件测试（Artificial intelligence testing）"></a>6.14 人工智能软件测试（Artificial intelligence testing）</h3><p>人工智能软件的测试是一个复杂但至关重要的过程，涉及确保AI系统在不同场景下的有效性、可靠性和安全性。</p><p>特点：不确定性和不透明性；数据依赖性；动态变化；非确定性输出；伦理和法律合规性。</p><h3 id="6-15-区块链软件系统测试-blockchain-software-testing"><a href="#6-15-区块链软件系统测试-blockchain-software-testing" class="headerlink" title="6.15 区块链软件系统测试(blockchain software testing)"></a>6.15 区块链软件系统测试(blockchain software testing)</h3><p>区块链软件是指用于创建、管理和维护区块链网络的各种应用程序和平台。这些软件提供了一个去中心化的环境，用于交易、数据存储和智能合约等功能。</p><p>测试重点是验证区块链协议的实现，如交易验证、数据一致性、网络中节点的协作以及安全性。区块链软件测试是确保开发出安全、可靠和高效的区块链应用的关键步骤。</p><h3 id="6-16-云宇宙测试-metaverse-testing）"><a href="#6-16-云宇宙测试-metaverse-testing）" class="headerlink" title="6.16 云宇宙测试(metaverse testing）"></a>6.16 云宇宙测试(metaverse testing）</h3><p>元宇宙（metaverse）是一种虚拟空间，结合了增强现实（AR）、虚拟现实（VR）、区块链和社交网络等技术，允许用户在一个共享的数字世界中进行互动和体验。这个概念不仅限于单一的平台或应用，而是一个广泛的生态系统，用户可以在其中进行社交、游戏、工作、教育和创造。</p><p>元宇宙测试是在虚拟环境中评估、验证和优化不同功能和内容的过程。这可以涉及诸多方面，包括用户体验、性能、安全性和交互性等。</p>]]></content>
      
      
      <categories>
          
          <category> Software Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
            <tag> Automated Testing </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
